<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AQS简述</title>
    <url>/2021/05/29/AQS%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<p>AbstractQuenedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。</p>
<p>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包</p>
<p><strong>AQS的核心思想</strong>是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。</p>
<p><strong>AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。</strong></p>
<p>用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p>
<p><strong>注意：AQS是自旋锁：</strong>在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功</p>
<p>转自：<a href="https://blog.csdn.net/mulinsen77/article/details/84583716">AQS原理</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA快捷键总结</title>
    <url>/2021/06/02/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>1</th>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>Ctrl+Shift+A</td>
<td>搜索操作方式</td>
</tr>
<tr>
<td>3</td>
<td>Ctrl+Space</td>
<td>基本代码补全，输入字母按后列出匹配的词组</td>
</tr>
<tr>
<td>4</td>
<td>Ctrl+Shift+Space</td>
<td>智能代码补全，列出与预期类型一致的方法或变量</td>
</tr>
<tr>
<td>5</td>
<td>Ctrl+Alt+Space</td>
<td>补全类名</td>
</tr>
<tr>
<td>6</td>
<td>Ctrl+Shift+Enter</td>
<td>补全语句</td>
</tr>
<tr>
<td>7</td>
<td>Ctrl+P</td>
<td>显示方法参数</td>
</tr>
<tr>
<td>8</td>
<td>Ctrl+Q</td>
<td>显示注释文档</td>
</tr>
<tr>
<td>9</td>
<td>Shift+F1</td>
<td>显示外部文档</td>
</tr>
<tr>
<td>10</td>
<td>Ctrl+mouse  over code</td>
<td>显示描述信息</td>
</tr>
<tr>
<td>11</td>
<td>Ctrl+F1</td>
<td>示提示、警告、错误等信息</td>
</tr>
<tr>
<td>12</td>
<td>Alt+lnsert</td>
<td>生成代码，生成Getter、Setter构造器等</td>
</tr>
<tr>
<td>13</td>
<td>Ctrl+O</td>
<td>重写父类方法</td>
</tr>
<tr>
<td>14</td>
<td>Ctrl+I</td>
<td>实现接口方法</td>
</tr>
<tr>
<td>15</td>
<td>Ctrl+/</td>
<td>使用“//”注释或取消注释</td>
</tr>
<tr>
<td>16</td>
<td>Ctrl+Shift+/</td>
<td>使用“/** **/”注释或取消注释</td>
</tr>
<tr>
<td>17</td>
<td>Ctrl+W</td>
<td>选择代码块，连续按会增加选择外层的代码块</td>
</tr>
<tr>
<td>18</td>
<td>Ctrl+Shift+W</td>
<td>与“Ctrl+W”相反，减少选择代码块</td>
</tr>
<tr>
<td>19</td>
<td>Alt+Q</td>
<td>显示类描述信息</td>
</tr>
<tr>
<td>20</td>
<td>Alt+Enter-fixes</td>
<td>显示快速修复列表</td>
</tr>
<tr>
<td>21</td>
<td>Ctrl+Alt+L</td>
<td>格式化代码</td>
</tr>
<tr>
<td>22</td>
<td>Ctrl+Alt+O</td>
<td>优化 Imports</td>
</tr>
<tr>
<td>23</td>
<td>Ctrl+Alt+I</td>
<td>自动优化代码缩进</td>
</tr>
<tr>
<td>24</td>
<td>Tab/Shift+Tab</td>
<td>缩进代码/取消缩进代码</td>
</tr>
<tr>
<td>25</td>
<td>Ctrl+X  or Shift+Delete</td>
<td>缩进代码/取消缩进代码</td>
</tr>
<tr>
<td>26</td>
<td>Ctrl+C  or Ctrl+lnsert</td>
<td>剪切代码，未选择代码时剪切当前行</td>
</tr>
<tr>
<td>27</td>
<td>Ctrl+V  or Shift+lnsert</td>
<td>粘贴代码</td>
</tr>
<tr>
<td>28</td>
<td>Ctrl+Shift+V</td>
<td>粘贴最近复制的内容</td>
</tr>
<tr>
<td>29</td>
<td>Ctrl+D</td>
<td>重复代码，未选择代码时重复当前行</td>
</tr>
<tr>
<td>30</td>
<td>Ctrl+Y</td>
<td>删除行，未选择时删除当前行</td>
</tr>
<tr>
<td>31</td>
<td>Ctrl+Shift+J</td>
<td>合并多行为一行</td>
</tr>
<tr>
<td>32</td>
<td>Ctrl+Enter</td>
<td>分割一行为多行</td>
</tr>
<tr>
<td>33</td>
<td>Shift+Enter</td>
<td>使光标所在位置的下一行为新行</td>
</tr>
<tr>
<td>34</td>
<td>Ctrl+Shift+U</td>
<td>对选中内容进行大小写切换</td>
</tr>
<tr>
<td>35</td>
<td>Ctrl+Shift+]/[</td>
<td>选中到代码块的开始/结束</td>
</tr>
<tr>
<td>36</td>
<td>Ctrl+Delete</td>
<td>删除从光标所在位置到单词结束位置的字符</td>
</tr>
<tr>
<td>37</td>
<td>Ctrl+Backspace</td>
<td>删除从单词起始位置到光标所在位置的字符</td>
</tr>
<tr>
<td>38</td>
<td>Ctrl+NumPad+/-</td>
<td>展开或收起代码块</td>
</tr>
<tr>
<td>39</td>
<td>Ctrl+Shift+NumPad+</td>
<td>展幵所有代码块</td>
</tr>
<tr>
<td>40</td>
<td>Ctrl+Shift+NumPad-</td>
<td>收起所有代码块</td>
</tr>
<tr>
<td>41</td>
<td>Ctrl+F4</td>
<td>关闭当前编辑页</td>
</tr>
<tr>
<td>42</td>
<td>Ctrl+F</td>
<td>查找</td>
</tr>
<tr>
<td>43</td>
<td>F3</td>
<td>查找下一个</td>
</tr>
<tr>
<td>44</td>
<td>Shift+F3</td>
<td>查找上一个</td>
</tr>
<tr>
<td>45</td>
<td>Ctrl+R</td>
<td>替换</td>
</tr>
<tr>
<td>46</td>
<td>Ctrl+Shift+F</td>
<td>目录内查找</td>
</tr>
<tr>
<td>47</td>
<td>Ctrl+Shift+R</td>
<td>目录内替换</td>
</tr>
<tr>
<td>48</td>
<td>Ctrl+Shift+S</td>
<td>语法模板搜索</td>
</tr>
<tr>
<td>49</td>
<td>Ctrl+Shift+M</td>
<td>语法模板替换</td>
</tr>
<tr>
<td>50</td>
<td>Alt+F7</td>
<td>查找被使用处</td>
</tr>
<tr>
<td>51</td>
<td>Ctrl+F7</td>
<td>查找当前文件中的使用处</td>
</tr>
<tr>
<td>52</td>
<td>Ctrl+Shift+F7</td>
<td>高亮当前文件中的使用处</td>
</tr>
<tr>
<td>53</td>
<td>Ctrl+Alt+F7</td>
<td>列出使用者</td>
</tr>
<tr>
<td>54</td>
<td>Ctrl+F9</td>
<td>Make模块、项目</td>
</tr>
<tr>
<td>55</td>
<td>Ctrl+Shift+F9</td>
<td>编译选中的文件、模块、项目</td>
</tr>
<tr>
<td>56</td>
<td>Alt+Shift+F10</td>
<td>选择配置后运行代码</td>
</tr>
<tr>
<td>57</td>
<td>Alt+Shift+F9</td>
<td>选择配置后调试代码</td>
</tr>
<tr>
<td>58</td>
<td>Shift+F10</td>
<td>运行代码</td>
</tr>
<tr>
<td>59</td>
<td>Shift+F9</td>
<td>调试代码</td>
</tr>
<tr>
<td>60</td>
<td>Ctrl+F2</td>
<td>停止调试</td>
</tr>
<tr>
<td>61</td>
<td>F8</td>
<td>单步调试，不进入函数内部</td>
</tr>
<tr>
<td>62</td>
<td>F7</td>
<td>单步调试，进入函数内部</td>
</tr>
<tr>
<td>63</td>
<td>Shift+F7</td>
<td>选择要进入的函数</td>
</tr>
<tr>
<td>64</td>
<td>Shift+F8</td>
<td>跳出函数</td>
</tr>
<tr>
<td>65</td>
<td>Alt+F9</td>
<td>运行到断点</td>
</tr>
<tr>
<td>66</td>
<td>Alt+F8</td>
<td>执行表达式查看结果</td>
</tr>
<tr>
<td>67</td>
<td>F9</td>
<td>继续执行，进入下一个断点或执行完程序</td>
</tr>
<tr>
<td>68</td>
<td>Ctrl+F8</td>
<td>设置/取消当前行断点</td>
</tr>
<tr>
<td>69</td>
<td>Ctrl+Shift+F8</td>
<td>查看断点</td>
</tr>
<tr>
<td>70</td>
<td>双击  Shift</td>
<td>查找所有</td>
</tr>
<tr>
<td>71</td>
<td>Ctrl+N</td>
<td>查找类</td>
</tr>
<tr>
<td>72</td>
<td>Ctrl+Shift+N</td>
<td>查找文件</td>
</tr>
<tr>
<td>73</td>
<td>Ctrl+Alt+Shift+N</td>
<td>Go to symbol</td>
</tr>
<tr>
<td>74</td>
<td>Alt+Right/Left</td>
<td>左右切换Tab</td>
</tr>
<tr>
<td>75</td>
<td>F12</td>
<td>回到上一个打开的窗口</td>
</tr>
<tr>
<td>76</td>
<td>Esc</td>
<td>焦点回到编辑器</td>
</tr>
<tr>
<td>77</td>
<td>Shift+Esc</td>
<td>隐藏打开的视图</td>
</tr>
<tr>
<td>78</td>
<td>Ctrl+Shift+F4</td>
<td>关闭当前Tab</td>
</tr>
<tr>
<td>79</td>
<td>Ctrl+G</td>
<td>跳到指定行</td>
</tr>
<tr>
<td>80</td>
<td>Ctrl+E</td>
<td>显示最近打开的文件</td>
</tr>
<tr>
<td>81</td>
<td>Ctrl+Alt+Left</td>
<td>跳到光标的上一个位置</td>
</tr>
<tr>
<td>82</td>
<td>Ctrl+Alt+Right</td>
<td>跳到光标的下一个位置</td>
</tr>
<tr>
<td>83</td>
<td>Ctrl+Shift+Backspace</td>
<td>跳到上一个编辑处</td>
</tr>
<tr>
<td>84</td>
<td>Alt+F1</td>
<td>选择当前文件显示在不同的视图</td>
</tr>
<tr>
<td>85</td>
<td>Ctrl+Bor/Ctrl+Click</td>
<td>跳到类声明处</td>
</tr>
<tr>
<td>86</td>
<td>Ctrl+Alt+B</td>
<td>跳到实现类/方法</td>
</tr>
<tr>
<td>87</td>
<td>Ctrl+Shift+I</td>
<td>显示类/变量/方法定义</td>
</tr>
<tr>
<td>88</td>
<td>Ctrl+Shift+B</td>
<td>跳到类型定义处</td>
</tr>
<tr>
<td>89</td>
<td>Ctrl+U</td>
<td>跳到父类/方法</td>
</tr>
<tr>
<td>90</td>
<td>Alt+Up</td>
<td>光标移动到上一个方法</td>
</tr>
<tr>
<td>91</td>
<td>Alt+Down</td>
<td>光标移动到下一个方法</td>
</tr>
<tr>
<td>92</td>
<td>Ctrl+[</td>
<td>光标移动到代码块的起始位置</td>
</tr>
<tr>
<td>93</td>
<td>Ctrl+]</td>
<td>光标移动到代码块的结束位置</td>
</tr>
<tr>
<td>94</td>
<td>Ctrl+F12</td>
<td>显示文件结构</td>
</tr>
<tr>
<td>95</td>
<td>Ctrl+H</td>
<td>显示类层级</td>
</tr>
<tr>
<td>96</td>
<td>Ctrl+Shift+H</td>
<td>显示方法层级</td>
</tr>
<tr>
<td>97</td>
<td>Ctrl+Alt+H</td>
<td>显示类/方法调用层级</td>
</tr>
<tr>
<td>98</td>
<td>F2</td>
<td>光标移动到下一个错误</td>
</tr>
<tr>
<td>99</td>
<td>Shift+F2</td>
<td>光标移动到上一个错误</td>
</tr>
<tr>
<td>100</td>
<td>F4</td>
<td>编辑源码，光标移到编辑器内</td>
</tr>
<tr>
<td>101</td>
<td>Ctrl+Enter</td>
<td>查看源码，光标没移到编辑器内</td>
</tr>
<tr>
<td>102</td>
<td>Alt+Home</td>
<td>显示导航面包屑</td>
</tr>
<tr>
<td>103</td>
<td>F11</td>
<td>当前行设置书签</td>
</tr>
<tr>
<td>104</td>
<td>Shift+F11</td>
<td>显示所有书签</td>
</tr>
<tr>
<td>105</td>
<td>Ctrl+F11</td>
<td>设置书签号［0-9］</td>
</tr>
<tr>
<td>106</td>
<td>Ctrl+[0-9]</td>
<td>跳到书签号［0-9］所在位置</td>
</tr>
<tr>
<td>107</td>
<td>F5</td>
<td>复制类</td>
</tr>
<tr>
<td>108</td>
<td>F6</td>
<td>移动类</td>
</tr>
<tr>
<td>109</td>
<td>Alt+Delete</td>
<td>安全删除，删除前会提示调用处</td>
</tr>
<tr>
<td>110</td>
<td>Shift+F6</td>
<td>重命名</td>
</tr>
<tr>
<td>111</td>
<td>Ctrl+F6</td>
<td>重构方法参数、Exception等</td>
</tr>
<tr>
<td>112</td>
<td>Ctrl+Alt+N</td>
<td>合并多行为一行</td>
</tr>
<tr>
<td>113</td>
<td>Ctrl+Alt+M</td>
<td>提取为新方法</td>
</tr>
<tr>
<td>114</td>
<td>Ctrl+Alt+V</td>
<td>提取为新变量</td>
</tr>
<tr>
<td>115</td>
<td>Ctrl+Alt+F</td>
<td>提取为对象新属性</td>
</tr>
<tr>
<td>116</td>
<td>Ctrl+Alt+C</td>
<td>提取为新静态常量</td>
</tr>
<tr>
<td>117</td>
<td>Alt+0</td>
<td>聚焦到Messages窗口</td>
</tr>
<tr>
<td>118</td>
<td>Alt+1</td>
<td>焦到Project窗口</td>
</tr>
<tr>
<td>119</td>
<td>Alt+2</td>
<td>聚焦到Favorite窗口</td>
</tr>
<tr>
<td>120</td>
<td>Alt+3</td>
<td>聚焦到Find窗口</td>
</tr>
<tr>
<td>121</td>
<td>Alt+4</td>
<td>聚焦到Run窗口</td>
</tr>
<tr>
<td>122</td>
<td>Alt+5</td>
<td>聚焦到Debug窗口</td>
</tr>
<tr>
<td>123</td>
<td>Alt+6</td>
<td>聚焦到TODO窗口</td>
</tr>
<tr>
<td>124</td>
<td>Alt+7</td>
<td>聚焦到Structure窗口</td>
</tr>
<tr>
<td>125</td>
<td>Alt+8</td>
<td>聚焦到Hierarchy窗口</td>
</tr>
<tr>
<td>126</td>
<td>Alt+9</td>
<td>聚焦到Change窗口</td>
</tr>
<tr>
<td>127</td>
<td>Ctrl+S</td>
<td>保存文件</td>
</tr>
<tr>
<td>128</td>
<td>Ctrl+Alt+Y</td>
<td>与本地文件同步</td>
</tr>
<tr>
<td>129</td>
<td>Alt+Shift+F</td>
<td>添加到收藏夹</td>
</tr>
<tr>
<td>130</td>
<td>Alt+Shift+I</td>
<td>检查当前文件，包括Javadoc问题、可能存在的bug等</td>
</tr>
<tr>
<td>131</td>
<td>Ctrl+Alt+S</td>
<td>打开settings窗口</td>
</tr>
<tr>
<td>132</td>
<td>Ctrl+BackQuote  (‘)</td>
<td>模式切换，包括文本外观、快捷键、编辑器外观、代码样式</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
  </entry>
  <entry>
    <title>CAS简述</title>
    <url>/2021/05/29/CAS%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<p>在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁</p>
<p>锁机制存在以下问题：</p>
<p>（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p>
<p>（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。</p>
<p>（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p>
<p>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。</p>
<p><strong>独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。</strong></p>
<h2 id="一、什么是CAS"><a href="#一、什么是CAS" class="headerlink" title="一、什么是CAS"></a>一、什么是CAS</h2><p>CAS,compare and swap的缩写，中文翻译成比较并交换。</p>
<p>我们都知道，在java语言之前，并发就已经广泛存在并在服务器领域得到了大量的应用。所以硬件厂商老早就在芯片中加入了大量直至并发操作的原语，从而在硬件层面提升效率。在intel的CPU中，使用cmpxchg指令。</p>
<p>在Java发展初期，java语言是不能够利用硬件提供的这些便利来提升系统的性能的。而随着java不断的发展,Java本地方法(JNI)的出现，使得java程序越过JVM直接调用本地方法提供了一种便捷的方式，因而java在并发的手段上也多了起来。而在Doug Lea提供的cucurenct包中，CAS理论是它实现整个java包的基石。</p>
<p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”</p>
<p>通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。</p>
<p>类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算。</p>
<h2 id="二、CAS的目的"><a href="#二、CAS的目的" class="headerlink" title="二、CAS的目的"></a>二、CAS的目的</h2><p>利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。</p>
<h2 id="三、CAS存在的问题"><a href="#三、CAS存在的问题" class="headerlink" title="三、CAS存在的问题"></a>三、CAS存在的问题</h2><p>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</p>
<p>\1.  <strong>ABA****问题</strong>。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</p>
<p><strong>从****Java1</strong>.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p>关于ABA问题参考文档: <a href="http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html">http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html</a></p>
<p><strong>2.</strong> <strong>循环时间长开销大</strong>。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<p><strong>3.</strong> <strong>只能保证一个共享变量的原子操作</strong>。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了<strong>AtomicReference<strong><strong>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行</strong></strong>CAS****操作。</strong></p>
<p>四、 concurrent包的实现</p>
<p>由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：</p>
<ol>
<li>A线程写volatile变量，随后B线程读这个volatile变量。</li>
<li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li>
</ol>
<p>Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p>
<ol>
<li>首先，声明共享变量为volatile；</li>
<li>然后，使用CAS的原子条件更新来实现线程之间的同步；</li>
<li>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li>
</ol>
<p>转自<a href="https://blog.csdn.net/ls5718/article/details/52563959">https://blog.csdn.net/ls5718/article/details/52563959</a></p>
<p><a href="https://www.jianshu.com/p/ae25eb3cfb5d">这个</a>讲的也挺好</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java各种对比</title>
    <url>/2021/05/27/Java%E5%90%84%E7%A7%8D%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h2 id="四种权限的作用范围对比："><a href="#四种权限的作用范围对比：" class="headerlink" title="四种权限的作用范围对比："></a>四种权限的作用范围对比：</h2><table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>default</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一个类</td>
<td>可</td>
<td>可</td>
<td>可</td>
<td>可</td>
</tr>
<tr>
<td>同一个包</td>
<td>可</td>
<td>可</td>
<td>可</td>
<td>不可</td>
</tr>
<tr>
<td>子类父类</td>
<td>可</td>
<td>可</td>
<td>不可</td>
<td>不可</td>
</tr>
<tr>
<td>不同包之间</td>
<td>可</td>
<td>不可</td>
<td>不可</td>
<td>不可</td>
</tr>
</tbody></table>
<h2 id="和equals对比"><a href="#和equals对比" class="headerlink" title="==和equals对比"></a>==和equals对比</h2><ol>
<li>==是判断两个变量是否指向同一块内存空间；equals是判断两个变量或实例所指向的内存空间的值是否相同</li>
<li>==是对内存地址进行比较，equals则是对内容进行比较；</li>
<li>==比较引用是否相同，equals比较值是否相同</li>
</ol>
<hr>
<h2 id="comparable和comparator对比"><a href="#comparable和comparator对比" class="headerlink" title="comparable和comparator对比"></a>comparable和comparator对比</h2><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><p>​    一个类的实现接口，属于内嵌比较。创建一个类时可实现该接口，重写compareTo()方法，用于自定比较方法，之后可采用collections中的sort方法进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mithrandir</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-04-2021/4/12-14:50</span></span><br><span class="line"><span class="comment"> * 类实现comparable接口，可以理解为将比较方式嵌入自身，便可以直接调用Collections的sort方法</span></span><br><span class="line"><span class="comment"> * （因为实现接口时重写的compareTo方法定义了比较方法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparableLearn</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="number">5</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="number">1</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="number">9</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="number">7</span>));</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">for</span>(Person person:list)&#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age-o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mithrandir</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-04-2021/4/12-14:59</span></span><br><span class="line"><span class="comment"> * comparator作为一个临时比较器，在调用collections的sort方法时写一个比较方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorLearn</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="number">2</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="number">6</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="number">1</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="number">9</span>));</span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.age-o2.age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(Student student:list)&#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="String和StringBuilder和StringBuffer"><a href="#String和StringBuilder和StringBuffer" class="headerlink" title="String和StringBuilder和StringBuffer"></a>String和StringBuilder和StringBuffer</h2><p>String: 底层用的是final char[]</p>
<p>StringBuilder: 线程安全</p>
<p>StringBuilder: 线程不安全，效率高</p>
<hr>
<h2 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>在同一个class内对同一个函数进行重载，必须保证形参个数或者形参类型不同</p>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>用于子类继承父类，对父类中方法的重写</p>
<hr>
<h2 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>boolean、byte、int、char、long、short、double、float</p>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>数组、类、接口…</p>
<p>为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h3 id="基本使用对比"><a href="#基本使用对比" class="headerlink" title="基本使用对比"></a>基本使用对比</h3><ul>
<li>Integer是int的包装类；int是基本数据类型；</li>
<li>Integer变量必须实例化后才能使用；int变量不需要；</li>
<li>Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；</li>
<li>Integer的默认值是null；int的默认值是0</li>
</ul>
<h3 id="深度使用对比"><a href="#深度使用对比" class="headerlink" title="深度使用对比"></a>深度使用对比</h3><ol>
<li><p>由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p>
</li>
<li><p>Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）。</p>
</li>
<li><p>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。因为非new生成的Integer变量指向的是静态常量池中cache数组中存储的指向了堆中的Integer对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的对象引用（地址）不同。</p>
</li>
<li><p>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p>
<p>对于第4条的原因： java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)。而java API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127这个Integer对象进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。</p>
</li>
</ol>
<hr>
<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><h3 id="并发（concurrent）"><a href="#并发（concurrent）" class="headerlink" title="并发（concurrent）"></a>并发（concurrent）</h3><p>交替做不同事情的能力；不同代码块交替执行的能力</p>
<p>程序需要被设计成能处理多个同时（几乎是同时）发生的事情</p>
<h3 id="并行（parallelism）"><a href="#并行（parallelism）" class="headerlink" title="并行（parallelism）"></a>并行（parallelism）</h3><p>同时做不同事情的能力；不同代码块同时执行</p>
<p>通过将问题中的多个部分并行执行，加速解决问题。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发</title>
    <url>/2021/05/27/Java%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h2 id="JMM概述"><a href="#JMM概述" class="headerlink" title="JMM概述"></a><a href="%5BJMM%E6%A6%82%E8%BF%B0_%E7%89%A7%E7%AB%B9%E5%AD%90-CSDN%E5%8D%9A%E5%AE%A2_jmm%5D(https://blog.csdn.net/zjcjava/article/details/78406330)">JMM概述</a></h2><p><img src="/2021/05/27/Java%E5%B9%B6%E5%8F%91/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="JVM内存模型"></p>
<p>不同线程之间无法直接访问对方工作内存中的变量，线程间的通信方式一般有三种方式进行：</p>
<p>1、wait/notify</p>
<p>2、利用共享内存</p>
<p>3、while轮询</p>
<p>JMM采用的就是共享内存方式实现线程间通讯。</p>
<hr>
<h2 id="可见性、原子性、有序性"><a href="#可见性、原子性、有序性" class="headerlink" title="可见性、原子性、有序性"></a>可见性、原子性、有序性</h2><h3 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h3><p>指线程之间的可见性，一个线程修改的状态对另外一个线程是可见的。（volatile可以保证变量的可见性）</p>
<h3 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h3><p>指一个操作或者多个操作要么都执行，要么都不执行。（synchronized可保证原子性）</p>
<h3 id="有序性："><a href="#有序性：" class="headerlink" title="有序性："></a>有序性：</h3><p>对于一个线程的代码而言，我们总是以为代码的执行是从前往后的，依次执行的。这么说不能说完全不对，在单线程程序里，确实会这样执行；但是在多线程并发时，程序的执行就有可能出现乱序。用一句话可以总结为：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行语义（WithIn Thread As-if-Serial Semantics）”,后半句是指“指令重排”现象和“工作内存和主内存同步延迟”现象。</p>
<p>一个最经典的例子就是银行汇款问题，一个银行账户存款100，这时一个人从该账户取10元，同时另一个人向该账户汇10元，那么余额应该还是100。那么此时可能发生这种情况，A线程负责取款，B线程负责汇款，A从主内存读到100，B从主内存读到100，A执行减10操作，并将数据刷新到主内存，这时主内存数据100-10=90，而B内存执行加10操作，并将数据刷新到主内存，最后主内存数据100+10=110，显然这是一个严重的问题，我们要保证A线程和B线程有序执行，先取款后汇款或者先汇款后取款，此为有序性。</p>
<p>Java提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性,volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现，</p>
<p>在单线程程序中，不会发生“指令重排”和“工作内存和主内存同步延迟”现象，只在多线程程序中出现。</p>
<hr>
<hr>
<h2 id="Happen-before原则"><a href="#Happen-before原则" class="headerlink" title="Happen before原则"></a>Happen before原则</h2><h3 id="定义了哪些指令不能重排："><a href="#定义了哪些指令不能重排：" class="headerlink" title="定义了哪些指令不能重排："></a>定义了哪些指令不能重排：</h3><p>单线程的happen before原则</p>
<p>写在前面的操作happen before后面的操作</p>
<p>锁的happen-before原则：</p>
<p>同一个锁的unlock操作happen-before此锁的lock操作。</p>
<p>volatile的happen-before原则：</p>
<p>对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。</p>
<p>happen-before的传递性原则：</p>
<p>如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。</p>
<p>线程启动的happen-before原则：</p>
<p>同一个线程的start方法happen-before此线程的其它方法。</p>
<p>线程中断的happen-before原则：</p>
<p>对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。</p>
<p>线程终结的happen-before原则：</p>
<p>线程中的所有操作都happen-before线程的终止检测。</p>
<p>对象创建的happen-before原则：</p>
<p>一个对象的初始化完成先于他的finalize方法调用。</p>
<h3 id="哪些会进行重排："><a href="#哪些会进行重排：" class="headerlink" title="哪些会进行重排："></a>哪些会进行重排：</h3><p>执行程序时为了提高性能，编译器和处理器经常会对指令进行重新排序。</p>
<p>编译器优化的重排序：</p>
<p>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>
<p>内存系统的重排序：</p>
<p>由于处理器使用的是缓存和读写缓冲区，看上去像是乱序执行。</p>
<hr>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>MyHospital项目笔记</title>
    <url>/2021/06/10/MyHospital/</url>
    <content><![CDATA[<h2 id="ip和端口号总结："><a href="#ip和端口号总结：" class="headerlink" title="ip和端口号总结："></a>ip和端口号总结：</h2><p>sql的IP地址：192.168.75.200，端口号：3306</p>
<p>nginx的端口号：30001  ——用于分发端口号</p>
<p>mongo的ip：192.168.75.200，端口号27017   ——-用于存储数据</p>
<p>nacos—–服务注册中心，端口号8848</p>
<p>redis的ip地址：192.168.75.200，端口号6379</p>
<p>rabbitmq：ip192.168.75.200,端口号15672  管理端口号5672</p>
<hr>
<h2 id="1、版本问题"><a href="#1、版本问题" class="headerlink" title="1、版本问题"></a>1、版本问题</h2><p><img src="/2021/06/10/MyHospital/image-20210719145620042.png" alt="spring的版本问题"></p>
<p>ans：之前在测试MyBatis Plus的时候，这个2.2.1.RELEASE版本一直报红，我采用了2.5.0，但是在此处不知道为什么没用也未发现报红。</p>
<hr>
<h2 id="2、工具swagger2"><a href="#2、工具swagger2" class="headerlink" title="2、工具swagger2"></a>2、工具swagger2</h2><p>在前期进行测试的时候，类似测试获取数据这种操作，可以直接通过访问固定网页（如：<a href="http://localhost:8201/admin/hosp/hospitalSet/findall%EF%BC%89%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%EF%BC%9B%E4%BD%86%E6%98%AF%E5%9C%A8%E6%B5%8B%E8%AF%95%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E6%A0%B9%E6%8D%AEid%E8%BF%9B%E8%A1%8C%E5%88%A0%E9%99%A4%EF%BC%89%E6%97%B6%EF%BC%8C%E4%BE%BF%E6%B2%A1%E6%B3%95%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E7%BD%91%E9%A1%B5%E8%BF%9B%E8%A1%8C%E5%88%A0%E9%99%A4%EF%BC%9B%E6%95%85%EF%BC%8C%E5%9C%A8%E8%BF%99%E9%87%8C%E9%87%87%E7%94%A8swagger2%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%EF%BC%8C%E9%80%9A%E8%BF%87%E5%AF%B9swagger2%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%B9%B6%E9%87%87%E7%94%A8%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AF%B9%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%8C%E4%BD%BF%E5%BE%97%E5%8F%AF%E9%98%B6%E6%AE%B5%E6%80%A7%E5%AF%B9%E5%8A%9F%E8%83%BD%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%E3%80%82">http://localhost:8201/admin/hosp/hospitalSet/findall）进行测试；但是在测试删除功能（根据id进行删除）时，便没法通过直接访问网页进行删除；故，在这里采用swagger2进行测试，通过对swagger2进行配置，并采用注解的方式对网页显示进行优化，使得可阶段性对功能进行测试。</a></p>
<p><img src="/2021/06/10/MyHospital/image-20210612151047092.png" alt="swagger2成果图"></p>
<hr>
<h2 id="3、工具Result"><a href="#3、工具Result" class="headerlink" title="3、工具Result"></a>3、工具Result</h2><p>为了统一返回结果（有人用1表示成功，有人用true表示成功…），故创建一个结果类Result，用于统一对返回结果的管理。</p>
<p>之后函数返回类型便可设置为Result，将原本的返回结果进行包装即可返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、查询医院设置表所有信息</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;获取所有医院设置&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;findAll&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">findAllHospitalSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//调用service方法</span></span><br><span class="line">        List&lt;HospitalSet&gt; list = hospitalSetService.list();</span><br><span class="line">        <span class="comment">//此处便对原本返回的list进行包装，源码在此处不再贴出，后续会上传至我的gitee</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、逻辑删除医院设置</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;逻辑删除医院设置&quot;)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">removeHospSet</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = hospitalSetService.removeById(id);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4、babel问题"><a href="#4、babel问题" class="headerlink" title="4、babel问题"></a>4、babel问题</h2><p>在安装使用babel时，安装之后无法显示版本号，问题如下</p>
<p><img src="/2021/06/10/MyHospital/image-20210621121447448.png" alt="babel安装问题"></p>
<p>ans：在安装时为全局配置，此处找不到babel应该是未进行环境路径配置，故在系统变量中添加路径</p>
<p>babel的路径可通过如下命令获得<img src="/2021/06/10/MyHospital/image-20210621121618787.png" alt="获得babel安装路径"></p>
<p>然后添加进系统环境变量中，重启vscode</p>
<p><img src="/2021/06/10/MyHospital/image-20210621121735212.png" alt="可获得babel版本号"></p>
<hr>
<h2 id="5、笔记：前端设置步骤"><a href="#5、笔记：前端设置步骤" class="headerlink" title="5、笔记：前端设置步骤"></a>5、笔记：前端设置步骤</h2><h3 id="1、添加路由"><a href="#1、添加路由" class="headerlink" title="1、添加路由"></a>1、添加路由</h3><p>在src/router/index.js中添加代码</p>
<p><img src="/2021/06/10/MyHospital/image-20210622105230312.png" alt="路由前端显示"><img src="/2021/06/10/MyHospital/image-20210622105257490.png" alt="路由代码" style="zoom:80%;"></p>
<h3 id="2、设置跳转页面路径"><a href="#2、设置跳转页面路径" class="headerlink" title="2、设置跳转页面路径"></a>2、设置跳转页面路径</h3><p>在路由代码中进行设置</p>
<p><img src="/2021/06/10/MyHospital/image-20210622105446334.png" alt="跳转路径设置"></p>
<h3 id="3、在api文件夹创建js文件，定义接口路径"><a href="#3、在api文件夹创建js文件，定义接口路径" class="headerlink" title="3、在api文件夹创建js文件，定义接口路径"></a>3、在api文件夹创建js文件，定义接口路径</h3><p>红线处为后端代码中设置的路径</p>
<p><img src="/2021/06/10/MyHospital/image-20210622105807763.png" alt="定义接口路径"></p>
<h3 id="4、在页面引入js文件，使用axios进行接口调用，把接口返回数据在页面显示"><a href="#4、在页面引入js文件，使用axios进行接口调用，把接口返回数据在页面显示" class="headerlink" title="4、在页面引入js文件，使用axios进行接口调用，把接口返回数据在页面显示"></a>4、在页面引入js文件，使用axios进行接口调用，把接口返回数据在页面显示</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--template是页面中显示的数据 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        医院设置列表</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">//引入接口定义的js文件</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> hospset <span class="keyword">from</span> <span class="string">&#x27;@/api/hospset&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">current</span>:<span class="number">1</span>,<span class="comment">//当前页</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">limit</span>:<span class="number">3</span>,<span class="comment">//每页显示记录数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">searchObj</span>:&#123;&#125;,<span class="comment">//条件封装对象</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">list</span>:[] <span class="comment">//每页数据集合</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;<span class="comment">//在页面渲染之前执行</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//一般调用methods定义的方法，得到数据</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">this</span>.getList()</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">methods</span>: &#123;<span class="comment">//定义方法，进行请求接口调用</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//医院设置列表</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="function"><span class="title">getList</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            hospset.getHospSetList(<span class="built_in">this</span>.current,<span class="built_in">this</span>.limit,<span class="built_in">this</span>.searchObj)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;<span class="comment">//请求成功，response是接口返回数据</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">console</span>.log(response)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;<span class="comment">//请求失败，error是错误提示</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">console</span>.log(error)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6、跨域问题"><a href="#6、跨域问题" class="headerlink" title="6、跨域问题"></a>6、跨域问题</h2><h3 id="三个地方，任何一个不相同便会产生跨域"><a href="#三个地方，任何一个不相同便会产生跨域" class="headerlink" title="三个地方，任何一个不相同便会产生跨域"></a>三个地方，任何一个不相同便会产生跨域</h3><p>1、访问协议：http  https</p>
<p>2、访问地址：192.128.1.1    172.11.1.1</p>
<p>3、端口号：9528    8201</p>
<h3 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h3><p>第一种：添加CrossOrigin注解</p>
<p>这个得配合nginx使用</p>
<p><img src="/2021/06/10/MyHospital/image-20210622145643778.png" alt="添加CrossOrigin注解"></p>
<p>第二种：采用gateway进行配置</p>
<hr>
<h2 id="7、粗心问题"><a href="#7、粗心问题" class="headerlink" title="7、粗心问题"></a>7、粗心问题</h2><p><img src="/2021/06/10/MyHospital/image-20210622153826279.png" alt="9528报404"></p>
<p>我没添加@CrossOrigin注解，不同端口号是没法访问的，应该是No Access-Control-Allow-Origin，就是下面这个</p>
<p><img src="/2021/06/10/MyHospital/image-20210622165657782.png" alt="9259报跨域问题"></p>
<p>ans：应该是在返回数据中未添加条件封装对象导致的</p>
<p><img src="/2021/06/10/MyHospital/image-20210622175439572.png" alt="条件封装对象"></p>
<hr>
<h2 id="8、问题"><a href="#8、问题" class="headerlink" title="8、问题"></a>8、问题</h2><p><img src="/2021/06/10/MyHospital/image-20210623091741109.png" alt="问题8内容不显示"></p>
<p>当前前端已经可以获得数据，前端代码也已经编写完毕，应该是可以按照表格形式进行显示，但是没数据显示，为什么</p>
<p><img src="/2021/06/10/MyHospital/image-20210623091842271.png" alt="问题8已经可以获得数据"></p>
<p>ans：在调用函数中未返回结果，并未将获取到的response的data返回给当前list</p>
<p><img src="/2021/06/10/MyHospital/image-20210623092522385.png" alt="问题8ans"></p>
<p>改完结果如下：</p>
<p><img src="/2021/06/10/MyHospital/image-20210623092645873.png" alt="问题8成功"></p>
<hr>
<h2 id="9、问题"><a href="#9、问题" class="headerlink" title="9、问题"></a>9、问题</h2><p>在添加锁定和取消锁定功能时，写好代码之后，锁定和取消锁定按钮提示失败，为什么</p>
<p><img src="/2021/06/10/MyHospital/image-20210623145904414.png" alt="问题9"></p>
<p>ans：在api文件中取值路径写错了，id和status没res写$，修正后如下</p>
<p><img src="/2021/06/10/MyHospital/image-20210623150234601.png" alt="问题9res"></p>
<hr>
<h2 id="10、问题"><a href="#10、问题" class="headerlink" title="10、问题"></a>10、问题</h2><p>再记录个问题，这个没来得及截图，（我可能误操作点着了什么，导致vscode关闭了，然后又打开）发现通过npm run dev无法进行运行，错误提示在D:\Coding\myproject\hospital\yygh路径下（我的vue-admin-template-master文件夹也是在这个路径下）没有package.json文件，可是package.json不是在vue-admin-template-master目录下吗</p>
<p>ans：怀疑是误删了什么资源文件，于是采用npm install 进行重新下载依赖，即可打开</p>
<h2 id="11、问题"><a href="#11、问题" class="headerlink" title="11、问题"></a>11、问题</h2><p>为什么没法保存</p>
<p><img src="/2021/06/10/MyHospital/image-20210623154018908.png" alt="问题11"></p>
<p>ans：经debug发现，在添加医院设置时，主键id并未进行设置，故报错</p>
<p>可是我主键id设置了自增，不必手动进行设置即可；在mysql中添加数据发现确实必须要设置id，于是对id的自增属性进行重新设置，问题解决。</p>
<hr>
<h2 id="12、问题（redis）"><a href="#12、问题（redis）" class="headerlink" title="12、问题（redis）"></a>12、问题（redis）</h2><p>在设置redis进行缓存的时候出现问题，报错如下</p>
<p>org.springframework.data.redis.RedisConnectionFailureException: Unable to connect to Redis; nested exception is org.springframework.data.redis.connection.PoolException: Could not get a resource from the pool; nested exception is io.lettuce.core.RedisConnectionException: Unable to connect to 192.168.75.200:6379</p>
<p><img src="/2021/06/10/MyHospital/image-20210625165357501.png" alt="问题12"></p>
<p>之前报错说没法连接，没password，我在配置文件添加了password，ok</p>
<p>现在有说还是没法连接到redis，可是IP地址和端口号都没问题，我也关了防火墙：systemctl stop firewalld，为什么还是报错</p>
<p>而且还提示说我主机中的软件终止了一个已建立的连接</p>
<p><img src="/2021/06/10/MyHospital/image-20210625165620855.png" alt="问题12-2"></p>
<p>经查阅资料，将redis的config文件中的protected-mode改为no，看看有没有效果</p>
<p><img src="/2021/06/10/MyHospital/image-20210625173835048.png" alt="问题12-3"></p>
<p>–没效果</p>
<p>再把这个改为0.0.0.0</p>
<p><img src="/2021/06/10/MyHospital/image-20210625174712006.png" alt="image-20210625174712006"></p>
<p>ans：我搞定了将protected-mode 改为no，再再把bind改为0.0.0.0</p>
<p>修改完redis配置记得重启redis服务</p>
<hr>
<h2 id="13、笔记：nginx解决多端口访问问题"><a href="#13、笔记：nginx解决多端口访问问题" class="headerlink" title="13、笔记：nginx解决多端口访问问题"></a>13、笔记：nginx解决多端口访问问题</h2><p>下载nginx，在nginx配置文件添加如下内容：</p>
<p><img src="/2021/06/10/MyHospital/image-20210626140829928.png" alt="笔记13"></p>
<p>（视频用的是9001）之后将前端的配置端口号改为30001，至此，所有端口号请求发送至30001，再由nginx对不同的关键字进行正则匹配，分发至各自端口号</p>
<p><img src="/2021/06/10/MyHospital/image-20210626140859725.png" alt="笔记13-2"></p>
<hr>
<h2 id="14、MongoDB的安装和使用"><a href="#14、MongoDB的安装和使用" class="headerlink" title="14、MongoDB的安装和使用"></a>14、MongoDB的安装和使用</h2><p>第一步：</p>
<p>使用docker拉取mongoDB镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull mongo:latest</span><br></pre></td></tr></table></figure>

<p>第二步：</p>
<p>创建和启动容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always -p 27017:27017 --name mymongo -v /data/db:/data/db -d mongo</span><br></pre></td></tr></table></figure>

<p>进入创建的容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it mymongo /bin/bash</span><br></pre></td></tr></table></figure>

<p>注意：使用容器mongodb之前记得先启动docker，之后进入创建的容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service docker start</span><br><span class="line">//也可也如下启动docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="15、问题（说lombok不支持我的编译器）"><a href="#15、问题（说lombok不支持我的编译器）" class="headerlink" title="15、问题（说lombok不支持我的编译器）"></a>15、问题（说lombok不支持我的编译器）</h2><p>诡异，我前几个模块都用了lombok，现在跟我说不支持…</p>
<p><img src="/2021/06/10/MyHospital/image-20210627155954703.png" alt="问题15"></p>
<p>ans：改了lombok版本号，就没出现这个错了</p>
<img src="/2021/06/10/MyHospital/image-20210627160354636.png" alt="问题15-ans" style="zoom:50%;">

<hr>
<h2 id="16、登录mysql"><a href="#16、登录mysql" class="headerlink" title="16、登录mysql"></a>16、登录mysql</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="17、笔记（MongoDB数据访问）"><a href="#17、笔记（MongoDB数据访问）" class="headerlink" title="17、笔记（MongoDB数据访问）"></a>17、笔记（MongoDB数据访问）</h2><p>这个<strong>厉害</strong>，Spring Data提供了对mongodb数据访问的支持，只需要继承MongoRepository类，按照Spring Data规范进行命名函数即可自动生成</p>
<p>1、不是随便声明的，而需要符合一定的规范<br> 2、 查询方法以find | read | get开头<br> 3、 涉及条件查询时，条件的属性用条件关键字连接<br> 4、 要注意的是：条件属性首字母需要大写</p>
<p><img src="/2021/06/10/MyHospital/image-20210628153532261.png" alt="笔记17-1"></p>
<p><img src="/2021/06/10/MyHospital/image-20210628153543607.png" alt="笔记17-2"></p>
<hr>
<h2 id="18、HttpServletRequest疑问-已解决-："><a href="#18、HttpServletRequest疑问-已解决-：" class="headerlink" title="18、HttpServletRequest疑问(已解决)："></a>18、HttpServletRequest疑问(已解决)：</h2><p>D:\Coding\myproject\hospital\yygh_parent\service\service_hosp\src\main\java\com\myproject\yygh\hosp\controller\api\ApiController.java这个里面的这些功能是怎么通过HttpServletRequest request来得到数据的</p>
<hr>
<h2 id="19、问题"><a href="#19、问题" class="headerlink" title="19、问题"></a>19、问题</h2><p>在将cmn模块添加进nacos服务中时，启动该模块报错（可是我另外一个服务已经启动了，为什么cmn会报错，说是mongo打不开socket）</p>
<p><img src="/2021/06/10/MyHospital/image-20210630103712904.png" alt="问题19"></p>
<p>上网查资料说原因是springboot自动配置了支持mongodb。在启动springboot时会自动实例化一个mongo实例，需要禁用自动配置 ，增加 <em>@SpringBootApplication(exclude = MongoAutoConfiguration.class)</em></p>
<p><img src="/2021/06/10/MyHospital/image-20210630104206830.png" alt="image-20210630104206830"></p>
<p>ans：搞定，成功启动</p>
<hr>
<h2 id="20、问题"><a href="#20、问题" class="headerlink" title="20、问题"></a>20、问题</h2><p>DictFeignClient这个接口定义了，也注解Repository了，在调用的时候也进行自动装配了，为什么会说找不到这个bean</p>
<p><img src="/2021/06/10/MyHospital/image-20210630154754091.png" alt="问题20"></p>
<p>网上有人说是没有指定包，我试下</p>
<p>ans：确实如此，也不尽然；在该服务下未引入需要用到的feign依赖，服务启动时也未注明引用包的路径，添加依赖和写好包的路径即可</p>
<hr>
<h2 id="21、问题"><a href="#21、问题" class="headerlink" title="21、问题"></a>21、问题</h2><p>之前采用的nginx，后来采用配置网关进行接口转发，但是服务启动后提示跨域问题</p>
<p><img src="/2021/06/10/MyHospital/image-20210705100014265.png" alt="问题21"></p>
<p>ans:要么接着使用@CrossOrigin注解，要么写个配置类</p>
<img src="/2021/06/10/MyHospital/image-20210705110829584.png" alt="问题21的ans" style="zoom:50%;">

<hr>
<h2 id="22、笔记：nuxt路由跳转"><a href="#22、笔记：nuxt路由跳转" class="headerlink" title="22、笔记：nuxt路由跳转"></a>22、笔记：nuxt路由跳转</h2><p>nuxt中路由跳转分为两种：固定路由、动态路由</p>
<p>固定路由：跳转路径固定，只能是某个指定页面；默认vue文件名称：index.vue</p>
<p>动态路由：每次可根据参数跳转至不同页面</p>
<p>​                    创建页面规则：在文件夹下创建vue文件；vue文件命名规范：_参数名称.vue；以下划线开头</p>
<hr>
<h2 id="23、疑问（已解决）"><a href="#23、疑问（已解决）" class="headerlink" title="23、疑问（已解决）"></a>23、疑问（已解决）</h2><p>HttpServletRequest是干嘛用的</p>
<p>–ans：见笔记</p>
<hr>
<h2 id="24、待定（搞定）"><a href="#24、待定（搞定）" class="headerlink" title="24、待定（搞定）"></a>24、待定（搞定）</h2><p>在p143这里，我的就诊人信息刷新不出，不清楚是不是因为patient的信息写的不够完整；之后还要做添加就诊人员的信息，暂且放置。</p>
<p><img src="/2021/06/10/MyHospital/image-20210714203109334.png" alt="问题24"></p>
<hr>
<h2 id="25、QuerryWrapper温故-搞定"><a href="#25、QuerryWrapper温故-搞定" class="headerlink" title="25、QuerryWrapper温故(搞定)"></a>25、QuerryWrapper温故(搞定)</h2><p>QuerryWrapper的条件查询和模糊查询，记得看一下源码人家是怎么实现的。</p>
<p>–ans：源码封装了sql语句，可以实现简单的查找</p>
<hr>
<h2 id="26、Feign温故（未搞定）"><a href="#26、Feign温故（未搞定）" class="headerlink" title="26、Feign温故（未搞定）"></a>26、Feign温故（未搞定）</h2><p>Feign这个注解是干啥的</p>
<p>Feign的使用（未完成）</p>
<hr>
<h2 id="27、rabbitMQ温故（未搞定）"><a href="#27、rabbitMQ温故（未搞定）" class="headerlink" title="27、rabbitMQ温故（未搞定）"></a>27、rabbitMQ温故（未搞定）</h2><p>rabbitMQ</p>
<hr>
<h2 id="28、rabbitmq启动"><a href="#28、rabbitmq启动" class="headerlink" title="28、rabbitmq启动"></a>28、rabbitmq启动</h2><p>这个是创建并启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5672:5672 -p 15672:15672 --name rabbitmq rabbitmq:management</span><br></pre></td></tr></table></figure>

<p>启动rabbitmq容器的话，先用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it rabbitmq /bin/bash</span><br></pre></td></tr></table></figure>

<p>查找所有容器id，是一串数字，然后再启动该容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker start 925153afeb449859b139ba8b9977312ec0dd1bfedf86772ddc735b72f466803b</span><br></pre></td></tr></table></figure>

<p>,接下来即可启动rabbitmq。</p>
<hr>
<p>29、问题（空指针异常p160）</p>
]]></content>
      <categories>
        <category>项目Hospital</category>
      </categories>
  </entry>
  <entry>
    <title>Spring实战第四版读书笔记</title>
    <url>/2021/06/04/Spring%E5%AE%9E%E6%88%98%E7%AC%AC%E5%9B%9B%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Spring实战第四版"><a href="#Spring实战第四版" class="headerlink" title="Spring实战第四版"></a>Spring实战第四版</h1><p>spring本质上是简化java开发。</p>
<p>几个简写：</p>
<table>
<thead>
<tr>
<th>EJB</th>
<th>Enterprise JavaBean</th>
<th>企业级javabean</th>
</tr>
</thead>
<tbody><tr>
<td>JDO</td>
<td>Java Data Object</td>
<td>java数据对象</td>
</tr>
<tr>
<td>POJO</td>
<td>Plian Old Java Object</td>
<td>简单老式java对象</td>
</tr>
<tr>
<td>DI</td>
<td>Dependency Injection</td>
<td>依赖注入</td>
</tr>
<tr>
<td>AOP</td>
<td>Aspect-Oriented Programing</td>
<td>面向切面编程</td>
</tr>
</tbody></table>
<h2 id="第一章：简介"><a href="#第一章：简介" class="headerlink" title="第一章：简介"></a>第一章：简介</h2><h3 id="怎么简化java开发的："><a href="#怎么简化java开发的：" class="headerlink" title="怎么简化java开发的："></a>怎么简化java开发的：</h3><p>通过DI和AOP实现松耦合；基于切面和惯例进行声明式编程；通过切面和模板减少样板式代码</p>
<h3 id="AOP的作用："><a href="#AOP的作用：" class="headerlink" title="AOP的作用："></a>AOP的作用：</h3><p>AOP通过将遍布应用各处的功能分离出来，形成可重用的组件，从而确保pojo的简单性</p>
<h3 id="Spring容器："><a href="#Spring容器：" class="headerlink" title="Spring容器："></a>Spring容器：</h3><p>将一个类转化为一个切面，首先需要将其声明为一个SpringBean，bean对象生存于Spring容器中；</p>
<p>Spring的容器分为两大类：bean工厂和应用上下文。</p>
<hr>
<h2 id="第二章：装配bean"><a href="#第二章：装配bean" class="headerlink" title="第二章：装配bean"></a>第二章：装配bean</h2><p>装配bean有三种方式：</p>
<p>1、xml配置</p>
<p>2、java显示装配</p>
<p>3、<strong>自动装配</strong>【重要】</p>
<p>自动装配最为便捷。</p>
<p>以下为简单的自动装配</p>
<p>分别创建三个pojo并进行注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.springlearn.exm3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">//第一个pojo</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">voice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵喵&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.springlearn.exm3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">//第二个pojo</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">voice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.springlearn.exm3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">//第三个pojo</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我有两只宠物&quot;</span>);</span><br><span class="line">        cat.voice();</span><br><span class="line">        dog.voice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后将三个pojo存放至spring容器中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.springlearn.exm3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exm3Config</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后便可对其进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.exam3test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.learn.springlearn.exm3.Exm3Config;</span><br><span class="line"><span class="keyword">import</span> com.learn.springlearn.exm3.Human;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = Exm3Config.class)</span></span><br><span class="line"><span class="comment">//下面这个注解必须要加，不然会报nulllpointerexception</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exm3Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Human human;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        human.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第三章：高级装配"><a href="#第三章：高级装配" class="headerlink" title="第三章：高级装配"></a>第三章：高级装配</h2><h3 id="配置profile-bean："><a href="#配置profile-bean：" class="headerlink" title="配置profile bean："></a>配置profile bean：</h3><p>profile可以根据环境创建哪个bean和不创建哪个bean</p>
<hr>
<h3 id="激活profile："><a href="#激活profile：" class="headerlink" title="激活profile："></a>激活profile：</h3><p>如果定义了spring.profiles.active，那就根据这个配置进行激活profile</p>
<p>没设置active的话，如果定义了spring.profiles.default，那就根据default进行jihuo</p>
<p>如果都没设置，那就只创建那些没定义在profile中的bean</p>
<hr>
<h3 id="条件化的bean"><a href="#条件化的bean" class="headerlink" title="条件化的bean"></a>条件化的bean</h3><p>通过注解Conditional实现，只有指定属性不存在的话，指定类就不会被实例化。</p>
<hr>
<h3 id="自动装配的歧义性"><a href="#自动装配的歧义性" class="headerlink" title="自动装配的歧义性"></a>自动装配的歧义性</h3><p>一个接口会存在多个实现类，此时进行自动装配时，spring无法确定装配哪个类。。</p>
<p>解决方法：</p>
<p>1、设置首选bean：@Primary</p>
<p>2、采用限定符来确定装配指定的bean：@Qualifier（“iceCream”）；@Qualifier也可以用于bean上，相当于为该bean设置ID；@Qualifier也可以将每个bean的ID设置为该类的特性，一个bean会存在多个特性，但是同一个类不允许多次使用同一个注解，因此可自行创建注解</p>
<p><img src="/2021/06/04/Spring%E5%AE%9E%E6%88%98%E7%AC%AC%E5%9B%9B%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210607102850024.png" alt="自行创建注解"></p>
<hr>
<h3 id="运行时值注入"><a href="#运行时值注入" class="headerlink" title="运行时值注入"></a>运行时值注入</h3><p>目的：使得一些值在运行时再确定</p>
<p>方法：</p>
<p>1、属性占位符</p>
<p>2、Spring表达式语言（SpEL）【重点】</p>
<p>SpEL的使用方法：</p>
<p>表示字面值：#{3.1459}，#{‘Hello’}，#{false}</p>
<p>引用bean、属性、方法</p>
<p>#{people}，#{people.name}，#{people.speak()}</p>
<hr>
<h2 id="第四章：面向切面的Spring"><a href="#第四章：面向切面的Spring" class="headerlink" title="第四章：面向切面的Spring"></a>第四章：面向切面的Spring</h2><p>AOP术语：</p>
<p>通知（Advice）：切面的工作被称为通知；通知包含了需要用于多个对象的横切行为。</p>
<p>连接点（Join Point）：在应用执行过程中插入到切面的一个点，切面代码利用这些点插入到应用的正常流程之中，并添加新的行为；连                                      接点是程序执行过程中能够应用通知的所有点。</p>
<p>切点（Pointcut）：通知定义了切面的“什么”和“何时”，切点定义了“何处”；切点定义了哪些连接点会得到通知。</p>
<p>切面（Aspect）：通知和切点构成了切面的全部内容。</p>
<p>引入（Introduction）：向现有的类添加新的方法和属性。</p>
<p>织入（Weaving）：将切面应用到目标对象并创建新的代理对象的过程。</p>
<h2 id="第五章：构建Spring-Web应用程序"><a href="#第五章：构建Spring-Web应用程序" class="headerlink" title="第五章：构建Spring Web应用程序"></a>第五章：构建Spring Web应用程序</h2><h4 id="跟踪Spring-MVC的请求"><a href="#跟踪Spring-MVC的请求" class="headerlink" title="跟踪Spring MVC的请求"></a>跟踪Spring MVC的请求</h4><p><img src="/2021/06/04/Spring%E5%AE%9E%E6%88%98%E7%AC%AC%E5%9B%9B%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20210608101154885.png" alt="Spring MVC的请求流程"></p>
<p>在请求离开浏览器时(1)，会带有用户所请求内容的信息，至少会包含请求的URL。但是还可能带有其他的信息，例如用户提交的表单信息。<br>请求旅程的第一站是Spring的DispatcherServlet。与大多数基于Java的Web框架一样，Spring MVC所有的请求都会通过一个前端控制器（front controller）Serlet。前端控制器是常用的Web应用程序模式，在这里一个单实例的Serlet将请求委托给应用程序的其他组件来执行实际的处理。在Spring MVC中，DispatcherServlet就是前端控制器。<br>DispatcherServlet的任务是将请求发送给Spring MVC控制器（controller)。控制器是一个用于处理请求的Spring组件。在典型的应用程序中可能会有多个控制器，Dispatcherservlet需要知道应该将请求发送给哪个控制器。所以DispatcherServlet以会查询一个或多个处理器映射（handler mapping)(2)来确定请求的下一站在哪里。处理器映射会根据请求所携带的URL信息来进行决策。<br>一旦选择了合适的控制器，Dispatcherservlet会将请求发送给选中的控制器(3)。到了控制器，请求会卸下其负载（用户提交的信息）并耐心等待控制器处理这些信息。（实际上，设计良好的控制器本身只处理很少甚至不处理工作，而是将业务逻辑委托给一个或多个服务对象进行处理。)控制器在完成逻辑处理后，通常会产生一些信息，这些信息需要返回给用户并在浏览器上显示。这些信息被称为模型（model）。不过仅仅给用户返回原始的信息是不够的——这些信息需要以用户友好的方式进行格式化，一般会是HTML。所以，信息需要发送给一个视图（view），通常会是JSP。<br>控制器所做的最后一件事就是将模型数据打包，并且标示出用于渲染输出的视图名。它接下来会将请求连同模型和视图名发送回DispatcherServlet(4)。<br>这样，控制器就不会与特定的视图相耦合，传递给Dispatcherservlet的视图名并不直接表示某个特定的JSP。实际上，它甚至并不能确定视图就是JSP。相反，它仅仅传递了一个逻辑名称，这个名字将会用来查找产生结果的真正视图。Dispatcherservlet将会使用视图解析器（view resolver）(5)来将逻辑视图名匹配为一个特定的视图实现，它可能是也可能不是JSP。<br>既然DispatcherServlet已经知道由哪个视图渲染结果，那请求的任务基本上也就完成了。它的最后一站是视图的实现（可能是JSP）(6)，在这里它交付模型数据。请求的任务就完成了。视图将使用模型数据渲染输出，这个输出会通过响应对象传递给客户端（不会像听上去那样硬编码）(7)。<br>可以看到，请求要经过很多的步骤，最终才能形成返回给客户端的响应。大多数的步骤都是在Spring框架内部完成的，也就是图5.1所示的组件中。尽管本章的主要内容都关注于如何编写控制器，但在此之前我们首先看一下如何搭建Spring MVC的基础组件。</p>
<hr>
<h2 id="第六章：渲染web视图"><a href="#第六章：渲染web视图" class="headerlink" title="第六章：渲染web视图"></a>第六章：渲染web视图</h2><p>这个暂时跳过。</p>
<hr>
<h2 id="第七章：SpringMVC的高级技术"><a href="#第七章：SpringMVC的高级技术" class="headerlink" title="第七章：SpringMVC的高级技术"></a>第七章：SpringMVC的高级技术</h2><p>这章看了一遍，不是很明白。</p>
<hr>
<h2 id="第八章：使用Spring-Web-Flow"><a href="#第八章：使用Spring-Web-Flow" class="headerlink" title="第八章：使用Spring Web Flow"></a>第八章：使用Spring Web Flow</h2><hr>
<h2 id="第九章：保护Web应用"><a href="#第九章：保护Web应用" class="headerlink" title="第九章：保护Web应用"></a>第九章：保护Web应用</h2><p>注：第五~第九章将的是Spring在web中的应用，暂且跳过。</p>
<hr>
<h2 id="第十章：通过Spring和JDBC连接数据库"><a href="#第十章：通过Spring和JDBC连接数据库" class="headerlink" title="第十章：通过Spring和JDBC连接数据库"></a>第十章：通过Spring和JDBC连接数据库</h2><p>通过jdbc消除样板式代码，使得在编程阶段能专注于代码本身；</p>
<p>简单讲了下jdbc的用法</p>
<hr>
<h2 id="第十一章：使用对象-关系映射持久化数据"><a href="#第十一章：使用对象-关系映射持久化数据" class="headerlink" title="第十一章：使用对象-关系映射持久化数据"></a>第十一章：使用对象-关系映射持久化数据</h2>]]></content>
      <categories>
        <category>读书总结</category>
      </categories>
  </entry>
  <entry>
    <title>Volatile关键字</title>
    <url>/2021/05/27/Volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html">volatile</a>关键字</h2><p>volatile 是一个类型修饰符。volatile 的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略</p>
<p>特性：</p>
<p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（实现可见性）</p>
<p>禁止进行指令重排序。（保证一定程度上的原子性）</p>
<p>volatile 只能保证对单次读/写的原子性。i++ 这种操作不能保证原子性</p>
<p>简单介绍下指令重排</p>
<p>第一个为读操作时，第二个任何操作不可重排序到第一个前面。</p>
<p>第二个为写操作时，第一个任何操作不可重排序到第二个后面。</p>
<p>第一个为写操作时，第二个的读写操作也不运行重排序。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode-回文字符串</title>
    <url>/2021/06/10/leetcode-%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h1><h2 id="知识点：manacher算法"><a href="#知识点：manacher算法" class="headerlink" title="知识点：manacher算法"></a>知识点：manacher算法</h2><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>manacher算法的快捷在于将每个节点的最大臂长都记录在内，这样下次再查找的时候就不必再做重复工作；另外，对字符串进行处理（加特殊符号），使得字符串的长度全部都为奇数。</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析:"></a>复杂度分析:</h2><p>时间复杂度：O(n)，其中 n 是字符串的长度。由于对于每个位置，扩展要么从当前的最右侧臂长 right 开始，要么只会进行一步，而 right 最多向前走 O(n) 步，因此算法的复杂度为 O(n)。</p>
<p>空间复杂度：O(n)，我们需要 O(n) 的空间记录每个位置的臂长。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理字符串</span></span><br><span class="line">        StringBuffer t = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            t.append(s.charAt(i));</span><br><span class="line">            t.append(<span class="string">&#x27;$&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s=t.toString();</span><br><span class="line">        <span class="comment">//start为最长字符串的起始，end为其末端</span></span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//right为当前最长回文串的最右端，j为最长回文串对称中心</span></span><br><span class="line">        <span class="keyword">int</span> right=-<span class="number">1</span>,j=-<span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; armLength = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> curArmLength;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=right)&#123;<span class="comment">//如果当前位置在最长回文串范围内部</span></span><br><span class="line">                <span class="keyword">int</span> iSym=j*<span class="number">2</span>-i;</span><br><span class="line">                <span class="keyword">int</span> minArm=Math.min(right-i,armLength.get(iSym));<span class="comment">//找到可以确定的臂长</span></span><br><span class="line">                curArmLength=getArmLength(s,i-minArm,i+minArm);<span class="comment">//扩展臂长</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//没有就重头开始找</span></span><br><span class="line">                curArmLength=getArmLength(s,i,i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对数据进行更新</span></span><br><span class="line">            armLength.add(curArmLength);</span><br><span class="line">            <span class="keyword">if</span>(right&lt;i+curArmLength)&#123;</span><br><span class="line">                j=i;</span><br><span class="line">                right=i+curArmLength;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(end-start&lt;curArmLength*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">                start=i-curArmLength;</span><br><span class="line">                end=i+curArmLength;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再次处理字符串，消除特殊字符</span></span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)!=<span class="string">&#x27;$&#x27;</span>)&#123;</span><br><span class="line">                res.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到字符串的臂长</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArmLength</span><span class="params">(String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (right-left-<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="214-最短回文串"><a href="#214-最短回文串" class="headerlink" title="214. 最短回文串"></a><a href="https://leetcode-cn.com/problems/shortest-palindrome/">214. 最短回文串</a></h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p>
<p>示例 1：</p>
<p>输入：s = “aacecaaa” 输出：”aaacecaaa” 示例 2：</p>
<p>输入：s = “abcd” 输出：”dcbabcd”</p>
<h2 id="知识点：字符串、manacher、KMP"><a href="#知识点：字符串、manacher、KMP" class="headerlink" title="知识点：字符串、manacher、KMP"></a>知识点：字符串、manacher、KMP</h2><h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><p>这个题目前没解决，走了个递归的路子，我尝试用manacher进行计算，超时了，但是有人的manacher没超时，说明我的manacher还有待改进；这个题用KMP是最好的，还有个解法是用的字符串哈希，那个是“投机取巧”了(我也不会用)。</p>
<p>已经掌握KMP模式匹配算法。</p>
<h2 id="KMP代码如下："><a href="#KMP代码如下：" class="headerlink" title="KMP代码如下："></a>KMP代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="comment">//next为当前字符串的最大前缀后缀匹配个数</span></span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,size=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="comment">//这个是回溯的意思，如果当前字符和下一个字符不相等，那就将size改为上次相等的那个位置</span></span><br><span class="line">            <span class="keyword">while</span>(size&gt;<span class="number">0</span>&amp;&amp;s.charAt(i)!=s.charAt(size))&#123;</span><br><span class="line">                size=next[size-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(size))&#123;</span><br><span class="line">                ++size;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i]=size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">//这个是相当于将S和其倒序字符串进行了求最大前缀后缀匹配个数</span></span><br><span class="line">            <span class="keyword">while</span>(index&gt;<span class="number">0</span>&amp;&amp;s.charAt(i)!=s.charAt(index))&#123;</span><br><span class="line">                index=next[index-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(index)==s.charAt(i))&#123;</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意此处的index，如果s为回文字符串，则index就是s的length</span></span><br><span class="line">        String add = (index==len?<span class="string">&quot;&quot;</span>:s.substring(index));</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(add);</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().append(s).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode-跳跃次数</title>
    <url>/2021/06/10/leetcode-%E8%B7%B3%E8%B7%83%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h1><h2 id="知识点：贪心算法"><a href="#知识点：贪心算法" class="headerlink" title="知识点：贪心算法"></a>知识点：贪心算法</h2><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定一个非负整数数组nums，你最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>维护每个位置所能到达的最右位置rightPositon，不断更新这个rightPositon，直到rightPositon大于等于最后的位置，或者遍历至数组最后一位也无法到达。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> rightMost = <span class="number">0</span>;<span class="comment">//维持一个最右边的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=rightMost)&#123;</span><br><span class="line">                rightMost = Math.max(rightMost,i+nums[i]);<span class="comment">//动态维护最右侧的位置</span></span><br><span class="line">                <span class="keyword">if</span>(rightMost&gt;=len-<span class="number">1</span>)&#123;<span class="comment">//此时说明已经可以到达最后位置</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="45-跳跃游戏-II知识点：贪心算法"><a href="#45-跳跃游戏-II知识点：贪心算法" class="headerlink" title="45. 跳跃游戏 II知识点：贪心算法"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a>知识点：贪心算法</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><p>关键点在于什么时候记录跳跃次数step，明确一点，如果在某一点i，所能到达的最远处rightPosition也无法到达最后一个位置时，那就需要再跳一次，即step++；故，每当i所能到达的rightPosition未到达最后一个位置，i又已经到达了当前能到达的最远位置（已经不得不跳了），则step++。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=nums.length;</span><br><span class="line">        <span class="comment">//end为未跳之前所能到达的最远位置</span></span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">0</span>,mostRight=<span class="number">0</span>,steps=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            mostRight=Math.max(mostRight,i+nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i==end)&#123;</span><br><span class="line">                end=mostRight;</span><br><span class="line">                steps++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode-重构二叉树</title>
    <url>/2021/06/10/leetcode-%E9%87%8D%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"><strong>105.</strong> <strong>从前序与中序遍历序列构造二叉树</strong></a></h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<h2 id="知识点-二叉树-递归"><a href="#知识点-二叉树-递归" class="headerlink" title="知识点:二叉树,递归"></a>知识点:二叉树,递归</h2><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><table>
<thead>
<tr>
<th><strong>二叉树遍历</strong></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>前序</td>
<td>根节点</td>
<td>左子树</td>
<td>右子树</td>
</tr>
<tr>
<td>中序</td>
<td>左子树</td>
<td>根节点</td>
<td>右子树</td>
</tr>
<tr>
<td>后序</td>
<td>左子树</td>
<td>右子树</td>
<td>根节点</td>
</tr>
</tbody></table>
<p>根据二叉树遍历的特点 ，前序遍历的第一个节点就是根节点；而在中序遍历中可根据根节点的坐标位置将整个数组分为左子树和右子树。在本题中，重点落在了中序遍历上，首先对中序遍历建立一个HashMap，k为数组的值，v为该值在中序遍历中的位置。根据前序遍历找到根节点root的位置，然后通过HashMap找到root在中序遍历中的位置，之后便可根据中序遍历确定左子树和右子树的长度；由于子树长度确定了，则可在前序遍历中确定左右子树的根节点，便可进行递归查找所有节点的位置。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//preorder和HashMap在两个函数中都会用到</span></span><br><span class="line">    <span class="keyword">int</span>[] preorder;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder=preorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//rootIndex为前序遍历中根节点的位置，leftIndex为中序遍历中子树的左端，rightIndex为中序遍历中子树的右端，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">recur</span><span class="params">(<span class="keyword">int</span> rootIndex,<span class="keyword">int</span> leftIndex,<span class="keyword">int</span> rightIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftIndex&gt;rightIndex)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(preorder[rootIndex]);</span><br><span class="line">        <span class="keyword">int</span> rootIndexInOrder=map.get(preorder[rootIndex]);</span><br><span class="line">        <span class="comment">//递归建立左子树</span></span><br><span class="line">        root.left=recur(rootIndex+<span class="number">1</span>,leftIndex,rootIndexInOrder-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//解释下rootIndex+rootIndexInOrder-leftIndex+1，这个式子为</span></span><br><span class="line">        <span class="comment">//rootIndex+[（rootIndexInOrder-1）-leftIndex+1]+1，</span></span><br><span class="line">        <span class="comment">//其实就是找到前序遍历中右子树开始的那个位置，当前根节点的位置+左子树长度+1</span></span><br><span class="line">        <span class="comment">//递归建立右子树</span></span><br><span class="line">        root.right=recur(rootIndex+rootIndexInOrder-leftIndex+<span class="number">1</span>,rootIndexInOrder+<span class="number">1</span>,rightIndex);</span><br><span class="line">        <span class="comment">//返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/"><strong>106.</strong> <strong>从中序与后序遍历序列构造二叉树</strong></a></h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意: 你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3]</p>
<h2 id="知识点：二叉树"><a href="#知识点：二叉树" class="headerlink" title="知识点：二叉树"></a>知识点：二叉树</h2><h2 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] postorder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.postorder=postorder;</span><br><span class="line">        <span class="keyword">int</span> len = inorder.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = dfs(len-<span class="number">1</span>,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对当前节点的左右子树进行构建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rootIndex 根节点在后序遍历中的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leftIndex 当前子树在中序遍历中的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rightIndex 当前子树在中序遍历中的右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rootIndex, <span class="keyword">int</span> leftIndex, <span class="keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftIndex&gt;rightIndex)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(postorder[rootIndex]);</span><br><span class="line">        <span class="keyword">int</span> rootInorder = map.get(postorder[rootIndex]);</span><br><span class="line">        <span class="keyword">int</span> leftLen = rootInorder-leftIndex;</span><br><span class="line">        node.left=dfs(rootIndex-(rightIndex-leftIndex+<span class="number">1</span>)+leftLen,leftIndex, rootInorder-<span class="number">1</span>);</span><br><span class="line">        node.right=dfs(rootIndex-<span class="number">1</span>,rootInorder+<span class="number">1</span>,rightIndex);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>maven首次运行问题</title>
    <url>/2021/06/01/maven%E9%A6%96%E6%AC%A1%E8%BF%90%E8%A1%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>第一次运行maven时，由于maven默认用的是jre，用命令行运行时会报错，如下图所示</p>
<p><img src="/2021/06/01/maven%E9%A6%96%E6%AC%A1%E8%BF%90%E8%A1%8C%E9%97%AE%E9%A2%98/image-20210601191617928.png" alt="image-20210601191617928"></p>
<p>根据提示错误，可知运行的是jre而不是jkd，查看maven版本</p>
<p><img src="/2021/06/01/maven%E9%A6%96%E6%AC%A1%E8%BF%90%E8%A1%8C%E9%97%AE%E9%A2%98/image-20210601191710470.png" alt="image-20210601191710470"></p>
<p>发现路径为jre，至此找到问题根源。</p>
<p>解决方法：</p>
<p>在maven\bin\setting文件中，在首行加上</p>
<p>set JAVA_HOME=C:\JDK\jdk1.8.0_291</p>
<p>将其所用的JAVA_HOME修改为本机所安装的jdk，之后问题解决，文件可正常编译。</p>
<p><img src="/2021/06/01/maven%E9%A6%96%E6%AC%A1%E8%BF%90%E8%A1%8C%E9%97%AE%E9%A2%98/image-20210601191917280.png" alt="image-20210601191917280"></p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
  </entry>
  <entry>
    <title>mybatisplus使用总结</title>
    <url>/2021/06/04/mybatisplus%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>使用mybatis对数据库进行操作时，为方便定位错误，可在配置文件中进行配置使得myqsl语句在控制台进行输出</p>
<p>在application.properties配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#控制面板输出mybatis日志</span><br><span class="line">mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="MybatisPlus的主键策略"><a href="#MybatisPlus的主键策略" class="headerlink" title="MybatisPlus的主键策略"></a>MybatisPlus的主键策略</h2><p>默认采用的是雪花算法：分布式ID生成器</p>
<p><strong>核心思想：</strong></p>
<p>长度共64bit（一个long型）。</p>
<p>首先是一个符号位，1bit标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0。</p>
<p>41bit时间截(毫秒级)，存储的是时间截的差值（当前时间截 - 开始时间截)，结果约等于69.73年。</p>
<p>10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID，可以部署在1024个节点）。</p>
<p>12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID）。</p>
<p><img src="/2021/06/04/mybatisplus%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/clip_image002.jpg" alt="分布式ID生成"></p>
<p>优点：整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞，并且效率较高。</p>
<p><img src="/2021/06/04/mybatisplus%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20210604104216001.png" alt="数据库自动生成ID"></p>
<hr>
<h2 id="MyBatisPlus自动填充功能"><a href="#MyBatisPlus自动填充功能" class="headerlink" title="MyBatisPlus自动填充功能"></a>MyBatisPlus自动填充功能</h2><p>好处：自动实现set功能</p>
<p>使用方法：</p>
<p>举例：添加记录的创建时间和修改时间</p>
<p>1、在数据库表中创建对应列：create_time,update_time</p>
<p><img src="/2021/06/04/mybatisplus%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20210604101416523.png" alt="数据库添加列"></p>
<p>2、在对应的实体类中添加对应属性：createTime,updateTime，并添加注解</p>
<p><img src="/2021/06/04/mybatisplus%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20210604101437416.png" alt="实体类添加属性"></p>
<p>3、创建一个类，实现MetaObjectHandler接口，并重写其中的两个方法</p>
<p><img src="/2021/06/04/mybatisplus%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/image-20210604103623362.png" alt="创建handler类"></p>
]]></content>
      <categories>
        <category>HelloWorld系列</category>
      </categories>
  </entry>
  <entry>
    <title>mysql登录</title>
    <url>/2021/06/03/mysql%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>启动mysql：systemctl start mysqld</p>
<p>查看mysql启动状态：systemctl status mysqld</p>
<p>显示active表示已经激活。</p>
<p>进行登录：mysql -uroot -p</p>
]]></content>
      <categories>
        <category>项目Hospital</category>
      </categories>
  </entry>
  <entry>
    <title>native关键字</title>
    <url>/2021/05/29/native%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="native关键字"><a href="#native关键字" class="headerlink" title="native关键字"></a>native关键字</h2><p>native是与C++联合开发的时候用的！java自己开发不用的！</p>
<p>使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用。</p>
<p>这些函数的实现体在DLL中，JDK的源代码中并不包含，你应该是看不到的。对于不同的平台它们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的。</p>
<p>1。native 是用做java 和其他语言（如c++）进行协作时用的也就是native 后的函数的实现不是用java写的</p>
<p>2。既然都不是java，那就别管它的源代码了，呵呵</p>
<p>native的意思就是通知操作系统，</p>
<p>这个函数你必须给我实现，因为我要使用。</p>
<p>所以native关键字的函数都是操作系统实现的，java只能调用。</p>
<p>java是跨平台的语言，既然是跨了平台，所付出的代价就是牺牲一些对底层的控制，而java要实现对底层的控制，就要一些其他语言的帮助，这个就是native的作用了</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Vue基础</title>
    <url>/2021/06/17/vue%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;!--插值表达式--&gt;</span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            //取路径</span><br><span class="line">            el:&#x27;#app&#x27;,</span><br><span class="line">            //定义变量名字和变量值</span><br><span class="line">            data:&#123;</span><br><span class="line">                message:&#x27;Hello Vue&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="单向绑定和双向绑定"><a href="#单向绑定和双向绑定" class="headerlink" title="单向绑定和双向绑定"></a>单向绑定和双向绑定</h2><!--双向绑定和单向绑定的区别-->
<p>采用双向绑定时，相当于将修改权一并给出，若在网页端进行修改，其他位置的引用值一并变化</p>
<p>采用单向绑定时，修改该值仅仅是修改该位置的值，其他位置的引用值不会变化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;!--单向绑定--&gt;</span><br><span class="line">        &lt;div v-bind:style=&quot;msg&quot;&gt;单向绑定&lt;/div&gt;</span><br><span class="line">        &lt;!--简写方式：直接写：--&gt;</span><br><span class="line">        &lt;div :style=&quot;msg&quot;&gt;单向绑定简写&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el: &#x27;#app&#x27;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                msg:&quot;color:red;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;!--内容中可通过插值表达式取到值，在属性中使用单向绑定或者双向绑定--&gt;</span><br><span class="line">        &#123;&#123;msg&#125;&#125;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;!--单向绑定--&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; :value=&quot;msg&quot;/&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;!--双向绑定--&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;/&gt;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el: &#x27;#app&#x27;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                msg:&quot;vue项目&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;button v-on:click=&quot;show1&quot;&gt;事件绑定&lt;/button&gt;</span><br><span class="line">        &lt;!-- 简写方式如下 --&gt;</span><br><span class="line">        &lt;button @click=&quot;show2&quot;&gt;事件绑定2&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el: &#x27;#app&#x27;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                msg:&quot;vue项目&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                show1()&#123;</span><br><span class="line">                    console.log(&quot;这是vue中定义的一个方法&quot;)</span><br><span class="line">                &#125;,</span><br><span class="line">                show2()&#123;</span><br><span class="line">                    console.log(&quot;这是vue中定义的第二个方法&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="条件渲染指令"><a href="#条件渲染指令" class="headerlink" title="条件渲染指令"></a>条件渲染指令</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; v-model=&quot;ok&quot;/&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;div v-if=&quot;ok&quot;&gt;已选&lt;/div&gt;</span><br><span class="line">        &lt;div v-else&gt;未选&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el: &#x27;#app&#x27;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                ok:false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;!-- 循环遍历userList，每个遍历到的对象取名user;添加index是列表的索引（从0开始） --&gt;</span><br><span class="line">        &lt;div v-for=&quot;(user,index) in userList&quot;&gt;</span><br><span class="line">            &#123;&#123;index&#125;&#125;--&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.age&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el: &#x27;#app&#x27;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                userList:[</span><br><span class="line">                    &#123;&quot;name&quot;:&quot;Neo&quot;,age:31&#125;,</span><br><span class="line">                    &#123;&quot;name&quot;:&quot;Alex&quot;,age:29&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>created方法在页面渲染之前执行，mounted方法在页面渲染之后执行</p>
<p>代码测试：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &#123;&#123;msg&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el: &#x27;#app&#x27;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                msg:&quot;hello&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            created()&#123;</span><br><span class="line">                debugger</span><br><span class="line">                console.log(&quot;created...&quot;)//页面渲染之前执行</span><br><span class="line">            &#125;,</span><br><span class="line">            mounted()&#123;</span><br><span class="line">                debugger</span><br><span class="line">                console.log(&quot;mounted...&quot;)//页面渲染之后执行</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<p><img src="/2021/06/17/vue%E5%9F%BA%E7%A1%80/image-20210617163308376.png" alt="vue生命周期"></p>
<hr>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>通过axios发送ajax请求，来获取json中的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;!-- 通过列表进行输出 --&gt;</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">            &lt;!-- 采用循环指令 --&gt;</span><br><span class="line">            &lt;tr v-for=&quot;user in userList&quot;&gt;</span><br><span class="line">                &lt;td&gt;&#123;&#123;user.name&#125;&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;&#123;&#123;user.age&#125;&#125;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el: &#x27;#app&#x27;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                userList:[]</span><br><span class="line">            &#125;,</span><br><span class="line">            created()&#123;//在页面渲染之前执行</span><br><span class="line">                //调用方法，得到返回的json数据</span><br><span class="line">                this.getList()</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                getList()&#123;</span><br><span class="line">                    //使用axios方式ajax请求</span><br><span class="line">                    axios.get(&quot;user.json&quot;)</span><br><span class="line">                        .then(response =&gt; &#123;//请求成功</span><br><span class="line">                            console.log(response)</span><br><span class="line">                            this.userList=response.data.data.items</span><br><span class="line">                            console.log(this.userList)</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .catch(error =&gt; &#123;//请求失败</span><br><span class="line">                            console.log(error)</span><br><span class="line">                        &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HelloWorld系列</category>
      </categories>
  </entry>
  <entry>
    <title>wait和sleep的异同</title>
    <url>/2021/05/29/wait%E5%92%8Csleep%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<h2 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h2><p>一旦执行方法，都可以使得当前的线程进入阻塞状态。</p>
<h2 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h2><p>1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()</p>
<p>2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</p>
<p>3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</p>
<hr>
<p>Sleep()方法是属于Thread类中的，而wait()方法是属于Object类中的。</p>
<p>Sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持着，当指定的时间结束后又会自动恢复运行状态。</p>
<hr>
<p>在调用sleep方法时，线程不会释放对象锁。</p>
<p>在调用wait方法时，线程会释放对象锁，进入等待此对象的等待锁定池，只有此对象调用notify方法后本线程才进入对象锁定池准备。</p>
<p>sleep可以在任何地方使用，而wait只能在同步方法或者同步块中使用。</p>
<p>另外，sleep是静态方法，wait是非静态方法。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>常见的线程调度算法</title>
    <url>/2021/05/27/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="先来先服务（first-come-first-serverd）"><a href="#先来先服务（first-come-first-serverd）" class="headerlink" title="先来先服务（first come first serverd）"></a>先来先服务（first come first serverd）</h3><p>优点：</p>
<p>易于实现，相当公平；</p>
<p>缺点：</p>
<p>有利于长进程，不利于短进程</p>
<hr>
<h3 id="短作业优先（shortest-job-first）"><a href="#短作业优先（shortest-job-first）" class="headerlink" title="短作业优先（shortest job first）"></a>短作业优先（shortest job first）</h3><p>优点：</p>
<p>平均周转时间最短，进程等待时间最短，可以增大系统吞吐量</p>
<p>缺点：</p>
<p>难以预测进程执行时间，开销较大；不利于长进程</p>
<hr>
<h3 id="最短剩余时间优先（shortest-remaining-time-next）"><a href="#最短剩余时间优先（shortest-remaining-time-next）" class="headerlink" title="最短剩余时间优先（shortest remaining time next）"></a>最短剩余时间优先（shortest remaining time next）</h3><p>按预估剩余时间最短顺序进行调度</p>
<hr>
<h3 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h3><p>为了照顾紧迫型作业，使之在进入系统后便获得优先处理。</p>
<p>1、非抢占式优先权算法</p>
<p>2、抢占式优先权算法</p>
<hr>
<h3 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h3><p>根据比率：R=(w+s)/s （R为响应比，w为等待处理的时间，s为预计的服务时间）</p>
<p>如果该进程被立即调用，则R值等于归一化周转时间（周转时间和服务时间的比率）。R最小值为1.0，只有第一个进入系统的进程才能达到该值。调度规则为：当前进程完成或被阻塞时，选择R值最大的就绪进程，它说明了进程的年龄。当偏向短作业时，长进程由于得不到服务，等待时间不断增加，从而增加比值，最终在竞争中赢了短进程。</p>
<p>和最短进程优先、最短剩余时间优先一样，使用最高响应比策略需要估计预计服务时间。</p>
<hr>
<h3 id="时间片轮转法"><a href="#时间片轮转法" class="headerlink" title="时间片轮转法"></a>时间片轮转法</h3><p>轮转法是基于适中的抢占策略的，以一个周期性间隔产生时钟中断，当中断发生后，当前正在运行的进程被置于就绪队列中，然后基于先来先去服务策略选择下一个就绪作业的运行。这种技术也称为时间片，因为每个进程再被抢占之前都给定一片时间。</p>
<hr>
<h3 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h3><p>多级反馈队列算法，不必事先知道各种进程所需要执行的时间，他是当前被公认的一种较好的进程调度算法。其实施过程如下：</p>
<p>1)设置多个就绪队列，并为各个队列赋予不同的优先级。在优先权越高的队列中，为每个进程所规定的执行时间片就越小。</p>
<p>2)当一个新进程进入内存后，首先放入第一队列的末尾，按照先来先去原则排队等候调度。如果他能在一个时间片中完成，便可撤离；如果未完成，就转入第二队列的末尾，同样等待调度…..如此下去，当一个长作业（进程）从第一队列依次将到第n队列（最后队列）后，便按第n队列时间片轮转运行。</p>
<p>3)仅当第一队列空闲的时候，调度程序才调度第二队列中的进程运行；仅当第1到（i-1）队列空时，才会调度第i队列中的进程运行，并执行相应的时间片轮转。</p>
<p>4)如果处理机正在处理第i队列中某进程，又有新进程进入优先权较高的队列，则此新队列抢占正在运行的处理机，并把正在运行的进程放在第i队列的队尾。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>快速失败、安全失败</title>
    <url>/2021/05/29/%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E3%80%81%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<h2 id="快速失败："><a href="#快速失败：" class="headerlink" title="快速失败："></a><strong>快速失败：</strong></h2><p>在使用迭代器对集合进行迭代的过程中，如果 A 线程正在对集合进行遍历，此时 B 线程对集合进行修改（增加、删除、修改），或者 A 线程在遍历过程中对集合进行修改，都会导致 A 线程抛出 ConcurrentModificationException 异常。</p>
<hr>
<h2 id="安全失败："><a href="#安全失败：" class="headerlink" title="安全失败："></a>安全失败：</h2><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2021/05/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>简析：比较相邻的两个元素，如果当前数字比后面的数字大，就交换位置</p>
<p>下列代码做了改进，从数组的末尾开始比较，除了能将最小元素移动至第一位外，还将第二小的元素尽可能的移动至靠近适合它的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,len=arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=len-<span class="number">1</span>;j&gt;=i;--j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>简析：在未排序的序列中，找到最小的元素，放到排列元素的起始位置；然后再从未排序的序列中找到最小的元素，放到已排序序列的末尾，依次类推，直至末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    	minIndex=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;arr.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[minIndex])&#123;</span><br><span class="line">                minIndex=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp=arr[minIndex];</span><br><span class="line">        arr[minIndex]=arr[i];</span><br><span class="line">        arr[i]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>简析：对于未排序的序列，在已排序的序列中从后往前扫描，找到合适的位置并插入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> insertVal=arr[i];<span class="comment">//要插入的值</span></span><br><span class="line">        <span class="keyword">int</span> insertIndex=i-<span class="number">1</span>;<span class="comment">//要插入的值的前一个坐标</span></span><br><span class="line">        <span class="keyword">while</span>(inserIndex&gt;=<span class="number">0</span>&amp;&amp;insertVal&lt;arr[insertIndex])&#123;</span><br><span class="line">            arr[insertIndex+<span class="number">1</span>]=arr[insertIndex];</span><br><span class="line">            intsertIndex--;</span><br><span class="line">        &#125;<span class="comment">//跳出循环时说明要插入的位置在insertIndex后面</span></span><br><span class="line">        arr[insertIndex+<span class="number">1</span>]=insertVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>简析：希尔排序是插入排序的优化版，通过设置不同的步长并逐步减少步长，以步长为单次移动距离，可大幅缩短所需时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> step=len/<span class="number">2</span>;step&gt;<span class="number">0</span>;step/=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="comment">//记录下要移动的元素下标</span></span><br><span class="line">            <span class="keyword">int</span> tmpIndex=i;</span><br><span class="line">            <span class="comment">//记录下要移动的元素值</span></span><br><span class="line">            <span class="keyword">int</span> tmpVal=arr[tmpIndex];</span><br><span class="line">            <span class="comment">//如果需要移动，那就移动至合适的位置</span></span><br><span class="line">            <span class="keyword">if</span>(tmpVal&lt;arr[tmmIndex-step])&#123;</span><br><span class="line">                <span class="keyword">while</span>(temIndex-step&gt;=<span class="number">0</span>&amp;&amp;tmpVal&lt;arr[tmpIndex-step])&#123;</span><br><span class="line">                    arr[tmpIndex]=arr[tmpIndex-step];</span><br><span class="line">                    tmpIndex-=step;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//tmpIndex已经是合适的位置</span></span><br><span class="line">            arr[tmpIndex]=tmpVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>简析：将已有序的子序列合并；起始默认单个元素既是一个有序序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        sort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,tmp);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        sort(arr, left,mid,tmp);</span><br><span class="line">        sort(arr, mid+<span class="number">1</span>, right,tmp);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&lt;=arr[mid+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        merge(arr,left,right,mid,tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> mid,<span class="keyword">int</span>[] tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=left;</span><br><span class="line">        <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">            tmp[k]=arr[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=left ;k&lt;=right;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==mid+<span class="number">1</span>)&#123;</span><br><span class="line">                arr[k]=tmp[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==right+<span class="number">1</span>)&#123;</span><br><span class="line">                arr[k]=tmp[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp[i]&lt;=tmp[j])&#123;</span><br><span class="line">                arr[k]=tmp[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr[k]=tmp[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>简析：通过指定一个pivot，使得数组以pivot为基准，大于pivot的都移动至pivot右边，小于pivot的都移动至其左边，然后对pivot两边的数组再次进行递归排序即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> vodi <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> left=l,right=r;</span><br><span class="line">        <span class="keyword">int</span> pivot=arr[l];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;arr[right]&gt;=pivot)&#123;<span class="comment">//先找到一个需要移动的right。</span></span><br><span class="line">                <span class="comment">//注意，此处必须先寻找right，因为left位置的元素已经取出（就是pivot），所以可以先对left的位置赋值</span></span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                arr[left++]=arr[right]；</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;arr[left]&lt;=pivot)&#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                arr[right--]=arr[left];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[right]=pivot;<span class="comment">//这个赋值给left或者right都可以</span></span><br><span class="line">        quickSort(arr,l,right-<span class="number">1</span>);</span><br><span class="line">        quickSort(arr,right+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mithrandir</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-03-2021/3/27-21:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSortAnother</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        quicksort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机将一个数字放至其合适的位置，并对该位置左右两区间进行排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 数组的左端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 数组的右端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=partition(arr,left,right);</span><br><span class="line">        quicksort(arr, left, mid-<span class="number">1</span>);</span><br><span class="line">        quicksort(arr, mid+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个要完成的功能是对数组内的一个随机数字安排至合适的位置，并以该位置为根据将数组分为左右区间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//来区间内位置的一个随机位置</span></span><br><span class="line">        <span class="keyword">int</span> tmpIndex=random.nextInt(right-left+<span class="number">1</span>)+left;</span><br><span class="line">        <span class="comment">//将该位置的数字放到数组的最右侧</span></span><br><span class="line">        swap(arr,tmpIndex,right);</span><br><span class="line">        <span class="comment">//定义一个索引</span></span><br><span class="line">        <span class="keyword">int</span> index=left;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;arr[right])&#123;<span class="comment">//凡是小于我们的随机数的值，一律从左开始排</span></span><br><span class="line">                swap(arr, i, index++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时，index左侧的所有值，均小于随机数，将随机数放到index的位置</span></span><br><span class="line">        swap(arr,index, right);</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=arr[i];</span><br><span class="line">        arr[i]=arr[j];</span><br><span class="line">        arr[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>简析：计数排序适用于元素数值较为集中，且元素要是确定范围内的整数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到arr里的最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> min=arr[<span class="number">0</span>],max=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;max)&#123;</span><br><span class="line">            max=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;min)&#123;</span><br><span class="line">            min=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个关键值</span></span><br><span class="line">    <span class="keyword">int</span> bias=<span class="number">0</span>-min;</span><br><span class="line">    <span class="comment">//准备一个额外数组</span></span><br><span class="line">    <span class="keyword">int</span>[] bucket=<span class="keyword">new</span> <span class="keyword">int</span>[max-min+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//遍历整个数组，记录每个元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        bucket[arr[i]+bias]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接下来准备重新排列arr,index为arr的索引，i为bucket的索引</span></span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(index&lt;arr.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bucket[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            arr[index++]=i-bias;</span><br><span class="line">            bucket[i]--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>简析：基数和计数都是用了桶来进行排序，不同的是，基数对所有元素的分配做了优化：按照每个元素的同一位（即个位，十位等）进行摆放，也就是说，所用到的桶一共有10层（0~9），在一轮循环中，每一层放的数据在某一位都相同。基数排序用的空间取决于元素的个数，而计数排序所用的额外空间取决于元素的范围（即最小-最大）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">review</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一步，先找到数组中的最大值</span></span><br><span class="line">        <span class="keyword">int</span> size = arr.length;</span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据最大值找到最大长度</span></span><br><span class="line">        String str = max + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = str.length();</span><br><span class="line">        <span class="comment">//创建一个桶，用于盛放处理后的数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][size];</span><br><span class="line">        <span class="comment">//还得创建一个计数器，用于计算每个位置放了多少个数据</span></span><br><span class="line">        <span class="keyword">int</span>[] numsCounter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//接下来就进入每一层的操作：放入桶，从桶中取出</span></span><br><span class="line">        <span class="comment">//定义两个变量，k用于确定数据的哪一层，m用于对每个数据进行取余操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, m = <span class="number">1</span>; k &lt; maxLength; m *= <span class="number">10</span>, k++) &#123;</span><br><span class="line">            <span class="comment">//先将数据取出，根据个（十、百）位数的大小放入桶中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">//取出个位</span></span><br><span class="line">                <span class="keyword">int</span> num = arr[i] / m % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">//放入个位对应的桶中</span></span><br><span class="line">                bucket[num][numsCounter[num]++] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时已完成所有数据入桶,按照顺序将其取出</span></span><br><span class="line">            <span class="comment">//定义一个索引，用于在arr中重新排序</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (numsCounter[i] != <span class="number">0</span>) &#123;<span class="comment">//i的取值范围是0~9，numsCounter[i]!=0说明该位置存放的有数据，需要取出</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numsCounter[i]; j++) &#123;</span><br><span class="line">                        arr[index++] = bucket[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                numsCounter[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HelloWorld系列</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索算法</title>
    <url>/2021/05/26/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">0</span>,height=arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=height)&#123;</span><br><span class="line">        mid=(low+height)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&lt;target)&#123;</span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&gt;target)&#123;</span><br><span class="line">            height=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>适用于数值分布均匀的查找表。</p>
<h3 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">0</span>,height=arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=height)&#123;</span><br><span class="line">        mid=low+(hight-low)(arr[mid]-arr[low])/(arr[height]-arr[low]);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&lt;target)&#123;</span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&gt;target)&#123;</span><br><span class="line">            height=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><p>利用了斐波那契数列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>,heigh=arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] f=fib();</span><br><span class="line">        <span class="comment">//k为合适的斐波那契数</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(heigh&gt;f[k]-<span class="number">1</span>)&#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义斐波那契数长度的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = Arrays.copyOf(arr, f[k]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=heigh;i&lt;f[k];i++)&#123;</span><br><span class="line">            nums[i]=nums[heigh];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (low&lt;=heigh)&#123;</span><br><span class="line">            mid=low+f[k-<span class="number">1</span>]-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;arr[mid])&#123;</span><br><span class="line">                k-=<span class="number">2</span>;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;arr[mid])&#123;</span><br><span class="line">                --k;</span><br><span class="line">                heigh=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid&lt;heigh)&#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> heigh;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//创建一个斐波那契数列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib()&#123;</span><br><span class="line">        <span class="keyword">int</span>[] f=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            f[i]=f[i-<span class="number">1</span>]+f[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HelloWorld系列</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>简单死锁的测试</title>
    <url>/2021/05/29/%E7%AE%80%E5%8D%95%E6%AD%BB%E9%94%81%E7%9A%84%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mithrandir</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-04-2021/4/12-10:19</span></span><br><span class="line"><span class="comment"> * 测试死锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> myThread1()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> myThread2()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (myLock.lock2)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是myThread2的第一层，已经持有lock2&quot;</span>);<span class="comment">//死锁情况下，只有这行能输出</span></span><br><span class="line">            <span class="keyword">synchronized</span> (myLock.lock1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是myThread2的第二层，已经持有lock2和lock1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (myLock.lock1)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是myThread1的第一层,已经持有lock1&quot;</span>);<span class="comment">//死锁情况下，只有这行能输出</span></span><br><span class="line">            <span class="keyword">synchronized</span> (myLock.lock2)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是myThead1的第二层，已经持有lock1和lock2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myLock</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object lock1=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object lock2=<span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>线程状态</title>
    <url>/2021/05/27/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>新建状态（new）</p>
<p>线程创建之后</p>
<p>可运行（running）</p>
<p>可能正在运行，也可能正在等待cpu时间片</p>
<p>阻塞（blocked）</p>
<p>等待获取一个排他锁，如果其他线程释放了锁就会结束此状态</p>
<p>无限期等待（waiting）</p>
<p>等待其他线程显示唤醒，否则不会分配cpu时间片</p>
<p>限期等待（time_waiting）</p>
<p>无需其他线程进行显示唤醒，到达时间之后会被系统自动唤醒</p>
<p>终止（terminated）</p>
<p>可能是任务结束之后的终止，也可能是出现异常终止</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>解决线程安全的方式</title>
    <url>/2021/05/29/%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="一：同步代码块"><a href="#一：同步代码块" class="headerlink" title="一：同步代码块"></a>一：同步代码块</h2><p>synchronized(同步监视器){</p>
<p>   //需要被同步的代码</p>
<p>  }</p>
<p> 说明：</p>
<p>1.操作共享数据的代码，即为需要被同步的代码。 –&gt;不能包含代码多了，也不能包含代码少了。</p>
<p>​      2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。</p>
<p>​      3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。</p>
<p>​     要求：多个线程必须要共用同一把锁。</p>
<p> 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</p>
<p>​    在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视</p>
<hr>
<h2 id="二：同步方法"><a href="#二：同步方法" class="headerlink" title="二：同步方法"></a>二：同步方法</h2><p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。</p>
<p> 关于同步方法的总结：</p>
<p> \1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</p>
<p> \2. 非静态的同步方法，同步监视器是：this</p>
<p>   静态的同步方法，同步监视器是：当前类本身</p>
<p>同步代码块和同步方法的对比：</p>
<p>其实还是同步代码块好一些，因为同步方法的作用范围相对来说会比较广泛，很容易会包括进一些没必要同步的代码，这样会造成效率降低。</p>
<hr>
<h2 id="三：同步锁Lock（jdk5-0新增，也就是建议用）"><a href="#三：同步锁Lock（jdk5-0新增，也就是建议用）" class="headerlink" title="三：同步锁Lock（jdk5.0新增，也就是建议用）"></a>三：同步锁Lock（jdk5.0新增，也就是建议用）</h2><p>在需要同步的代码前调用Lock 的lock函数，在需要同步的代码执行完之后，手动调用unlock函数才能释放锁。（创建lock对象时，用的时reentrantlock这个类创建的）</p>
<h2 id="synchronize和lock的异同："><a href="#synchronize和lock的异同：" class="headerlink" title="synchronize和lock的异同："></a>synchronize和lock的异同：</h2><p>同：都可以解决线程安全问题</p>
<p>异：synchronize在执行完对应的代码块之后，会自动释放锁；lock必须手动释放锁</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>运行Halo项目时遇到的问题</title>
    <url>/2021/05/31/%E8%BF%90%E8%A1%8CHalo%E9%A1%B9%E7%9B%AE%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="/2021/05/31/%E8%BF%90%E8%A1%8CHalo%E9%A1%B9%E7%9B%AE%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/Failedto.jpg" alt="Failedto"></p>
<p>这个问题在将jdk版本从8改为11之后就没遇到了;</p>
<p>但是在后续的运行中又出现了其他错误，经查阅资料，将IDEA从2019.3升级为2020.3之后解决；</p>
<p>后记：改完之后还需要将gradle的jdk版本以及项目运行依赖的jdk版本改为11（我装了8和11两个版本）；</p>
<p>最后一次运行报错是显示未找到默认主题，在<a href="https://github.com/halo-dev/halo-theme-anatole">halo-dev/halo-theme-anatole (github.com)</a>进行下载并存放至Halo\halo\src\main\resources\templates\themes\anatole后，成功运行。</p>
<p>至此成功运行。</p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
  </entry>
  <entry>
    <title>线程进程协程</title>
    <url>/2021/05/27/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong>进程</strong></h2><p>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a><strong>线程</strong></h2><p>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</p>
<p>与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<h2 id="进程与线程的区别总结"><a href="#进程与线程的区别总结" class="headerlink" title="进程与线程的区别总结"></a><strong>进程与线程的区别总结</strong></h2><p>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p>
<p>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位 </p>
<p>资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 </p>
<p>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 </p>
<p>内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的 </p>
<p>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 </p>
<p>执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p>
<h3 id="多进程和多线程区别"><a href="#多进程和多线程区别" class="headerlink" title="多进程和多线程区别"></a><strong>多进程和多线程区别</strong></h3><p>多进程：操作系统中同时运行的多个程序</p>
<p>多线程：在同一个进程中同时运行的多个任务</p>
<p>举个例子，多线程下载软件，可以同时运行多个线程，但是通过程序运行的结果发现，每一次结果都不一致。 因为多线程存在一个特性：随机性。造成的原因：CPU在瞬间不断切换去处理各个线程而导致的，可以理解成多个线程在抢CPU资源。</p>
<h3 id="Java中的多线程"><a href="#Java中的多线程" class="headerlink" title="Java中的多线程"></a><strong>Java中的多线程</strong></h3><p>Java程序的进程里有几个线程：主线程，垃圾回收线程(后台线程)等</p>
<p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p>
<p> Java支持多线程，当Java程序执行main方法的时候，就是在执行一个名字叫做main的线程，可以在main方法执行时，开启多个线程A,B,C，多个线程 main,A,B,C同时执行，相互抢夺CPU，Thread类是java.lang包下的一个常用类,每一个Thread类的对象，就代表一个处于某种状态的线程</p>
<h3 id="从-JVM-角度说进程和线程之间的关系（重要）"><a href="#从-JVM-角度说进程和线程之间的关系（重要）" class="headerlink" title="从 JVM 角度说进程和线程之间的关系（重要）"></a><strong>从 JVM 角度说进程和线程之间的关系（重要）</strong></h3><p><img src="/2021/05/27/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="运行时数据区域"></p>
<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。</p>
<p>程序计数器为什么是私有的?</p>
<p>程序计数器主要有下面两个作用：</p>
<p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</p>
<p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</p>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。</p>
<p>虚拟机栈和本地方法栈为什么是私有的?</p>
<p>虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<p>本地方法栈：和虚拟机栈所发挥的作用非常相似，区别是:虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p>
<p>一句话简单了解堆和方法区</p>
<p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>来自 <a href="https://blog.csdn.net/ThinkWon/article/details/102021274">https://blog.csdn.net/ThinkWon/article/details/102021274</a> </p>
<p><strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p>
<p><img src="/2021/05/27/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B.png" alt="进程线程协程"></p>
<p>最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</p>
<p>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<p>既然协程这么好，它到底是怎么来使用的呢？</p>
<p>由于Java的原生语法中并没有实现协程（某些开源框架实现了协程，但是很少被使用）；</p>
<p>协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。</p>
<p>因此，<strong>协程的开销远远小于线程的开销。</strong></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>进程间通信方式</title>
    <url>/2021/05/27/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="进程之间的通信方式"><a href="#进程之间的通信方式" class="headerlink" title="进程之间的通信方式"></a><a href="https://blog.csdn.net/weixin_44653395/article/details/99686244">进程之间的通信方式</a></h2><p><strong>1.无名管道( pipe )：</strong> 管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
<p><strong>2.高级管道(popen)：</strong> 将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。</p>
<p><strong>3.有名管道 (named pipe) ：</strong> 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
<p><strong>4.消息队列( message queue ) ：</strong> 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<p><strong>5.信号量( semophore ) ：</strong> 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<p><strong>6.信号 ( sinal ) ：</strong> 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<p><strong>7.共享内存( shared memory ) ：</strong> 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p>
<p><strong>8.套接字( socket ) ：</strong> 套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java反射机制</title>
    <url>/2021/05/27/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a><a href="%5BJava%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3_%E5%BC%A0%E7%BB%B4%E9%B9%8F%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2_java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%5D(https://blog.csdn.net/a745233700/article/details/82893076)">Java反射机制</a></h2><h3 id="一、什么是反射："><a href="#一、什么是反射：" class="headerlink" title="一、什么是反射："></a>一、什么是反射：</h3><p>（1）Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。</p>
<p>（2）Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。</p>
<h3 id="二、反射的原理："><a href="#二、反射的原理：" class="headerlink" title="二、反射的原理："></a>二、反射的原理：</h3><p>下图是类的正常加载过程、反射原理与class对象：</p>
<p><img src="/2021/05/27/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%92%8C%E5%8F%8D%E5%B0%84.jpg" alt="类的加载过程和反射"></p>
<p>Class对象的由来是将.class文件读入内存，并为之创建一个Class对象。</p>
<p>对于类加载机制与双亲委派模型感兴趣的小伙伴可以阅读<a href="https://blog.csdn.net/a745233700/article/details/90232862">这篇文章</a></p>
<h3 id="三、反射的优缺点"><a href="#三、反射的优缺点" class="headerlink" title="三、反射的优缺点"></a>三、反射的优缺点</h3><p>优点：在运行时获得类的各种内容，进行反编译，对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。</p>
<p>缺点：（1）反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；</p>
<p>（2）反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</p>
<h3 id="四、反射的用途"><a href="#四、反射的用途" class="headerlink" title="四、反射的用途"></a>四、反射的用途</h3><p>1、反编译：.class–&gt;.java</p>
<p>2、通过反射机制访问java对象的属性，方法，构造方法等</p>
<p>3、当我们在使用IDE,比如Ecplise时，当我们输入一个对象或者类，并想调用他的属性和方法是，一按点号，编译器就会自动列出他的属性或者方法，这里就是用到反射。</p>
<p>4、反射最重要的用途就是开发各种通用框架。比如很多框架（Spring）都是配置化的（比如通过XML文件配置Bean），为了保证框架的通用性，他们可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象。</p>
<p>5、例如，在使用Strut2框架的开发过程中，我们一般会在struts.xml里去配置Action，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;action name=&quot;login&quot; class=&quot;org.ScZyhSoft.test.action.SimpleLoginAction&quot; method=&quot;execute&quot;&gt;  </span><br><span class="line"></span><br><span class="line">  &lt;result&gt;/shop/shop-index.jsp&lt;/result&gt;      </span><br><span class="line"></span><br><span class="line">  &lt;result name=&quot;error&quot;&gt;login.jsp&lt;/result&gt;    </span><br><span class="line"></span><br><span class="line">&lt;/action&gt;</span><br></pre></td></tr></table></figure>

<p>比如我们请求login.action时，那么StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，从action中查找出name为login的Action，并根据class属性创建SimpleLoginAction实例，并用Invoke方法来调用execute方法，这个过程离不开反射。配置文件与Action建立了一种映射关系，当View层发出请求时，请求会被StrutsPrepareAndExecuteFilter拦截，然后StrutsPrepareAndExecuteFilter会去动态地创建Action实例。</p>
<p>比如，加载数据库驱动的，用到的也是反射。</p>
<p>Class.forName(“com.mysql.jdbc.Driver”); // 动态加载mysql驱动</p>
<h3 id="五、反射的基本使用"><a href="#五、反射的基本使用" class="headerlink" title="五、反射的基本使用"></a>五、反射的基本使用</h3><h4 id="获得Class：主要有三种方法："><a href="#获得Class：主要有三种方法：" class="headerlink" title="获得Class：主要有三种方法："></a>获得Class：主要有三种方法：</h4><p>（1）Object–&gt;getClass</p>
<p>（2）任何数据类型（包括基本的数据类型）都有一个“静态”的class属性</p>
<p>（3）通过class类的静态方法：forName(String className)（最常用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fanshe</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//第一种方式获取Class对象  </span></span><br><span class="line">		Student stu1 = <span class="keyword">new</span> Student();<span class="comment">//这一new 产生一个Student对象，一个Class对象。</span></span><br><span class="line">		Class stuClass = stu1.getClass();<span class="comment">//获取Class对象</span></span><br><span class="line">		System.out.println(stuClass.getName());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第二种方式获取Class对象</span></span><br><span class="line">		Class stuClass2 = Student.class;</span><br><span class="line">		System.out.println(stuClass == stuClass2);<span class="comment">//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第三种方式获取Class对象</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class stuClass3 = Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);<span class="comment">//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名</span></span><br><span class="line">			System.out.println(stuClass3 == stuClass2);<span class="comment">//判断三种方式是否获取的是同一个Class对象</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，在运行期间，一个类，只有一个Class对象产生，所以打印结果都是true；</p>
<p>三种方式中，常用第三种，第一种对象都有了还要反射干什么，第二种需要导入类包，依赖太强，不导包就抛编译错误。一般都使用第三种，一个字符串可以传入也可以写在配置文件中等多种方法。</p>
<h4 id="判断是否为某个类的示例："><a href="#判断是否为某个类的示例：" class="headerlink" title="判断是否为某个类的示例："></a>判断是否为某个类的示例：</h4><p>一般的，我们使用instanceof 关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断时候为某个类的实例，他是一个native方法。</p>
<p>public native boolean isInstance(Object obj);</p>
<h4 id="创建实例：通过反射来生成对象主要有两种方法："><a href="#创建实例：通过反射来生成对象主要有两种方法：" class="headerlink" title="创建实例：通过反射来生成对象主要有两种方法："></a>创建实例：通过反射来生成对象主要有两种方法：</h4><p>（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。</p>
<p>Class&lt;?&gt; c = String.class;</p>
<p>Object str = c.newInstance();</p>
<p>（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建对象，这种方法可以用指定的构造器构造类的实例。</p>
<p>//获取String的Class对象</p>
<p>Class&lt;?&gt; str = String.class;</p>
<p>//通过Class对象获取指定的Constructor构造器对象</p>
<p>Constructor constructor=c.getConstructor(String.class);</p>
<p>//根据构造器创建实例：</p>
<p>Object obj = constructor.newInstance(“hello reflection”);</p>
<h4 id="通过反射获取构造方法并使用："><a href="#通过反射获取构造方法并使用：" class="headerlink" title="通过反射获取构造方法并使用："></a>通过反射获取构造方法并使用：</h4><p>（1）批量获取的方法：</p>
<p>public Constructor[] getConstructors()：所有”公有的”构造方法</p>
<p>public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</p>
<p>（2）单个获取的方法，并调用：</p>
<p>public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法：</p>
<p>public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有；</p>
<p>（3） 调用构造方法：</p>
<p>Constructor–&gt;newInstance(Object… initargs)</p>
<p>newInstance是 Constructor类的方法（管理构造函数的类）</p>
<p>api的解释为：newInstance(Object… initargs) ，使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。</p>
<p>它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象，并为之调用。</p>
<p>例子：</p>
<p>Student类：共六个构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">//---------------构造方法-------------------</span></span><br><span class="line">	<span class="comment">//（默认的构造方法）</span></span><br><span class="line">	Student(String str)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;(默认)的构造方法 s = &quot;</span> + str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//无参构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用了公有、无参构造方法执行了。。。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有一个参数的构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">char</span> name)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;姓名：&quot;</span> + name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有多个参数的构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name ,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;年龄：&quot;</span>+ age);<span class="comment">//这的执行效率有问题，以后解决。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//受保护的构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">Student</span><span class="params">(<span class="keyword">boolean</span> n)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;受保护的构造方法 n = &quot;</span> + n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//私有构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;私有的构造方法   年龄：&quot;</span>+ age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员；</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.获取构造方法：</span></span><br><span class="line"><span class="comment"> * 		1).批量的方法：</span></span><br><span class="line"><span class="comment"> * 			public Constructor[] getConstructors()：所有&quot;公有的&quot;构造方法</span></span><br><span class="line"><span class="comment">            public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</span></span><br><span class="line"><span class="comment"> * 		2).获取单个的方法，并调用：</span></span><br><span class="line"><span class="comment"> * 			public Constructor getConstructor(Class... parameterTypes):获取单个的&quot;公有的&quot;构造方法：</span></span><br><span class="line"><span class="comment"> * 			public Constructor getDeclaredConstructor(Class... parameterTypes):获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有； 		</span></span><br><span class="line"><span class="comment"> * 		3).调用构造方法：</span></span><br><span class="line"><span class="comment"> * 			Constructor--&gt;newInstance(Object... initargs)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constructors</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//1.加载Class对象</span></span><br><span class="line">		Class clazz = Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.获取所有公有构造方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;**********************所有公有构造方法*********************************&quot;</span>);</span><br><span class="line">		Constructor[] conArray = clazz.getConstructors();</span><br><span class="line">		<span class="keyword">for</span>(Constructor c : conArray)&#123;</span><br><span class="line">			System.out.println(c);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;************所有的构造方法(包括：私有、受保护、默认、公有)***************&quot;</span>);</span><br><span class="line">		conArray = clazz.getDeclaredConstructors();</span><br><span class="line">		<span class="keyword">for</span>(Constructor c : conArray)&#123;</span><br><span class="line">			System.out.println(c);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;*****************获取公有、无参的构造方法*******************************&quot;</span>);</span><br><span class="line">		Constructor con = clazz.getConstructor(<span class="keyword">null</span>);</span><br><span class="line">		<span class="comment">//1&gt;、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型</span></span><br><span class="line">		<span class="comment">//2&gt;、返回的是描述这个无参构造函数的类对象。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;con = &quot;</span> + con);</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//调用构造方法</span></span><br><span class="line">		Object obj = con.newInstance();</span><br><span class="line">	<span class="comment">//	System.out.println(&quot;obj = &quot; + obj);</span></span><br><span class="line">	<span class="comment">//	Student stu = (Student)obj;</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;******************获取私有构造方法，并调用*******************************&quot;</span>);</span><br><span class="line">		con = clazz.getDeclaredConstructor(<span class="keyword">char</span>.class);</span><br><span class="line">		System.out.println(con);</span><br><span class="line">		<span class="comment">//调用构造方法</span></span><br><span class="line">		con.setAccessible(<span class="keyword">true</span>);<span class="comment">//暴力访问(忽略掉访问修饰符)</span></span><br><span class="line">		obj = con.newInstance(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>控制台输出：</p>
<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>所有公有构造方法</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>***********</p>
<p>public fanshe.Student(java.lang.String,int)</p>
<p>public fanshe.Student(char)</p>
<p>public fanshe.Student()</p>
<p><strong><strong><strong><strong><strong><strong>所有的构造方法(包括：私有、受保护、默认、公有)</strong></strong></strong></strong></strong></strong>***</p>
<p>private fanshe.Student(int)</p>
<p>protected fanshe.Student(boolean)</p>
<p>public fanshe.Student(java.lang.String,int)</p>
<p>public fanshe.Student(char)</p>
<p>public fanshe.Student()</p>
<p>fanshe.Student(java.lang.String)</p>
<p><em><strong><strong><strong><strong><strong><strong><strong><strong>获取公有、无参的构造方法</strong></strong></strong></strong></strong></strong></strong></strong></em>**************</p>
<p>con = public fanshe.Student()</p>
<p>调用了公有、无参构造方法执行了。。。</p>
<p><strong><strong><strong><strong><strong><strong><strong><strong><strong>获取私有构造方法，并调用</strong></strong></strong></strong></strong></strong></strong></strong></strong>*************</p>
<p>public fanshe.Student(char)</p>
<p>姓名：男</p>
<h4 id="获取成员变量并调用："><a href="#获取成员变量并调用：" class="headerlink" title="获取成员变量并调用："></a>获取成员变量并调用：</h4><p>Student类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.field;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//**********字段*************//</span></span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">	<span class="keyword">private</span> String phoneNum;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, sex=&quot;</span> + sex</span><br><span class="line">				+ <span class="string">&quot;, phoneNum=&quot;</span> + phoneNum + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取成员变量并调用：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.批量的</span></span><br><span class="line"><span class="comment"> * 		1).Field[] getFields():获取所有的&quot;公有字段&quot;</span></span><br><span class="line"><span class="comment"> * 		2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；</span></span><br><span class="line"><span class="comment"> * 2.获取单个的：</span></span><br><span class="line"><span class="comment"> * 		1).public Field getField(String fieldName):获取某个&quot;公有的&quot;字段；</span></span><br><span class="line"><span class="comment"> * 		2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 	 设置字段的值：</span></span><br><span class="line"><span class="comment"> * 		Field --&gt; public void set(Object obj,Object value):</span></span><br><span class="line"><span class="comment"> * 					参数说明：</span></span><br><span class="line"><span class="comment"> * 					1.obj:要设置的字段所在的对象；</span></span><br><span class="line"><span class="comment"> * 					2.value:要为字段设置的值；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fields</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			<span class="comment">//1.获取Class对象</span></span><br><span class="line">			Class stuClass = Class.forName(<span class="string">&quot;fanshe.field.Student&quot;</span>);</span><br><span class="line">			<span class="comment">//2.获取字段</span></span><br><span class="line">			System.out.println(<span class="string">&quot;************获取所有公有的字段********************&quot;</span>);</span><br><span class="line">			Field[] fieldArray = stuClass.getFields();</span><br><span class="line">			<span class="keyword">for</span>(Field f : fieldArray)&#123;</span><br><span class="line">				System.out.println(f);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;************获取所有的字段(包括私有、受保护、默认的)********************&quot;</span>);</span><br><span class="line">			fieldArray = stuClass.getDeclaredFields();</span><br><span class="line">			<span class="keyword">for</span>(Field f : fieldArray)&#123;</span><br><span class="line">				System.out.println(f);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;*************获取公有字段**并调用***********************************&quot;</span>);</span><br><span class="line">			Field f = stuClass.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">			System.out.println(f);</span><br><span class="line">			<span class="comment">//获取一个对象</span></span><br><span class="line">			Object obj = stuClass.getConstructor().newInstance();<span class="comment">//产生Student对象--》Student stu = new Student();</span></span><br><span class="line">			<span class="comment">//为字段设置值</span></span><br><span class="line">			f.set(obj, <span class="string">&quot;刘德华&quot;</span>);<span class="comment">//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot;</span></span><br><span class="line">			<span class="comment">//验证</span></span><br><span class="line">			Student stu = (Student)obj;</span><br><span class="line">			System.out.println(<span class="string">&quot;验证姓名：&quot;</span> + stu.name);</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">&quot;**************获取私有字段****并调用********************************&quot;</span>);</span><br><span class="line">			f = stuClass.getDeclaredField(<span class="string">&quot;phoneNum&quot;</span>);</span><br><span class="line">			System.out.println(f);</span><br><span class="line">			f.setAccessible(<span class="keyword">true</span>);<span class="comment">//暴力反射，解除私有限定</span></span><br><span class="line">			f.set(obj, <span class="string">&quot;18888889999&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;验证电话：&quot;</span> + stu);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong><strong><strong><strong><strong>获取所有公有的字段</strong></strong></strong></strong></strong></strong>********</p>
<p>public java.lang.String fanshe.field.Student.name</p>
<p><strong><strong><strong><strong><strong><strong>获取所有的字段(包括私有、受保护、默认的)</strong></strong></strong></strong></strong></strong>********</p>
<p>public java.lang.String fanshe.field.Student.name</p>
<p>protected int fanshe.field.Student.age</p>
<p>char fanshe.field.Student.sex</p>
<p>private java.lang.String fanshe.field.Student.phoneNum</p>
<p><em><strong>*<em><strong><strong>*<em><strong>获取公有字段</strong>并调用</em>*</strong></strong></em>*</strong>****</em>********************</p>
<p>public java.lang.String fanshe.field.Student.name</p>
<p>验证姓名：刘德华</p>
<p><strong><strong><strong>*<em><strong><strong><strong>获取私有字段</strong></strong>并调用</strong></em>*</strong></strong>********</strong>**************</p>
<p>private java.lang.String fanshe.field.Student.phoneNum</p>
<p>验证电话：Student [name=刘德华, age=0, sex=</p>
<h4 id="获取成员方法并调用："><a href="#获取成员方法并调用：" class="headerlink" title="获取成员方法并调用："></a>获取成员方法并调用：</h4><p>Student类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.method;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">//**************成员方法***************//</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用了：公有的，String参数的show1(): s = &quot;</span> + s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用了：受保护的，无参的show2()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用了：默认的，无参的show3()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">show4</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用了，私有的，并且有返回值的，int参数的show4(): age = &quot;</span> + age);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取成员方法并调用：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.批量的：</span></span><br><span class="line"><span class="comment"> * 		public Method[] getMethods():获取所有&quot;公有方法&quot;；（包含了父类的方法也包含Object类）</span></span><br><span class="line"><span class="comment"> * 		public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</span></span><br><span class="line"><span class="comment"> * 2.获取单个的：</span></span><br><span class="line"><span class="comment"> * 		public Method getMethod(String name,Class&lt;?&gt;... parameterTypes):</span></span><br><span class="line"><span class="comment"> * 					参数：</span></span><br><span class="line"><span class="comment"> * 						name : 方法名；</span></span><br><span class="line"><span class="comment"> * 						Class ... : 形参的Class类型对象</span></span><br><span class="line"><span class="comment"> * 		public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 	 调用方法：</span></span><br><span class="line"><span class="comment"> * 		Method --&gt; public Object invoke(Object obj,Object... args):</span></span><br><span class="line"><span class="comment"> * 					参数说明：</span></span><br><span class="line"><span class="comment"> * 					obj : 要调用方法的对象；</span></span><br><span class="line"><span class="comment"> * 					args:调用方式时所传递的实参；</span></span><br><span class="line"><span class="comment">):</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodClass</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//1.获取Class对象</span></span><br><span class="line">		Class stuClass = Class.forName(<span class="string">&quot;fanshe.method.Student&quot;</span>);</span><br><span class="line">		<span class="comment">//2.获取所有公有方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;***************获取所有的”公有“方法*******************&quot;</span>);</span><br><span class="line">		stuClass.getMethods();</span><br><span class="line">		Method[] methodArray = stuClass.getMethods();</span><br><span class="line">		<span class="keyword">for</span>(Method m : methodArray)&#123;</span><br><span class="line">			System.out.println(m);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;***************获取所有的方法，包括私有的*******************&quot;</span>);</span><br><span class="line">		methodArray = stuClass.getDeclaredMethods();</span><br><span class="line">		<span class="keyword">for</span>(Method m : methodArray)&#123;</span><br><span class="line">			System.out.println(m);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;***************获取公有的show1()方法*******************&quot;</span>);</span><br><span class="line">		Method m = stuClass.getMethod(<span class="string">&quot;show1&quot;</span>, String.class);</span><br><span class="line">		System.out.println(m);</span><br><span class="line">		<span class="comment">//实例化一个Student对象</span></span><br><span class="line">		Object obj = stuClass.getConstructor().newInstance();</span><br><span class="line">		m.invoke(obj, <span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;***************获取私有的show4()方法******************&quot;</span>);</span><br><span class="line">		m = stuClass.getDeclaredMethod(<span class="string">&quot;show4&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">		System.out.println(m);</span><br><span class="line">		m.setAccessible(<span class="keyword">true</span>);<span class="comment">//解除私有限定</span></span><br><span class="line">		Object result = m.invoke(obj, <span class="number">20</span>);<span class="comment">//需要两个参数，一个是要调用的对象（获取有反射），一个是实参</span></span><br><span class="line">		System.out.println(<span class="string">&quot;返回值：&quot;</span> + result);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<p><em><strong><strong><strong><strong><strong><strong><strong>获取所有的”公有“方法</strong></strong></strong></strong></strong></strong></strong></em>****</p>
<p>public void fanshe.method.Student.show1(java.lang.String)</p>
<p>public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</p>
<p>public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</p>
<p>public final void java.lang.Object.wait() throws java.lang.InterruptedException</p>
<p>public boolean java.lang.Object.equals(java.lang.Object)</p>
<p>public java.lang.String java.lang.Object.toString()</p>
<p>public native int java.lang.Object.hashCode()</p>
<p>public final native java.lang.Class java.lang.Object.getClass()</p>
<p>public final native void java.lang.Object.notify()</p>
<p>public final native void java.lang.Object.notifyAll()</p>
<p><em><strong><strong><strong><strong><strong><strong><strong>获取所有的方法，包括私有的</strong></strong></strong></strong></strong></strong></strong></em>****</p>
<p>public void fanshe.method.Student.show1(java.lang.String)</p>
<p>private java.lang.String fanshe.method.Student.show4(int)</p>
<p>protected void fanshe.method.Student.show2()</p>
<p>void fanshe.method.Student.show3()</p>
<p><em><strong><strong><strong><strong><strong><strong><strong>获取公有的show1()方法</strong></strong></strong></strong></strong></strong></strong></em>****</p>
<p>public void fanshe.method.Student.show1(java.lang.String)</p>
<p>调用了：公有的，String参数的show1(): s = 刘德华</p>
<p><em><strong><strong><strong><strong><strong><strong><strong>获取私有的show4()方法</strong></strong></strong></strong></strong></strong></strong></em>***</p>
<p>private java.lang.String fanshe.method.Student.show4(int)</p>
<p>调用了，私有的，并且有返回值的，int参数的show4(): age = 20</p>
<p>返回值：abcd</p>
<h4 id="反射main方法"><a href="#反射main方法" class="headerlink" title="反射main方法:"></a>反射main方法:</h4><p>Student类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.main;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;main方法执行了。。。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">测试类：</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fanshe.main;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Student类的main方法、不要与当前的main方法搞混了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//1、获取Student对象的字节码</span></span><br><span class="line">			Class clazz = Class.forName(<span class="string">&quot;fanshe.main.Student&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//2、获取main方法</span></span><br><span class="line">			 Method methodMain = clazz.getMethod(<span class="string">&quot;main&quot;</span>, String[].class);<span class="comment">//第一个参数：方法名称，第二个参数：方法形参的类型，</span></span><br><span class="line">			<span class="comment">//3、调用main方法</span></span><br><span class="line">			<span class="comment">// methodMain.invoke(null, new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);</span></span><br><span class="line">			 <span class="comment">//第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数</span></span><br><span class="line">			 <span class="comment">//这里拆的时候将  new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125; 拆成3个对象。。。所以需要将它强转。</span></span><br><span class="line">			 methodMain.invoke(<span class="keyword">null</span>, (Object)<span class="keyword">new</span> String[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;);<span class="comment">//方式一</span></span><br><span class="line">			<span class="comment">// methodMain.invoke(null, new Object[]&#123;new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;&#125;);//方式二			</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<p>main方法执行了。。。</p>
<h4 id="利用反射创建数值："><a href="#利用反射创建数值：" class="headerlink" title="利用反射创建数值："></a>利用反射创建数值：</h4><p>数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testArray</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        Object array = Array.newInstance(cls,<span class="number">25</span>);</span><br><span class="line">        <span class="comment">//往数组里添加内容</span></span><br><span class="line">        Array.set(array,<span class="number">0</span>,<span class="string">&quot;golang&quot;</span>);</span><br><span class="line">        Array.set(array,<span class="number">1</span>,<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        Array.set(array,<span class="number">2</span>,<span class="string">&quot;pytho&quot;</span>);</span><br><span class="line">        Array.set(array,<span class="number">3</span>,<span class="string">&quot;Scala&quot;</span>);</span><br><span class="line">        Array.set(array,<span class="number">4</span>,<span class="string">&quot;Clojure&quot;</span>);</span><br><span class="line">        <span class="comment">//获取某一项的内容</span></span><br><span class="line">        System.out.println(Array.get(array,<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反射方法的其他使用–通过反射运行配置文件内容："><a href="#反射方法的其他使用–通过反射运行配置文件内容：" class="headerlink" title="反射方法的其他使用–通过反射运行配置文件内容："></a>反射方法的其他使用–通过反射运行配置文件内容：</h4><p>Student类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;is show()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件以txt文件为例子：</p>
<p>className = cn.fanshe.Student</p>
<p>methodName = show</p>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改</span></span><br><span class="line"><span class="comment"> * 我们只需要将新类发送给客户端，并修改配置文件即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//通过反射获取Class对象</span></span><br><span class="line">		Class stuClass = Class.forName(getValue(<span class="string">&quot;className&quot;</span>));<span class="comment">//&quot;cn.fanshe.Student&quot;</span></span><br><span class="line">		<span class="comment">//2获取show()方法</span></span><br><span class="line">		Method m = stuClass.getMethod(getValue(<span class="string">&quot;methodName&quot;</span>));<span class="comment">//show</span></span><br><span class="line">		<span class="comment">//3.调用show()方法</span></span><br><span class="line">		m.invoke(stuClass.getConstructor().newInstance());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//此方法接收一个key，在配置文件中获取相应的value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getValue</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">		Properties pro = <span class="keyword">new</span> Properties();<span class="comment">//获取配置文件的对象</span></span><br><span class="line">		FileReader in = <span class="keyword">new</span> FileReader(<span class="string">&quot;pro.txt&quot;</span>);<span class="comment">//获取输入流</span></span><br><span class="line">		pro.load(in);<span class="comment">//将流加载到配置文件对象中</span></span><br><span class="line">		in.close();</span><br><span class="line">		<span class="keyword">return</span> pro.getProperty(key);<span class="comment">//返回根据key获取的value值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<p>is show()</p>
<p>需求：</p>
<p>当我们升级这个系统时，不要Student类，而需要新写一个Student2的类时，这时只需要更改pro.txt的文件内容就可以了。代码就一点不用改动。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;is show2()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件更改为：</p>
<p>className = cn.fanshe.Student2</p>
<p>methodName = show2</p>
<h4 id="反射方法的其他使用–通过反射越过泛型检查："><a href="#反射方法的其他使用–通过反射越过泛型检查：" class="headerlink" title="反射方法的其他使用–通过反射越过泛型检查："></a>反射方法的其他使用–通过反射越过泛型检查：</h4><p>泛型用在编译期，编译过后泛型擦除（消失掉），所以是可以通过反射越过泛型检查的</p>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过反射越过泛型检查</span></span><br><span class="line"><span class="comment"> * 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		ArrayList&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		strList.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">		strList.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//	strList.add(100);</span></span><br><span class="line">		<span class="comment">//获取ArrayList的Class对象，反向的调用add()方法，添加数据</span></span><br><span class="line">		Class listClass = strList.getClass(); <span class="comment">//得到 strList 对象的字节码 对象</span></span><br><span class="line">		<span class="comment">//获取add()方法</span></span><br><span class="line">		Method m = listClass.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">		<span class="comment">//调用add()方法</span></span><br><span class="line">		m.invoke(strList, <span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历集合</span></span><br><span class="line">		<span class="keyword">for</span>(Object obj : strList)&#123;</span><br><span class="line">			System.out.println(obj);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<p>aaa</p>
<p>bbb</p>
<p>100</p>
<blockquote>
<p>版权声明：本文为CSDN博主「张维鹏」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
</blockquote>
<blockquote>
<p>原文链接：<a href="https://blog.csdn.net/a745233700/article/details/82893076">https://blog.csdn.net/a745233700/article/details/82893076</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>医院挂号系统知识点总结</title>
    <url>/2021/07/19/%E5%B0%9A%E5%8C%BB%E9%80%9A%E5%8C%BB%E9%99%A2%E9%A2%84%E7%BA%A6%E6%8C%82%E5%8F%B7%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>在此对尚医通在线预约挂号系统进行一个总结，以致自省。</p>
<h1 id="功能划分"><a href="#功能划分" class="headerlink" title="功能划分"></a>功能划分</h1><h2 id="一、后台管理系统"><a href="#一、后台管理系统" class="headerlink" title="一、后台管理系统"></a>一、后台管理系统</h2><h3 id="1、医院设置管理"><a href="#1、医院设置管理" class="headerlink" title="1、医院设置管理"></a>1、医院设置管理</h3><p>包括</p>
<p>​    医院设置列表显示（包括该医院的网址、医院编号、联系人、联系方式）</p>
<p>​    医院设置添加（添加新的医院设置）</p>
<p>​    进行医院锁定（锁定之后不可再进行预约）</p>
<p>​    医院设置的删除</p>
<p>​    医院列表（显示医院的名称、等级、地址）</p>
<p>​    医院详情（该医院的具体详细信息）</p>
<p>​    医院的排班情况（分科室）</p>
<p>​    医院上线、下线</p>
<h3 id="2、数据管理"><a href="#2、数据管理" class="headerlink" title="2、数据管理"></a>2、数据管理</h3><p>​    数据字典的树形显示、</p>
<p>​    数据的导入、导出功能（通过excel表格形式）</p>
<h3 id="3、用户管理"><a href="#3、用户管理" class="headerlink" title="3、用户管理"></a>3、用户管理</h3><p>​    用户列表（查看所有用户）</p>
<p>​    用户详情（查看用户名称、证件信息等）</p>
<p>​    用户锁定（违规操作锁定账号）</p>
<p>​    认证审批列表（用户注册时，需后台进行审批的列表，可查看用户信息、进行判定通过或者不通过）</p>
<h2 id="二、前台用户系统"><a href="#二、前台用户系统" class="headerlink" title="二、前台用户系统"></a>二、前台用户系统</h2><h3 id="1、首页数据显示"><a href="#1、首页数据显示" class="headerlink" title="1、首页数据显示"></a>1、首页数据显示</h3><p>​    显示下属医院、</p>
<p>​    显示所有等级和地区信息（并可根据不同等级和地区进行医院查询）</p>
<p>​    并可根据医院名称进行搜索</p>
<h3 id="2、通过显示医院进入医院的详情页面"><a href="#2、通过显示医院进入医院的详情页面" class="headerlink" title="2、通过显示医院进入医院的详情页面"></a>2、通过显示医院进入医院的详情页面</h3><p>​    查看医院详情</p>
<p>​    查看各个科室及下属部门</p>
<p>​    点击不同的科室进行挂号</p>
<h3 id="3、用户注册-登录"><a href="#3、用户注册-登录" class="headerlink" title="3、用户注册/登录"></a>3、用户注册/登录</h3><p>​    通过手机号进行注册/登录（本来是要通过整合阿里云的短信功能，但是一直申请不下来）</p>
<h3 id="4、用户的实名认证功能"><a href="#4、用户的实名认证功能" class="headerlink" title="4、用户的实名认证功能"></a>4、用户的实名认证功能</h3><p>​    挂号之前需要用户进行填写姓名和身份证，提交之后会显示认证状态，后台通过之后才可以进行挂号</p>
<h3 id="5、就诊人信息"><a href="#5、就诊人信息" class="headerlink" title="5、就诊人信息"></a>5、就诊人信息</h3><p>​    用户完成注册之后，挂号之前需要填写就诊人信息（姓名、证件类型、证件号码、性别、出生日期、手机号码），包括就诊人列表、添    加、详情、删除</p>
<h3 id="6、预约挂号功能"><a href="#6、预约挂号功能" class="headerlink" title="6、预约挂号功能"></a>6、预约挂号功能</h3><p>​    用户完成注册之后，通过进入医院界面，选择科室之后，会显示可预约的日期以及当前选择日期的可预约情况（上午、下午、主治医师信息、剩余可预约数量），选择日期和科室之后，跳转至挂号详情页面，确认挂号信息，生成挂号订单，之后可进行订单支付或者订单取消</p>
<hr>
<h1 id="前后端知识点"><a href="#前后端知识点" class="headerlink" title="前后端知识点"></a>前后端知识点</h1><h2 id="后端技术"><a href="#后端技术" class="headerlink" title="后端技术"></a>后端技术</h2><hr>
<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p>一个Spring的脚手架，快速构建Spring工程</p>
<hr>
<h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><h4 id="Nacos："><a href="#Nacos：" class="headerlink" title="Nacos："></a>Nacos：</h4><p>注册服务中心，实现不同服务之间的调用，需要在注册服务中心进行注册</p>
<h4 id="Feign："><a href="#Feign：" class="headerlink" title="Feign："></a>Feign：</h4><p>用于发现服务，从而进行调用</p>
<h4 id="Spring-Cloud-Gateway："><a href="#Spring-Cloud-Gateway：" class="headerlink" title="Spring Cloud Gateway："></a>Spring Cloud Gateway：</h4><p>通过网关根据不同的路径进行转发至不同的接口，从而调用不同的服务;网关核心功能是路由转发，因此不要有耗时操作在网关上处理，让请求快速转发到后端服务上，网关还能做统一的熔断、限流、认证、日志监控等。</p>
<h5 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h5><img src="/2021/07/19/%E5%B0%9A%E5%8C%BB%E9%80%9A%E5%8C%BB%E9%99%A2%E9%A2%84%E7%BA%A6%E6%8C%82%E5%8F%B7%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210723095501971.png" alt="image-20210723095501971" style="zoom:50%;">

<blockquote>
<p>客户端向Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。</p>
<p>Filter在<strong>“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换</strong>等，</p>
<p>在<strong>“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控</strong>等有着非常重要的作用</p>
</blockquote>
<p>gateway可参考<a href="http://www.ityouknow.com/springcloud/2018/12/12/spring-cloud-gateway-start.html">springcloud(十五)：服务网关 Spring Cloud GateWay 入门 - 纯洁的微笑博客 (ityouknow.com)</a></p>
<hr>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>一个内存数据库，基于key-value进行存储，优点是查询效率高</p>
<p>（1）作为缓存使用，将不经常变动的数据存放入redis中，如：医院信息</p>
<img src="/2021/07/19/%E5%B0%9A%E5%8C%BB%E9%80%9A%E5%8C%BB%E9%99%A2%E9%A2%84%E7%BA%A6%E6%8C%82%E5%8F%B7%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210720094940760.png" alt="redis使用1" style="zoom:50%;">

<p>（2）验证码有效时间</p>
<hr>
<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>NoSql型数据库</p>
<p>（1）将医院的基本信息、科室信息、排班信息等存储在MongoDB中，通过SpringBoot整合MongoTemplate和MongoRepository对数据库进行操作</p>
<hr>
<h3 id="EasyExcel"><a href="#EasyExcel" class="headerlink" title="EasyExcel"></a>EasyExcel</h3><p>阿里开发的一个操作Excel的工具，可对excel表格进行快速读取</p>
<hr>
<h3 id="MyBatisPlus"><a href="#MyBatisPlus" class="headerlink" title="MyBatisPlus"></a>MyBatisPlus</h3><p>本身就是对MyBatis的增强，通过该工具实现对数据库的快速操作</p>
<p>（1）接口继承IService</p>
<img src="/2021/07/19/%E5%B0%9A%E5%8C%BB%E9%80%9A%E5%8C%BB%E9%99%A2%E9%A2%84%E7%BA%A6%E6%8C%82%E5%8F%B7%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210720100130577.png" alt="MyBatisPlus使用1" style="zoom: 67%;">

<p>（2）在mapper中继承BaseMapper；BaseMapper封装了增删改查的基本操作</p>
<p><img src="/2021/07/19/%E5%B0%9A%E5%8C%BB%E9%80%9A%E5%8C%BB%E9%99%A2%E9%A2%84%E7%BA%A6%E6%8C%82%E5%8F%B7%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210720100322528.png" alt="MyBatisPlus使用2"></p>
<hr>
<h3 id="RabbitMQ（补）"><a href="#RabbitMQ（补）" class="headerlink" title="RabbitMQ（补）"></a>RabbitMQ（补）</h3><p>订单的相关操作，订单修改发送mq消息，mq消息的好处：使得项目的并发功能更加强大</p>
<hr>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>下载镜像、创建容器</p>
<p>（1）MongoDB容器的创建</p>
<p>（2）RabbitMQ容器的创建</p>
<hr>
<h3 id="swagger-ui"><a href="#swagger-ui" class="headerlink" title="swagger-ui"></a>swagger-ui</h3><p>这也是个工具，用于后端接口进行阶段性调试时使用；写好一个接口可进行功能测试。</p>
<hr>
<h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p>HttpServletRequest对象代表客户端的请求,当客户端通过http协议请求访问；服务器的时候,http请求头的所有信息都封装在这个对象中，通过这个对象，可以获取客户端请求的所有信息。</p>
<p>http请求包含请求行/状态行、请求头、请求体。</p>
<p>request如果是post才有请求体，get则没有请求体，直接跟在？后面，用&amp;隔开。</p>
<p>请求头header一般用来存放一些cookie，token信息；</p>
<p>请求体body一般用来存储post的参数和参数数据；</p>
<p>————————————————<br>版权声明：本文为CSDN博主「金麟十三少」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/u012373281/article/details/91350377">https://blog.csdn.net/u012373281/article/details/91350377</a></p>
<hr>
<h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>Json web token，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>​        由于http协议本身是一种<strong>无状态的协议</strong>，这意味着当用户使用账户和密码进行用户认证完成后并不能存在登录状态。导致下次请求依旧需要再次认证。因为服务器仅仅通过http协议，并不能知道是哪个用户发出的请求，所以需要借助一些处理机制来记录认证状态，从而完成请求和响应。</p>
<h4 id="认证方式："><a href="#认证方式：" class="headerlink" title="认证方式："></a>认证方式：</h4><h5 id="传统session认证"><a href="#传统session认证" class="headerlink" title="传统session认证"></a>传统session认证</h5><p>session认证是将用户的认证信息存储在服务器端，并且会在认证通过后将这一份认证信息传递给浏览器端，浏览器将其保存为cookie。浏览器在下次发送请求时会将该cookie携带并且发送给我们的服务器，这样我们的应用就能识别请求来自哪个用户了，这就是基于传统的session认证。</p>
<p>但是基于session认证的的应用本身很难扩展，随着不同客户端用户的增加，独立的服务器无法承载越来越多的用户，这时候session认证的问题也就暴露出来了。</p>
<p>基于session认证的常见问题<br>1）session：由于每个用户经过我们的认证服务器认证之后，都要在该认证服务器端做一次记录，通常而言该记录保存在内存中，这就导致内存占用量随着认证用户数量的增加而越来越大，==服务器的开销也会越来越大==。<br>2）扩展性：用户认证之后，服务器端将认证记录存储在内存中，这意味着该用户的下次请求还必须要请求在这台服务器上，只有这样授权才能通过。这种方式下也就限制了==负载均衡器的能力==。也就限制了应用的扩展能力。<br>3）CSRF:因为基于cookie来进行用户识别，所以当cookie被劫持，用户就很容易受到跨站请求==伪造的攻击==。</p>
<h5 id="基于token的认证"><a href="#基于token的认证" class="headerlink" title="基于token的认证"></a>基于token的认证</h5><p>认证流程：</p>
<ol>
<li><p>用户使用用户名（账户）、密码请求服务器进行登录。</p>
</li>
<li><p>服务器验证用户信息，对比用户名和密码是否存在且一致。</p>
</li>
<li><p>验证用户信息没有问题后，服务器端根据token生成的机制生成token。</p>
</li>
<li><p>服务器端返回给用户一个token。客户端（浏览器）存储token，并且每次请求时附送上这个token。</p>
</li>
<li><p>服务器端通过验证机制验证token，并且返回数据。<br>这个token在验证后每次请求时都要传递给服务器端，通过请求头传递。另外服务器要支持CORS（跨来源资源共享）策略，一般在服务端这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin：*</span><br></pre></td></tr></table></figure>

<p>版权声明：本文为CSDN博主「敬苍生」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_32609199/article/details/109569396">https://blog.csdn.net/qq_32609199/article/details/109569396</a></p>
</li>
</ol>
<h4 id="JWT结构"><a href="#JWT结构" class="headerlink" title="JWT结构"></a>JWT结构</h4><p>JWT由三段信息构成，通过 <code>.</code>链接在一起构成jwt字符串。</p>
<h5 id="header"><a href="#header" class="headerlink" title="header"></a>header</h5><p>jwt的头部承载两部分信息：</p>
<p>声明token类型，这里是jwt<br>声明token的加密方式 通常使用 HMAC SHA256等<br>完整的头部如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&#x27;typ&#x27;</span>: <span class="string">&#x27;JWT&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;alg&#x27;</span>: <span class="string">&#x27;HS256&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p> 通过对该json字符串进行BASE64压缩就得到了header部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span><br></pre></td></tr></table></figure>

<h5 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h5><p>有关实体的声明，存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p>
<p>声明有三种类型: registered, public 和 private。</p>
<ul>
<li><p>Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。</p>
<p>​        标准中注册的声明 (建议但不强制使用) ：</p>
<ul>
<li>iss: jwt签发者</li>
<li>sub: jwt所面向的用户</li>
<li>aud: 接收jwt的一方</li>
<li>exp: jwt的过期时间，这个过期时间必须要大于签发时间</li>
<li>nbf: 定义在什么时间之前，该jwt都是不可用的.</li>
<li>iat: jwt的签发时间</li>
<li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li>
</ul>
</li>
<li><p>Public claims : 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p>
</li>
<li><p>Private claims : 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p>
</li>
</ul>
<p>对该json字符串进行<code>BASE64</code>压缩就得到了第二部分。从这里可以看出<code>payload</code>完全是明文暴露的，==请不要放置一些重要信息==。<br>————————————————<br>版权声明：本文为CSDN博主「敬苍生」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_32609199/article/details/109569396">https://blog.csdn.net/qq_32609199/article/details/109569396</a></p>
<h5 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h5><p>jwt的第三部分是一个签证信息，以token的前两部分作为明文，用共同协商好的秘钥进行签名（对称签名和非对称签名）。这个签证信息由三部分组成：</p>
<ul>
<li>header (base64后的)</li>
<li>payload (base64后的)</li>
<li>secret</li>
</ul>
<p>签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。 </p>
<p>通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。</p>
<p>注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。</p>
</li>
<li><p>因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。</p>
</li>
<li><p>便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。</p>
</li>
<li><p>它不需要在服务端保存会话信息, 所以它易于应用的扩展</p>
</li>
<li><p>无状态和可扩展性：Tokens存储在客户端。完全无状态，可扩展。我们的负载均衡器可以将用户传递到任意服务器，因为在任何地方都没有状态或会话信息。</p>
</li>
<li><p>安全：Token不是Cookie。（The token, not a cookie.）每次请求的时候Token都会被发送。而且，由于没有Cookie被发送，还有助于防止CSRF攻击。即使在你的实现中将token存储到客户端的Cookie中，这个Cookie也只是一种存储机制，而非身份认证机制。没有基于会话的信息可以操作，因为我们没有会话!</p>
</li>
<li><p>过期性：token在一段时间以后会过期，这个时候用户需要重新登录。这有助于我们保持安全。还有一个概念叫token撤销，它允许我们根据相同的授权许可使特定的token甚至一组token无效。<br>————————————————</p>
<p>版权声明：本文为CSDN博主「敬苍生」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_32609199/article/details/109569396">https://blog.csdn.net/qq_32609199/article/details/109569396</a></p>
</li>
</ul>
<hr>
<h3 id="QueryWrapper的用法"><a href="#QueryWrapper的用法" class="headerlink" title="QueryWrapper的用法"></a>QueryWrapper的用法</h3><h4 id="构造器条件关系"><a href="#构造器条件关系" class="headerlink" title="构造器条件关系"></a>构造器条件关系</h4><img src="/2021/07/19/%E5%B0%9A%E5%8C%BB%E9%80%9A%E5%8C%BB%E9%99%A2%E9%A2%84%E7%BA%A6%E6%8C%82%E5%8F%B7%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210722152843270.png" alt="QueryWrapper构造器条件关系" style="zoom: 67%;">

<ol>
<li>上图绿色框为抽象类abstract</li>
<li>蓝色框为正常class类，可new对象</li>
<li>黄色箭头指向为父子类关系，箭头指向为父类</li>
</ol>
<h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><img src="/2021/07/19/%E5%B0%9A%E5%8C%BB%E9%80%9A%E5%8C%BB%E9%99%A2%E9%A2%84%E7%BA%A6%E6%8C%82%E5%8F%B7%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210722153040525.png" alt="QueryWrapper常用函数" style="zoom:67%;">

<hr>
<hr>
<hr>
<h2 id="前端技术"><a href="#前端技术" class="headerlink" title="前端技术"></a>前端技术</h2><hr>
<h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><p>一个快速构建页面的框架；指令：v-if、v-for、插值表达式</p>
<hr>
<h3 id="Element-ui"><a href="#Element-ui" class="headerlink" title="Element-ui"></a>Element-ui</h3><p>一个前端组件库，可以快速实现组件效果</p>
<hr>
<h3 id="Nuxt"><a href="#Nuxt" class="headerlink" title="Nuxt"></a>Nuxt</h3><p>一个服务端渲染技术</p>
<hr>
<h3 id="Npm"><a href="#Npm" class="headerlink" title="Npm"></a>Npm</h3><p>项目里用的最多的就是下载依赖</p>
<hr>
<hr>
<hr>
<p>我学到了什么：</p>
<p>swagger-ui这个小工具，用于调试接口很好用，可提高排错效率</p>
<hr>
<p>result：一个结果集，这个很实用，相当于对函数的返回类型进行统一，使得代码通用性更高</p>
<hr>
<p>HttpServletRequest</p>
]]></content>
      <categories>
        <category>项目Hospital</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode-无重复最长字符串</title>
    <url>/2021/06/18/leetcode-%E6%97%A0%E9%87%8D%E5%A4%8D%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<h3 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h3><p>双指针、滑动窗口</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>这个问题的解决模型是滑动窗口。同时定义两个指针，一个临时固定p1，一个不断扫描p2；当p2扫描至已包含的字符时，让p1后移，直至不包含重复字符。在此需要用到一个collection：HashSet，用于记录已扫描的字符和判断是否包含下一个字符；每次p1后移之前，记录下无重复的最大长度。</p>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> right = -<span class="number">1</span>,res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">                set.remove(s.charAt(i-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(right&lt;len-<span class="number">1</span>&amp;&amp;!set.contains(s.charAt(right+<span class="number">1</span>)))&#123;</span><br><span class="line">                set.add(s.charAt(right+<span class="number">1</span>));</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,right-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-N个数之和</title>
    <url>/2021/06/22/leetcode-N%E4%B8%AA%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h1><p>给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<h2 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h2><p>链表</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>这个题目不难，重点在于想清楚即可，还有处理好细节。</p>
<h2 id="代码入下："><a href="#代码入下：" class="headerlink" title="代码入下："></a>代码入下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode resHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode curNode = resHead;</span><br><span class="line">        <span class="keyword">int</span> plus = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>||l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = l1==<span class="keyword">null</span>?<span class="number">0</span>:l1.val;</span><br><span class="line">            <span class="keyword">int</span> num2 = l2==<span class="keyword">null</span>?<span class="number">0</span>:l2.val;</span><br><span class="line">            <span class="keyword">int</span> sum = num1+num2+plus;</span><br><span class="line">            plus = sum/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> curNum = sum%<span class="number">10</span>;</span><br><span class="line">            curNode.next = <span class="keyword">new</span> ListNode(curNum);</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(plus!=<span class="number">0</span>)&#123;</span><br><span class="line">            curNode.next = <span class="keyword">new</span> ListNode(plus);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h1><h2 id="知识点：双指针"><a href="#知识点：双指针" class="headerlink" title="知识点：双指针"></a>知识点：双指针</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><p>三个数之和为零，肯定得有负数，或者全是0，先对数组进行排序，然后开始遍历；</p>
<p>如果nums[i]&gt;0，则说明后面的数字已经全部大于0，不可能再有满足条件的数组，直接返回结果；</p>
<p>如果nums[i]+nums[left]+nums[right]=0，进行记录，并将left和right分别进行右移和左移，直到找到不重复的元素为止；</p>
<p>如果和小于0，让左指针右移；和大于0，就让右指针左移。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> resList;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> curSum = nums[i]+nums[left]+nums[right];</span><br><span class="line">                <span class="keyword">if</span>(curSum==<span class="number">0</span>)&#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                    list.add(nums[left]);</span><br><span class="line">                    list.add(nums[right]);</span><br><span class="line">                    resList.add(list);</span><br><span class="line">                    <span class="keyword">while</span> (left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>])&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right-<span class="number">1</span>])&#123;</span><br><span class="line">                        --right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curSum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="611-有效三角形的个数"><a href="#611-有效三角形的个数" class="headerlink" title="611. 有效三角形的个数"></a><a href="https://leetcode-cn.com/problems/valid-triangle-number/">611. 有效三角形的个数</a></h1><p>给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。</p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> [2,2,3,4]<br> <strong>输出:</strong> 3<br> <strong>解释:</strong><br> 有效的组合是:<br> 2,3,4 (使用第一个 2)<br> 2,3,4 (使用第二个 2)<br> 2,2,3</p>
<p><strong>注意:</strong></p>
<ol>
<li>数组长度不超过1000。</li>
<li>数组里整数的范围为     [0, 1000]。</li>
</ol>
<h2 id="知识点：二分法、双指针"><a href="#知识点：二分法、双指针" class="headerlink" title="知识点：二分法、双指针"></a>知识点：二分法、双指针</h2><h2 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h2><p>在一个数组中找出三个符合条件的数字，三重遍历肯定是少不了；可是在查找的时候可用二分法来降低复杂度。</p>
<h2 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是二分法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> left = j + <span class="number">1</span>, right = n - <span class="number">1</span>, k = j;</span><br><span class="line">                <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="comment">//此处注意，写为&lt;=，因为当left这个索引指向的元素也可能满足条件</span></span><br><span class="line">                    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (nums[mid] &lt; nums[i] + nums[j]) &#123;</span><br><span class="line">                        k = mid;</span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += k - j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是双指针:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">while</span> (k + <span class="number">1</span> &lt; n &amp;&amp; nums[k + <span class="number">1</span>] &lt; nums[i] + nums[j]) &#123;</span><br><span class="line">                    ++k;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += Math.max(k - j, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>链表、双指针、二分</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-接雨水</title>
    <url>/2021/06/23/leetcode-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></h1><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<h2 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h2><p>双指针</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>根据木桶理论，每个位置能存放的雨水数量取决于该点左右两边的最高柱子中低的那个，即找出当前位置Math.min(leftMax,rightMax),然后该值减去当前节点的高度即为可存放雨水的数量。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLeft = <span class="number">0</span>,maxRight = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//left和right为计算存水量的位置</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>,right = height.length-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;<span class="comment">//此处必须可=，最后一个存水位置也要计算</span></span><br><span class="line">            <span class="keyword">if</span>(height[left-<span class="number">1</span>]&lt;height[right+<span class="number">1</span>])&#123;<span class="comment">//这说明右侧比较高，存水得按照左侧来计算</span></span><br><span class="line">                <span class="comment">//看下左边最高能到哪个位置</span></span><br><span class="line">                maxLeft = Math.max(height[left-<span class="number">1</span>],maxLeft);</span><br><span class="line">                <span class="comment">//只有当前柱子高度小于左侧最大值时才可以存水</span></span><br><span class="line">                <span class="keyword">if</span>(height[left]&lt;maxLeft)&#123;</span><br><span class="line">                    sum+=maxLeft-height[left];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果当前这个柱子没法存水，那就考虑下一个</span></span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">//右侧同理</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxRight = Math.max(maxRight,height[right+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(maxRight&gt;height[right])&#123;</span><br><span class="line">                    sum+=maxRight-height[right];</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-逆序对相关</title>
    <url>/2021/06/25/leetcode-%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></h1><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<h2 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h2><p>利用归并排序（这个题目算是个新的知识点，可以入库）</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> resCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] tmpNums = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        merge(nums, tmpNums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> resCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums    待排数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tmpNums 辅助数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left    待排数组左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right   待排数组右边界</span></span><br><span class="line"><span class="comment">     *                将待排数组分为两段，分别调用排序函数，并将两段数组排序成为一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] tmpNums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//待排数组仅一个数字时，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将待排数组分为两段</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        merge(nums, tmpNums, left, mid);</span><br><span class="line">        merge(nums, tmpNums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums, tmpNums, left, mid,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组nums在下标left和right内进行有序排列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums    待排数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tmpNums 辅助数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left    待排左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right   待排右边界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] tmpNums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将待排元素放入辅助数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            tmpNums[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处rightIndex必须从mid+1开始，否则会出错</span></span><br><span class="line">        <span class="keyword">int</span> index = left, leftIndex = left, rightIndex = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftIndex &gt; mid) &#123;<span class="comment">//此时左侧区间元素已经全部排序完毕</span></span><br><span class="line">                nums[index] = tmpNums[rightIndex];</span><br><span class="line">                rightIndex++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightIndex &gt; right) &#123;<span class="comment">//此时右侧区间元素排序完毕</span></span><br><span class="line">                nums[index] = tmpNums[leftIndex];</span><br><span class="line">                leftIndex++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmpNums[leftIndex] &lt;= tmpNums[rightIndex]) &#123;<span class="comment">//如果左侧元素较小，就把左侧元素放入nums数组中</span></span><br><span class="line">                nums[index] = tmpNums[leftIndex];</span><br><span class="line">                leftIndex++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果右侧元素较小，就将右侧元素放入数组中</span></span><br><span class="line">                nums[index] = tmpNums[rightIndex];</span><br><span class="line">                rightIndex++;</span><br><span class="line">                <span class="comment">//此时变动逆序对个数</span></span><br><span class="line">                resCount+=mid-leftIndex+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="315-计算右侧小于当前元素的个数"><a href="#315-计算右侧小于当前元素的个数" class="headerlink" title="315. 计算右侧小于当前元素的个数"></a><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a></h1><p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。</p>
<p>示例：</p>
<p>输入：nums = [5,2,6,1]</p>
<p>输出：[2,1,1,0] </p>
<p>解释：</p>
<p>5 的右侧有 2 个更小的元素 (2 和 1)</p>
<p>2 的右侧仅有 1 个更小的元素 (1)</p>
<p>6 的右侧有 1 个更小的元素 (1)</p>
<p>1 的右侧有 0 个更小的元素</p>
<h2 id="知识点：归并排序"><a href="#知识点：归并排序" class="headerlink" title="知识点：归并排序"></a>知识点：归并排序</h2><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>这个题目和逆序基本一致，可以利用归并排序检索右侧小于当前元素的个数；需要注意的是，对局部区间进行排序之后，元素位置发生变化，会出现上次的索引和当前的索引对应的不是同一个元素的情况，故需要建立索引数组，整个排序区间对索引数组中索引的位置进行排序，即根据元素本身大小实现其索引有序；还有注意一点，在计算右侧小于当前元素个数时，为避免重复计算，需等待右侧区间元素大于左侧区间元素时，将右侧区间元素前面的元素计算个数并加入至左侧区间元素对应的结果中。</p>
<h2 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode子序列问题</title>
    <url>/2021/06/27/leetcode%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h1><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>示例 1：</p>
<p>输入：nums = [10,9,2,5,3,7,101,18]</p>
<p>输出：4</p>
<p>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p>
<p>示例 2：</p>
<p>输入：nums = [0,1,0,3,2,3]</p>
<p>输出：4</p>
<p>示例 3：</p>
<p>输入：nums = [7,7,7,7,7,7,7]</p>
<p>输出：1</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 2500</p>
<p>-104 &lt;= nums[i] &lt;= 104</p>
<p>进阶：</p>
<p>你可以设计时间复杂度为 O(n2) 的解决方案吗？</p>
<p>你能将算法的时间复杂度降低到 O(n log(n)) 吗?</p>
<h2 id="知识点：动态规划、二分查找"><a href="#知识点：动态规划、二分查找" class="headerlink" title="知识点：动态规划、二分查找"></a>知识点：动态规划、二分查找</h2><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>这个题目核心思想是：让子序列增长的慢，使得每个长度的子序列的最大值（也就是最后一个）保持当前长度的最小值（尽量小），故得到最长的递增子序列。这个<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/">题解</a>不错，仔细看看。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length,res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        d[res] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;d[res])&#123;</span><br><span class="line">                <span class="comment">//如果下一个数本身就比当前子序列最大值大，那直接加进去就行</span></span><br><span class="line">                d[++res] = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果下一个数比较小，那么我们给这个数找一个合适的位置</span></span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">1</span>,right = res,pos = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(d[mid]&lt;nums[i])&#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        left = mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        right = mid-<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos+<span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组</a></h1><p>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>请你找出符合题意的 最短 子数组，并输出它的长度。</p>
<p>示例1：</p>
<p>输入：nums = [2,6,4,8,10,9,15]</p>
<p>输出：5</p>
<p>解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</p>
<p>示例2：</p>
<p><strong>输入：</strong>nums = [1,2,3,4]<br><strong>输出：</strong>0</p>
<p>示例3：</p>
<p><strong>输入：</strong>nums = [1]<br><strong>输出：</strong>0</p>
<h2 id="知识点：双指针"><a href="#知识点：双指针" class="headerlink" title="知识点：双指针"></a>知识点：双指针</h2><h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><p>仔细想一下，这个题目的解法可从两个角度来看。</p>
<p>第一，因为对数组中的某段子序列进行排序之后，整段数组都会变为升序（也就是整段有序），那也就是说，数组的前端和尾端（如果两端都有的话）已经是有序的了，换句话说，只需要将数组进行排序，然后找到前后两端和排序后的数组相同的位置即可。</p>
<p>第二，将数组分为A、B、C三段，其中A、C段为首尾两端，B中最右侧的元素小于所有C中的元素，B中最左侧的元素大于所有A中的元素，根据这一特点，对数组进行一次遍历即可。</p>
<h2 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h2><p>题解1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            copy[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(copy);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index&lt;len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(copy[index]==nums[index])&#123;</span><br><span class="line">                index++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index==len)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index = len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(copy[index]==nums[index])&#123;</span><br><span class="line">                --index;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len-count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>题解2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> maxn = Integer.MIN_VALUE, right = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> minn = Integer.MAX_VALUE, left = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxn &gt; nums[i]) &#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxn = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minn &lt; nums[n - i - <span class="number">1</span>]) &#123;</span><br><span class="line">                left = n - i - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                minn = nums[n - i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right == -<span class="number">1</span> ? <span class="number">0</span> : right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<hr>
<h1 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035. 不相交的线"></a><a href="https://leetcode-cn.com/problems/uncrossed-lines/">1035. 不相交的线</a></h1><p>在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。</p>
<p>现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：</p>
<p> nums1[i] == nums2[j]</p>
<p>且绘制的直线不与任何其他连线（非水平线）相交。</p>
<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>
<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>
<img src="/2021/06/27/leetcode%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/Users\Mithrandir\AppData\Roaming\Typora\typora-user-images\image-20210727101312923.png" alt="1035—不相交的线" style="zoom: 67%;">

<h2 id="知识点：dp"><a href="#知识点：dp" class="headerlink" title="知识点：dp"></a>知识点：dp</h2><h2 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h2><p>求最长公共子序列，代码都不用改。</p>
<h2 id="代码如下：-2"><a href="#代码如下：-2" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = nums1.length,len2 = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">1</span>;j&lt;=len2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i-<span class="number">1</span>]==nums2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143.最长公共子序列</a></h1><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<p>示例 1：</p>
<p>输入：text1 = “abcde”, text2 = “ace” 输出：3 解释：最长公共子序列是 “ace” ，它的长度为 3 。</p>
<h2 id="知识点：dp、数组"><a href="#知识点：dp、数组" class="headerlink" title="知识点：dp、数组"></a>知识点：dp、数组</h2><h2 id="分析：-3"><a href="#分析：-3" class="headerlink" title="分析："></a>分析：</h2><p>这个解法我没看太明白。</p>
<p>二维动态规划，双层for循环，外层遍历text1，内层遍历text2。贴个题解<a href="https://leetcode-cn.com/problems/longest-common-subsequence/solution/fu-xue-ming-zhu-er-wei-dong-tai-gui-hua-r5ez6/">二维动态规划的常规套路</a>，讲的不赖。</p>
<p>1.状态定义：</p>
<p>比如对于本题而言，可以定义 dp<a href="http://">i</a> 表示 text1[0:i-1] 和 text2[0:j-1] 的最长公共子序列。 （注：text1[0:i-1] 表示的是 text1 的 第 0 个元素到第 i - 1 个元素，两端都包含） 之所以 dp<a href="http://">i</a> 的定义不是 text1[0:i] 和 text2[0:j] ，是为了方便当 i = 0 或者 j = 0 的时候，dp<a href="http://">i</a>表示的为空字符串和另外一个字符串的匹配，这样 dp<a href="http://">i</a> 可以初始化为 0.</p>
<p>2.状态转移方程</p>
<p>知道状态定义之后，开始写状态转移方程。</p>
<p>当 text1[i - 1] == text2[j - 1] 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 1，所以 dp<a href="http://">i</a> = dp<a href="http://">i - 1</a> + 1；举个例子，比如对于 ac 和 bc 而言，他们的最长公共子序列的长度等于 a 和 b 的最长公共子序列长度 0 + 1 = 1。 当 text1[i - 1] != text2[j - 1] 时，说明两个子字符串的最后一位不相等，那么此时的状态 dp<a href="http://">i</a> 应该是 dp<a href="http://">i - 1</a> 和 dp<a href="http://">i</a> 的最大值。举个例子，比如对于 ace 和 bc 而言，他们的最长公共子序列的长度等于 ① ace 和 b 的最长公共子序列长度0 与 ② ac 和 bc 的最长公共子序列长度1 的最大值，即 1。 综上状态转移方程为：</p>
<p>dp<a href="http://">i</a> = dp<a href="http://">i - 1</a> + 1dp<a href="http://">i</a>=dp<a href="http://">i−1</a>+1, 当 text1[i - 1] == text2[j - 1];text1[i−1]==text2[j−1]; dp<a href="http://">i</a> = max(dp<a href="http://">i - 1</a>, dp<a href="http://">i</a>)dp<a href="http://">i</a>=max(dp<a href="http://">i−1</a>,dp<a href="http://">i</a>), 当 text1[i - 1] != text2[j - 1]text1[i−1]!=text2[j−1]</p>
<p>3.状态初始化</p>
<p>初始化就是要看当 i = 0 与 j = 0 时， dp<a href="http://">i</a> 应该取值为多少。</p>
<p>当 i = 0 时，dp<a href="http://">0</a> 表示的是 text1中取空字符串跟 text2 的最长公共子序列，结果肯定为 0. 当 j = 0 时，dp<a href="http://">i</a> 表示的是 text2text2 中取空字符串 跟 text1text1 的最长公共子序列，结果肯定为 0. 综上，当 i = 0 或者 j = 0 时，dp<a href="http://">i</a> 初始化为 0.</p>
<h2 id="代码如下：-3"><a href="#代码如下：-3" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] array1 = text1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] array2 = text2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len1 = array1.length,len2 = array2.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=len2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array1[i-<span class="number">1</span>]==array2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="1713-得到子序列的最少操作次数"><a href="#1713-得到子序列的最少操作次数" class="headerlink" title="1713. 得到子序列的最少操作次数"></a><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/">1713. 得到子序列的最少操作次数</a></h1><p>给你一个数组 target ，包含若干 互不相同 的整数，以及另一个整数数组 arr ，arr 可能 包含重复元素。</p>
<p>每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = [1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2] 。你可以在数组最开始或最后面添加整数。</p>
<p>请你返回 最少 操作次数，使得 target 成为 arr 的一个子序列。</p>
<p>一个数组的子序列指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。</p>
<p>示例 1：</p>
<p> 输入：target = [5,1,3], arr = [9,4,2,3,4]</p>
<p>输出：2</p>
<p>解释：你可以添加 5 和 1 ，使得 arr 变为 [5,9,4,1,2,3,4] ，target 为 arr 的子序列。</p>
<p>示例 2：</p>
<p>输入：target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]</p>
<p>输出：3 </p>
<p>提示：</p>
<p>1 &lt;= target.length, arr.length &lt;= 105</p>
<p>1 &lt;= target[i], arr[i] &lt;= 109</p>
<p>target 不包含任何重复元素。</p>
<h2 id="知识点：贪心、二分查找"><a href="#知识点：贪心、二分查找" class="headerlink" title="知识点：贪心、二分查找"></a>知识点：贪心、二分查找</h2><h2 id="分析：-4"><a href="#分析：-4" class="headerlink" title="分析："></a>分析：</h2><p>这个<a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/solution/de-dao-zi-xu-lie-de-zui-shao-cao-zuo-ci-hefgl/">题解</a>讲的比较好，我没什么好补充的。</p>
<h2 id="代码如下：-4"><a href="#代码如下：-4" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最少操作数=target.length-arr中已存在的target子序列最大长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="keyword">int</span>[] target, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = target.length;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            map.put(target[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">                <span class="keyword">int</span> index = map.get(num);</span><br><span class="line">                <span class="keyword">int</span> pos = binarySearch(list,index);</span><br><span class="line">                <span class="keyword">if</span>(pos!=list.size())&#123;</span><br><span class="line">                    list.set(pos,index);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    list.add(index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len-list.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过二分查找，将当前遍历到的较小的数字放置合适的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;Integer&gt; list,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>||list.get(size-<span class="number">1</span>)&lt;target)&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = size-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right-left)/<span class="number">2</span>+left;</span><br><span class="line">            <span class="keyword">if</span>(list.get(mid)&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h1><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<p>示例 1：</p>
<p>输入：s = “bbbab”</p>
<p>输出：4</p>
<p>解释：一个可能的最长回文子序列为 “bbbb” 。</p>
<p>示例 2：</p>
<p>输入：s = “cbbd”</p>
<p>输出：2</p>
<p>解释：一个可能的最长回文子序列为 “bb” 。</p>
<p><strong>提示：</strong></p>
<ul>
<li>1     &lt;= s.length &lt;= 1000</li>
<li>s 仅由小写英文字母组成</li>
</ul>
<h2 id="知识点：动态规划"><a href="#知识点：动态规划" class="headerlink" title="知识点：动态规划"></a>知识点：动态规划</h2><h2 id="分析：-5"><a href="#分析：-5" class="headerlink" title="分析："></a>分析：</h2><p>这种问题都可以分解为一个个子问题；既然是回文，那去掉首尾两个字符之后必定还是回文，以dp[i][j]表示以i、j为首尾下标的数组中的最长回文子序列长度，那么动态转移方程dp[i][j]就有两种情况，一种是i位置的字符和j位置的字符不相等，此时dp[i][j]=max（dp[i+1][j],dp[i][j-1]）；另一种是相等dp[i][j] = dp[i+1][j-1]+2;</p>
<p>还要注意的一点就是遍历顺序，由于dp[i][j]的取值取决于dp[i+1][j-1]，所以i必定要从末尾开始，进行降序遍历；j必定要从i+1开始，进行升序遍历。</p>
<h2 id="代码如下：-5"><a href="#代码如下：-5" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> c1 = s.charAt(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> c2 = s.charAt(j);</span><br><span class="line">                <span class="keyword">if</span>(c1==c2)&#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>动态规划、二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-股票问题</title>
    <url>/2021/06/21/leetcode-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<h2 id="知识点：动态规划"><a href="#知识点：动态规划" class="headerlink" title="知识点：动态规划"></a>知识点：动态规划</h2><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>其实这个题的本质就是求出两者之差，先找到一个值i，只要后面有比i大的，就记录下差值；不断将i往小处更新，不断比较差值。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE,res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将min不断更新为较小值，只要超过min，便计算是否可取的更大利润并记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&lt;min)&#123;</span><br><span class="line">                min = prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = Math.max(res,prices[i]-min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h2 id="知识点：动态规划-1"><a href="#知识点：动态规划-1" class="headerlink" title="知识点：动态规划"></a>知识点：动态规划</h2><h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><p>想一下，多笔交易且必须卖出去之后再买进，也就是说，当前状态只有两种：持有股票、未持有股票。</p>
<p>持有股票：要么卖出去，要么什么都不做</p>
<p>未持有：要么买进，要么什么都不做</p>
<p>到最后一天的时候，肯定是不持有股票利润更高，做一个dp数组，用0和1分别表示未持有和持有，详情见代码。</p>
<p>一般来说，对于动态规划都会有空间方面的优化。</p>
<h2 id="代码如下-："><a href="#代码如下-：" class="headerlink" title="代码如下 ："></a>代码如下 ：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LC0122_best_time_to_buy_and_sell_stock_II;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimeToBuyAndSellStockII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][len];</span><br><span class="line">        <span class="comment">//dp均为当天交易完后的利润</span></span><br><span class="line">        <span class="comment">//在第0天未持有股票利润</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//在第0天持有股票的利润</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="comment">//第i天没持有股票，要么是前一天有，卖了；要么是昨天也没</span></span><br><span class="line">            dp[<span class="number">0</span>][i] = Math.max(dp[<span class="number">1</span>][i-<span class="number">1</span>]+prices[i],dp[<span class="number">0</span>][i-<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//第i天持有股票，今天刚买，或者昨天就有，没卖</span></span><br><span class="line">            dp[<span class="number">1</span>][i] = Math.max(dp[<span class="number">1</span>][i-<span class="number">1</span>],dp[<span class="number">0</span>][i-<span class="number">1</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对上述dp代码进行空间优化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">int</span> hold = -prices[<span class="number">0</span>],unhold = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmpHold = hold,tmpUnhold = unhold;</span><br><span class="line">            hold = Math.max(tmpHold,tmpUnhold-prices[i]);</span><br><span class="line">            unhold = Math.max(tmpUnhold,tmpHold+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unhold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h1><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h2 id="知识点：动态规划-2"><a href="#知识点：动态规划-2" class="headerlink" title="知识点：动态规划"></a>知识点：动态规划</h2><h2 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h2><p>只能交易两次，也就是挣两个差值，最后一天结束的时候，有五种情况：</p>
<ul>
<li>一次交易都没有</li>
<li>只买进了一次</li>
<li>买一次，卖一次，即完成一次交易</li>
<li>交易一次，买第二次</li>
<li>交易两次。</li>
</ul>
<p>第一种为0，不必理会。以下四种的利润分别记为不用buy1，sell1，buy2，sell2。详情见代码</p>
<h2 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> buy1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sell1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy2 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sell2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            buy1 = Math.max(buy1,-prices[i]);</span><br><span class="line">            sell1 = Math.max(sell1,buy1+prices[i]);</span><br><span class="line">            buy2 = Math.max(buy2,sell1-prices[i]);</span><br><span class="line">            sell2 = Math.max(sell2,buy2+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h1><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h2 id="知识点：数组、动态规划"><a href="#知识点：数组、动态规划" class="headerlink" title="知识点：数组、动态规划"></a>知识点：数组、动态规划</h2><h2 id="分析：-3"><a href="#分析：-3" class="headerlink" title="分析："></a>分析：</h2><p>这个其实也就是个变形，有点不太好理解，你就这么记吧；[题解](<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iv-by-8xtkp/">买卖股票的最佳时机 IV - 买卖股票的最佳时机 IV - 力扣（LeetCode） (leetcode-cn.com)</a>)</p>
<h2 id="代码如下：-2"><a href="#代码如下：-2" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        k = Math.min(k, len / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//手上持有股票的利润</span></span><br><span class="line">        <span class="keyword">int</span>[] buy = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="comment">//手上未持有股票的利润</span></span><br><span class="line">        <span class="keyword">int</span>[] sell = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            buy[i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已经完成第i笔交易，第j天</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">                buy[j] = Math.max((j==<span class="number">0</span>?<span class="number">0</span>:sell[j-<span class="number">1</span>])-prices[i],buy[j]);</span><br><span class="line">                sell[j] = Math.max(buy[j]+prices[i],sell[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[k-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h1><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<h2 id="知识点：动态规划、数组"><a href="#知识点：动态规划、数组" class="headerlink" title="知识点：动态规划、数组"></a><strong>知识点：动态规划、数组</strong></h2><h2 id="分析：-4"><a href="#分析：-4" class="headerlink" title="分析："></a><strong>分析：</strong></h2><p>和II最为相似，只是加了个手续费而已。</p>
<h2 id="代码如下：-3"><a href="#代码如下：-3" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hold = -prices[<span class="number">0</span>],unhold = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmpHold = hold,tmpUnhold = unhold;</span><br><span class="line">            hold = Math.max(tmpHold,tmpUnhold-prices[i]);</span><br><span class="line">            unhold = Math.max(tmpUnhold,tmpHold+prices[i]-fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unhold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h1><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p>
<h2 id="知识点：动态规划-3"><a href="#知识点：动态规划-3" class="headerlink" title="**知识点：动态规划"></a>**知识点：动态规划</h2><h2 id="分析：-5"><a href="#分析：-5" class="headerlink" title="分析："></a><strong>分析：</strong></h2><p>算下来，当前的状态就三种，一种是持有股票（当然不在冷冻期）；一种是未持有（在冷冻期）；还有一种未持有（不在冷冻期），详情见代码。</p>
<h2 id="代码如下：-4"><a href="#代码如下：-4" class="headerlink" title="代码如下："></a><strong>代码如下：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前持有股票</span></span><br><span class="line">        <span class="keyword">int</span> hold = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//当前不持有股票</span></span><br><span class="line">        <span class="keyword">int</span> unhold = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前在冷冻期</span></span><br><span class="line">        <span class="keyword">int</span> cold = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmpHold = hold;</span><br><span class="line">            <span class="keyword">int</span> tmpUnhold = unhold;</span><br><span class="line">            <span class="keyword">int</span> tmpCold = cold;</span><br><span class="line">            <span class="comment">//今天持有，那说明要么是昨天就有；要么昨天冷冻期，今天又买的</span></span><br><span class="line">            hold = Math.max(tmpHold,tmpCold-prices[i]);</span><br><span class="line">            <span class="comment">//今天未持有：要么昨天就没；要么昨天持有今天卖了</span></span><br><span class="line">            unhold = Math.max(tmpUnhold,tmpHold+prices[i]);</span><br><span class="line">            <span class="comment">//今天冷冻期：必定昨天卖了</span></span><br><span class="line">            cold = tmpUnhold;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(unhold,cold),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-进制相关</title>
    <url>/2021/06/20/leetcode-%E8%BF%9B%E5%88%B6%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="171-Excel表列序号"><a href="#171-Excel表列序号" class="headerlink" title="171. Excel表列序号"></a><a href="https://leetcode-cn.com/problems/excel-sheet-column-number/">171. Excel表列序号</a></h1><p>给定一个Excel表格中的列名称，返回其相应的列序号。</p>
<p>例如，</p>
<p>  A -&gt; 1</p>
<p>  B -&gt; 2</p>
<p>  C -&gt; 3</p>
<p>  …</p>
<p>  Z -&gt; 26</p>
<p>  AA -&gt; 27</p>
<p>  AB -&gt; 28 </p>
<p>  …</p>
<p>示例 1:</p>
<p>输入: “A”</p>
<p>输出: 1</p>
<p>示例 2:</p>
<p>输入: “AB”</p>
<p>输出: 28</p>
<p>示例 3:</p>
<p>输入: “ZY”</p>
<p>输出: 701</p>
<h2 id="知识点：进制相关"><a href="#知识点：进制相关" class="headerlink" title="知识点：进制相关"></a>知识点：进制相关</h2><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>这本质上是个26进制题目，将26进制转为10进制。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String columnTitle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>,multiple = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=columnTitle.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> curNumber = columnTitle.charAt(i)-<span class="string">&#x27;A&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">            sum += curNumber*multiple;</span><br><span class="line">            multiple *= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="168-Excel表列名称"><a href="#168-Excel表列名称" class="headerlink" title="168. Excel表列名称"></a><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/">168. Excel表列名称</a></h1><p>给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。</p>
<p>例如：</p>
<p>A -&gt; 1</p>
<p>B -&gt; 2</p>
<p>C -&gt; 3</p>
<p>…</p>
<p>Z -&gt; 26</p>
<p>AA -&gt; 27</p>
<p>AB -&gt; 28 </p>
<p>…</p>
<p>示例 1：</p>
<p>输入：columnNumber = 1</p>
<p>输出：”A”</p>
<p>示例 2：</p>
<p>输入：columnNumber = 28</p>
<p>输出：”AB”</p>
<p>示例 3：</p>
<p>输入：columnNumber = 701</p>
<p>输出：”ZY”</p>
<p>示例 4：</p>
<p>输入：columnNumber = 2147483647</p>
<p>输出：”FXSHRXW”</p>
<p>提示：</p>
<p>1 &lt;= columnNumber &lt;= 231 - 1</p>
<h2 id="知识点：进制问题"><a href="#知识点：进制问题" class="headerlink" title="知识点：进制问题"></a>知识点：进制问题</h2><h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><p>A是从1开始的，所以当数字是1时，没法直接让它+‘A’来对应字符，必须先减1。</p>
<h2 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(columnNumber&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            columnNumber--;</span><br><span class="line">            sb.append((<span class="keyword">char</span>)(<span class="string">&#x27;A&#x27;</span>+columnNumber%<span class="number">26</span>));</span><br><span class="line">            columnNumber /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>进制问题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-K字之谜</title>
    <url>/2021/06/07/leetcode-K%E5%AD%97%E4%B9%8B%E8%B0%9C/</url>
    <content><![CDATA[<h1 id="1337-矩阵中战斗力最弱的-K-行"><a href="#1337-矩阵中战斗力最弱的-K-行" class="headerlink" title="1337. 矩阵中战斗力最弱的 K 行"></a><a href="https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/">1337. 矩阵中战斗力最弱的 K 行</a></h1><p>给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。</p>
<p>请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。</p>
<p>如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。</p>
<p>军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：mat = </span><br><span class="line">[[1,1,0,0,0],</span><br><span class="line"> [1,1,1,1,0],</span><br><span class="line"> [1,0,0,0,0],</span><br><span class="line"> [1,1,0,0,0],</span><br><span class="line"> [1,1,1,1,1]], </span><br><span class="line">k = 3</span><br><span class="line">输出：[2,0,3]</span><br><span class="line">解释：</span><br><span class="line">每行中的军人数目：</span><br><span class="line">行 0 -&gt; 2 </span><br><span class="line">行 1 -&gt; 4 </span><br><span class="line">行 2 -&gt; 1 </span><br><span class="line">行 3 -&gt; 2 </span><br><span class="line">行 4 -&gt; 5 </span><br><span class="line">从最弱到最强对这些行排序后得到 [2,0,3,1,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：mat = </span><br><span class="line">[[1,0,0,0],</span><br><span class="line"> [1,1,1,1],</span><br><span class="line"> [1,0,0,0],</span><br><span class="line"> [1,0,0,0]], </span><br><span class="line">k = 2</span><br><span class="line">输出：[0,2]</span><br><span class="line">解释： </span><br><span class="line">每行中的军人数目：</span><br><span class="line">行 0 -&gt; 1 </span><br><span class="line">行 1 -&gt; 4 </span><br><span class="line">行 2 -&gt; 1 </span><br><span class="line">行 3 -&gt; 1 </span><br><span class="line">从最弱到最强对这些行排序后得到 [0,2,3,1]</span><br></pre></td></tr></table></figure>

<h2 id="知识点：二分查找、堆排序"><a href="#知识点：二分查找、堆排序" class="headerlink" title="知识点：二分查找、堆排序"></a>知识点：二分查找、堆排序</h2><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>这个题目的解决分为两步：找出每一行1的个数；按每行1的个数、行的索引进行排序。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] kWeakestRows(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = mat.length,n = mat[<span class="number">0</span>].length;</span><br><span class="line">        ArrayList&lt;<span class="keyword">int</span>[]&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>,right = n-<span class="number">1</span>,pos = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][mid]==<span class="number">0</span>)&#123;</span><br><span class="line">                    right = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pos = mid;</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            lists.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;pos+<span class="number">1</span>,i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(lists, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1[<span class="number">0</span>]!=o2[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> o1[<span class="number">0</span>]-o2[<span class="number">0</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            res[i] = lists.get(i)[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：我这里采用了普通排序，[题解](<a href="https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/solution/fang-zhen-zhong-zhan-dou-li-zui-ruo-de-k-xing-by-l/">矩阵中战斗力最弱的 K 行 - 矩阵中战斗力最弱的 K 行 - 力扣（LeetCode） (leetcode-cn.com)</a>)里采用的是小顶堆，忘记的话可以看下。</p>
<hr>
<hr>
<h1 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h1><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>示例 1:</p>
<p>输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 </p>
<p>示例 2:</p>
<p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4</p>
<p><strong>知识点：堆、快排</strong></p>
<p><strong>分析：</strong></p>
<p>可以维护一个大顶堆，删除k次最大元素，每次删除元素之后就重新调整堆内的数据位置，此时就是第K大的元素；这里简单创建并维护一个大顶堆。</p>
<p><strong>代码入下：（堆排序法）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LC0215_kth_largest_element_in_an_array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthLargestElementInAnArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//建立大顶堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            priorityQueue.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            priorityQueue.poll();</span><br><span class="line">            --k;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = priorityQueue.peek();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了直接用PriorityQueue之外，也得知道是怎么建立大顶堆的（小顶堆同理）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="comment">//创建一个大顶堆，len为堆的大小</span></span><br><span class="line">        buildHeap(nums,len);</span><br><span class="line">        <span class="comment">//要找到第k大的元素，需要剔除k-1个数据，也就是执行k-1次，所有i&gt;=nums.length-1-（k-2）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=nums.length-k+<span class="number">1</span>;--i)&#123;</span><br><span class="line">            <span class="comment">//将最小的元素同最大的元素</span></span><br><span class="line">            swap(nums,<span class="number">0</span>,i);</span><br><span class="line">            --len;</span><br><span class="line">            <span class="comment">//每次消除元素之后，重新调整堆</span></span><br><span class="line">            maxHeapify(nums,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//此处i为堆中最靠后的一个有子树的节点，依次向上调整所有带有子树的节点</span></span><br><span class="line">            maxHeapify(nums,i,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="comment">//left为i的左子树，right为i的右子树</span></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">2</span>*i+<span class="number">1</span>,right=<span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//默认i为当前小子树中的最大值</span></span><br><span class="line">        <span class="keyword">int</span> largest=i;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;size&amp;&amp;nums[left]&gt;nums[largest])&#123;</span><br><span class="line">            largest=left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;size&amp;&amp;nums[right]&gt;nums[largest])&#123;</span><br><span class="line">            largest=right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(largest!=i)&#123;<span class="comment">//确保i位置的值为当前小子树的中的最大值</span></span><br><span class="line">            swap(nums,i,largest);</span><br><span class="line">            maxHeapify(nums,largest,size);<span class="comment">//并调整下更换过位置的子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个题目还有个解法，可以用快排的思想来解决：我们找到一个数组内的随机数，然后将其放置在合适的位置，如果这个位置刚好是我们求的位置，那就直接返回这个数字即可。</p>
<h2 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解法二：快排</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,nums.length-k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = randomPartition(nums,left,right);</span><br><span class="line">        <span class="keyword">if</span>(q==index)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[q];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> q&lt;index?quickSelect(nums, q+<span class="number">1</span>, right, index):quickSelect(nums, left, q-<span class="number">1</span>, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在left和right之间随机一个位置，并将该位置的数字放置合适的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randomPartition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> randomIndex = random.nextInt(right-left+<span class="number">1</span>)+left;</span><br><span class="line">        swap(nums,randomIndex,right);</span><br><span class="line">        <span class="keyword">int</span> x = nums[right],curIndex = left-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;x)&#123;</span><br><span class="line">                swap(nums,++curIndex,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,curIndex+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> curIndex+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负责交换指定的两个位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h1><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>示例 1:</p>
<p>输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] </p>
<p>示例 2:</p>
<p>输入: nums = [1], k = 1 输出: [1]</p>
<h2 id="知识点：堆"><a href="#知识点：堆" class="headerlink" title="知识点：堆"></a><strong>知识点：堆</strong></h2><h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a><strong>分析：</strong></h2><p>只要是查找前k个元素，首先考虑堆结构的使用；以下用的是java自带的堆结构，请多练习并熟悉操作。</p>
<h2 id="代码如下：-2"><a href="#代码如下：-2" class="headerlink" title="代码如下："></a><strong>代码如下：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建一个map，map的k为元素值，v为元素出现的频率</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个小顶堆，注意comparator的使用，是确保前k大还是前k小的关键</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> map.get(o1)-map.get(o2);<span class="comment">//按value从小到大排序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//维持一个数量为k的小顶堆</span></span><br><span class="line">        <span class="comment">//此处解释下为什么是小顶堆</span></span><br><span class="line">        <span class="comment">//我们要找的是前k大的元素，听上去，应该建立一个容量为k的大顶堆；</span></span><br><span class="line">        <span class="comment">//但是，hash集合的key是元素，value是频率，无法根据value找到key</span></span><br><span class="line">        <span class="comment">//故，建立一个小顶堆，每次替换堆顶的那个元素（也就是频率最低的元素）</span></span><br><span class="line">        <span class="comment">//当遍历完所有的元素时，堆里的所有元素即是所求</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key :map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size()&lt;k)&#123;</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(map.get(key)&gt;map.get(pq.peek()))&#123;<span class="comment">//如果map里的值大于当前堆顶值，就替换这个堆顶</span></span><br><span class="line">                pq.remove();</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出小顶堆中的所有元素</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[pq.size()];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            res[i++]=(pq.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>堆排序、快排、二分</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-网络延迟时间</title>
    <url>/2021/08/02/leetcode-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h1 id="743-网络延迟时间有-n-个网络节点，标记为-1-到-n。"><a href="#743-网络延迟时间有-n-个网络节点，标记为-1-到-n。" class="headerlink" title="743. 网络延迟时间有 n 个网络节点，标记为 1 到 n。"></a><a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a>有 n 个网络节点，标记为 1 到 n。</h1><p>给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。</p>
<p>现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。</p>
<p>示例1：</p>
<img src="/2021/08/02/leetcode-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/Users\Mithrandir\AppData\Roaming\Typora\typora-user-images\image-20210802101619285.png" alt="image-20210802101619285" style="zoom:50%;">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：times = [[1,2,1]], n = 2, k = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<h2 id="知识点：图"><a href="#知识点：图" class="headerlink" title="知识点：图"></a>知识点：图</h2><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>从k节点开始，找到遍历至其他所有节点的最短路径；可利用贪心思想，定义一个距离数组，将到达每个节点的最短路径放入，然后取出最大值即可。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] g = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            Arrays.fill(g[i],INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] t:times)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = t[<span class="number">0</span>]-<span class="number">1</span>,y = t[<span class="number">1</span>]-<span class="number">1</span>;</span><br><span class="line">            g[x][y] = t[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dist,INF);</span><br><span class="line">        dist[k-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;n;++y)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!used[y]&amp;&amp;(x==-<span class="number">1</span>||dist[y]&lt;dist[x]))&#123;</span><br><span class="line">                    x=y;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            used[x] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;n;++y)&#123;</span><br><span class="line">                dist[y] = Math.min(dist[y],dist[x]+g[x][y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Arrays.stream(dist).max().getAsInt();</span><br><span class="line">        <span class="keyword">return</span> ans==INF?-<span class="number">1</span>:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6语法</title>
    <url>/2021/06/16/ES6%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var是全局变量，let是局部变量</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//var可对一变量进行多次定义，let对同一变量尽可定义一次</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p>常量定义时，声明时必须进行初始化；一旦声明不可更改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const  A = 10;</span><br><span class="line">        console.log(A) //10</span><br><span class="line"></span><br><span class="line">        const B = &quot;你好，ES&quot; //你好，ES</span><br><span class="line">        console.log(B)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        //解构赋值</span><br><span class="line">        let a = 1,b = 2, c = 3</span><br><span class="line">        console.log(a,b,c)</span><br><span class="line"></span><br><span class="line">        //ES6可写法如下</span><br><span class="line">        let[x,y,z] = [1,2,3]</span><br><span class="line">        console.log(x,y,z) </span><br><span class="line"></span><br><span class="line">		//对象解构(常用)</span><br><span class="line">        let user = &#123;name:&#x27;Helen&#x27;,age:18&#125;</span><br><span class="line">        //传统方式</span><br><span class="line">        let name1 = user.name</span><br><span class="line">        let age1 = user.age</span><br><span class="line">        console.log(name1,age1)</span><br><span class="line"></span><br><span class="line">        //ES6</span><br><span class="line">        let&#123;name,age&#125; = user</span><br><span class="line">        console.log(name,age)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串可对定义的变量进行通过$进行引用，并进行简单的运算，以及在输出时进行换行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        let name = &quot;Luna&quot;</span><br><span class="line">        let age = 19</span><br><span class="line">        </span><br><span class="line">        let info  = `My name is $&#123;name&#125; and </span><br><span class="line">        I am $&#123;age+1&#125; years old next year.`</span><br><span class="line">        console.log(info)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const name = &quot;Alex&quot;,age = 20</span><br><span class="line">        //传统写法</span><br><span class="line">        // const user = &#123;name:name,age:age&#125;</span><br><span class="line">        // console.log(user)</span><br><span class="line"></span><br><span class="line">        //ES6</span><br><span class="line">        const user = &#123;name,age&#125;</span><br><span class="line">        //要想这样写，变量名称必须一致</span><br><span class="line">        console.log(user)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="对象拓展运算符"><a href="#对象拓展运算符" class="headerlink" title="对象拓展运算符"></a>对象拓展运算符</h2><p>主要用于对象的复制和对象的合并</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        //对象复制</span><br><span class="line">        let person = &#123;name:&quot;Alex&quot;,age:38&#125;</span><br><span class="line">        //通过...可对指定对象内所有属性进行遍历并进行赋值给当前对象</span><br><span class="line">        let someone = &#123;...person&#125;</span><br><span class="line">        console.log(someone)</span><br><span class="line"></span><br><span class="line">		//对象合并</span><br><span class="line">        let name1 = &#123;name:&quot;Hony&quot;&#125;,age1 = &#123;age:40&#125;</span><br><span class="line">        let someother = &#123;...name1,...age1&#125;</span><br><span class="line">        console.log(someother)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        //传统方式定义函数</span><br><span class="line">        var f1 = function(a) &#123;</span><br><span class="line">            return a+1</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(f1(4))</span><br><span class="line">        </span><br><span class="line">        //箭头函数</span><br><span class="line">        //单个参数时，可省略（）</span><br><span class="line">        var f2 = (a) =&gt; 2*a</span><br><span class="line">        console.log(f2(2))</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HelloWorld系列</category>
      </categories>
  </entry>
  <entry>
    <title>StackOverFlow和OutOfMemory对比</title>
    <url>/2021/07/24/StackOverFlow%E5%92%8COutOfMemory%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数（设置本地方法栈大小）虽然存在，但实际上是没有任何效果的，栈容量只能由-Xss参数来设定。关于虚拟机栈和本地方法栈，在《Java虚拟机规范》中描述了两种异常：</p>
<p>  1)如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</p>
<p>  2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出DutOfMemory Error异常。</p>
<p>  《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机的选择是不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。</p>
<p>Java堆溢出：</p>
<p>只要不断的创建对象，达到最大堆容量限制之后就会抛出OOM异常；</p>
<p>虚拟机栈和本地方法栈溢出：</p>
<p>不断创建线程，会导致OOM异常</p>
<p>方法区溢出：</p>
<p>通过String::inner()这个本地方法，不断添加对象，将导致OOM异常</p>
]]></content>
      <categories>
        <category>JVM相关</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>HappenBefore原则</title>
    <url>/2021/07/20/HappenBefore%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h2 id="定义了哪些指令不能重排："><a href="#定义了哪些指令不能重排：" class="headerlink" title="定义了哪些指令不能重排："></a>定义了哪些指令不能重排：</h2><h3 id="单线程的happen-before原则"><a href="#单线程的happen-before原则" class="headerlink" title="单线程的happen before原则"></a>单线程的happen before原则</h3><p>写在前面的操作happen before后面的操作</p>
<h3 id="锁的happen-before原则："><a href="#锁的happen-before原则：" class="headerlink" title="锁的happen-before原则："></a>锁的happen-before原则：</h3><p>同一个锁的unlock操作happen-before此锁的lock操作。</p>
<h3 id="volatile的happen-before原则："><a href="#volatile的happen-before原则：" class="headerlink" title="volatile的happen-before原则："></a>volatile的happen-before原则：</h3><p>对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。</p>
<h3 id="happen-before的传递性原则："><a href="#happen-before的传递性原则：" class="headerlink" title="happen-before的传递性原则："></a>happen-before的传递性原则：</h3><p>如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。</p>
<h3 id="线程启动的happen-before原则："><a href="#线程启动的happen-before原则：" class="headerlink" title="线程启动的happen-before原则："></a>线程启动的happen-before原则：</h3><p>同一个线程的start方法happen-before此线程的其它方法。</p>
<h3 id="线程中断的happen-before原则："><a href="#线程中断的happen-before原则：" class="headerlink" title="线程中断的happen-before原则："></a>线程中断的happen-before原则：</h3><p>对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。</p>
<h3 id="线程终结的happen-before原则："><a href="#线程终结的happen-before原则：" class="headerlink" title="线程终结的happen-before原则："></a>线程终结的happen-before原则：</h3><p>线程中的所有操作都happen-before线程的终止检测。</p>
<h3 id="对象创建的happen-before原则："><a href="#对象创建的happen-before原则：" class="headerlink" title="对象创建的happen-before原则："></a>对象创建的happen-before原则：</h3><p>一个对象的初始化完成先于他的finalize方法调用。</p>
<h2 id="哪些会进行重排："><a href="#哪些会进行重排：" class="headerlink" title="哪些会进行重排："></a>哪些会进行重排：</h2><p>执行程序时为了提高性能，编译器和处理器经常会对指令进行重新排序。</p>
<h3 id="编译器优化的重排序："><a href="#编译器优化的重排序：" class="headerlink" title="编译器优化的重排序："></a>编译器优化的重排序：</h3><p>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>
<h3 id="内存系统的重排序："><a href="#内存系统的重排序：" class="headerlink" title="内存系统的重排序："></a>内存系统的重排序：</h3><p>由于处理器使用的是缓存和读写缓冲区，看上去像是乱序执行。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>创建线程的四种方式</title>
    <url>/2021/07/21/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p><em>start和run的区别</em></p>
<blockquote>
<p>调用start是开启一个线程，并自动执行run方法；</p>
<p>调用run是在当前线程去调用run方法，本质上是调用一个类中的方法，并未开启新的线程。</p>
</blockquote>
<h3 id="1、使用线程池"><a href="#1、使用线程池" class="headerlink" title="1、使用线程池"></a>1、使用线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//演示一下</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,  </span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,  </span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,  </span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,  </span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,  </span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,  </span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||  </span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||  </span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||  </span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();  </span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;  </span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;  </span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;  </span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);  </span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;  </span><br><span class="line">        <span class="keyword">this</span>.handler = handler;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>核心线程池大小</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>最大线程池大小</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>线程池中超过corePoolSize数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true)使得核心线程有效时间</td>
</tr>
<tr>
<td>TimeUnit</td>
<td>keepAliveTime时间单位</td>
</tr>
<tr>
<td>workQueue</td>
<td>任务缓存队列，用来存放等待执行的任务</td>
</tr>
<tr>
<td>threadFactory</td>
<td>新建线程工厂</td>
</tr>
<tr>
<td>RejectedExecutionHandler</td>
<td>当提交任务数超过maxmumPoolSize+workQueue之和时，任务会交给RejectedExecutionHandler来处理</td>
</tr>
</tbody></table>
<h4 id="线程池增长策略："><a href="#线程池增长策略：" class="headerlink" title="线程池增长策略："></a>线程池增长策略：</h4><p>1.当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。 </p>
<p>2.当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行 </p>
<p>3.当workQueue已满，且当前线程池中的线程数量&lt;maximumPoolSize时，新提交任务会创建新线程执行任务 </p>
<p>4.当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理 </p>
<p>5.当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程 </p>
<hr>
<h4 id="线程池的拒绝策略："><a href="#线程池的拒绝策略：" class="headerlink" title="线程池的拒绝策略："></a>线程池的拒绝策略：</h4><p>1、AbortPolicy（默认）：抛出异常</p>
<p>2、DiscardPolicy：删除不能被执行的任务</p>
<p>补充</p>
<p>6.当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭</p>
<p>7.有界任务队列</p>
<p>有界任务队列可以用ArrayBlockingQueue来实现，若有新的任务需要执行，线程池会创建新的线程，直到创建的线程数量达到corePoolSize时，会将新的任务添加入等待队列；若等待队列已满，超过ArrayBlockingQueue的初始化容量时，则会继续创建线程，直到线程数量达到maximumPoolSize，超过maximumPoolSize之后则执行拒绝策略。</p>
<p>8.无界任务队列</p>
<p>无界任务队列可以使用LinkedBlockingQueue来实现，使用无界任务队列可以无限制添加新的任务，任务的最大数量为corePoolSize，此时maximumPoolSize是无效的，若再有新的任务加入，则直接进入等待队列。</p>
<p>9.优先任务队列</p>
<p>通过PriorityBlockingQueue实现，这也是一个无界队列，此队列可自定义规则根据任务优先级顺序先后执行</p>
<hr>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p> (1) 降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</p>
<p>（2）提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；</p>
<p>（3）方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换</p>
<hr>
<hr>
<h3 id="2、实现runnable接口"><a href="#2、实现runnable接口" class="headerlink" title="2、实现runnable接口"></a>2、实现runnable接口</h3><h3 id="3、实现callable接口"><a href="#3、实现callable接口" class="headerlink" title="3、实现callable接口"></a>3、实现callable接口</h3><p>相较于实现runnable方法，线程可以有返回值，可以抛出异常</p>
<h3 id="4、继承Thread类"><a href="#4、继承Thread类" class="headerlink" title="4、继承Thread类"></a>4、继承Thread类</h3>]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的各种锁</title>
    <url>/2021/07/23/java%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81/</url>
    <content><![CDATA[<h2 id="悲观锁、乐观锁"><a href="#悲观锁、乐观锁" class="headerlink" title="悲观锁、乐观锁"></a>悲观锁、乐观锁</h2><p>这两种锁并不是指某个具体的锁，而是指一种策略，一种宏观的描述。</p>
<h3 id="悲观锁（Pessimistic-Lock）："><a href="#悲观锁（Pessimistic-Lock）：" class="headerlink" title="悲观锁（Pessimistic　Lock）："></a>悲观锁（Pessimistic　Lock）：</h3><p>认为冲突一定会发生，每次拿数据时都认为别的线程会对该数据进行修改，所以每次拿数据都会上锁；这样其他线程想取得数据都会被阻塞，直到悲观锁释放。（只要上锁，就都是悲观锁）</p>
<h3 id="乐观锁（Optimistic-Lock）："><a href="#乐观锁（Optimistic-Lock）：" class="headerlink" title="乐观锁（Optimistic Lock）："></a>乐观锁（Optimistic Lock）：</h3><p>认为冲突一定不会发生，每次拿数据都认为不会被修改，所以都不上锁；但是如果想要更新数据，会在更新前检查自读取到更新这段时间内是否有其他线程对数据进行更改，如果更改过那就重新读取，直到读取成功。（CAS算法）</p>
<hr>
<h2 id="synchronized锁的升级"><a href="#synchronized锁的升级" class="headerlink" title="synchronized锁的升级"></a>synchronized锁的升级</h2><p>无锁—偏向锁—轻量级锁（自旋锁）—重量级锁</p>
<p>上述过程叫做锁膨胀</p>
<h3 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a>偏向锁：</h3><p>初次执行到synchronized代码块的时候，锁对象会变成偏向锁（也就是偏向于第一个获得它的线程），同步代码块执行完毕之后线程不会主动释放偏向锁；第二次执行至同步代码块时，线程会判断此时持有锁的线程是否就是自己，如果是的话就正常执行。由于没有释放锁，所以也不需要重新加锁，故偏向锁性能高。</p>
<h3 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a>轻量级锁：</h3><p>一旦有第二个线程加入竞争，偏向锁就升级为轻量级锁，当某线程尝试获取锁的时候，发现已经被其他线程占用，只能等待其释放，此时发生锁竞争。在锁竞争下，没抢到锁的线程会进行自旋，即不停的循环判断锁是否能被获取。一个线程持有锁，其它线程在原地空耗cpu，这个现象叫做忙等。如果多个线程用一个锁，但是未发生锁竞争或是很轻微的锁竞争，synchronized就用轻量级锁。线程长时间的自旋是非常消耗资源的。</p>
<h3 id="重量级锁："><a href="#重量级锁：" class="headerlink" title="重量级锁："></a>重量级锁：</h3><p>如果锁的竞争情况严重，某个达到最大自旋次数的线程会将轻量级锁升级为重量级锁；当后续线程尝试获取锁时，不会再进行自旋，而是直接将自己挂起，等待被唤醒。</p>
<hr>
<h2 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h2><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>先申请先得到</p>
<h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>可能是随机或者根据优先级来得到锁</p>
<p>reentrantlock默认是非公平锁，也可以设置为公平锁；</p>
<p>synchronized只能是非公平锁</p>
<h3 id="为什么非公平锁吞吐量更大"><a href="#为什么非公平锁吞吐量更大" class="headerlink" title="为什么非公平锁吞吐量更大"></a><em>为什么非公平锁吞吐量更大</em></h3><p>因为公平锁在获取锁时，永远是等待时间最长的线程获取到锁，这样当线程T1释放锁以后，如果还想继续再获取锁，它也得去同步队列尾部排队，这样就会频繁的发生线程的上下文切换，当线程越多，对CPU的损耗就会越严重。</p>
<p>非公平锁性能虽然优于公平锁，但是会存在导致线程饥饿的情况。在最坏的情况下，可能存在某个线程一直获取不到锁。不过相比性能而言，饥饿问题可以暂时忽略，这可能就是ReentrantLock默认创建非公平锁的原因之一</p>
<hr>
<h2 id="读写锁、共享锁、互斥锁"><a href="#读写锁、共享锁、互斥锁" class="headerlink" title="读写锁、共享锁、互斥锁"></a>读写锁、共享锁、互斥锁</h2><p>读锁（共享锁），写锁（互斥锁、排他锁）。</p>
<p>如果读取数据是为了更新对象，那么加写锁，持有写锁的时候其他线程需要等待；</p>
<p>如果读取数据只是为了查询，那么加读锁，其他线程如果也要加读锁，可以直接获取该数据</p>
<hr>
<h2 id="可重入锁、不可重入锁"><a href="#可重入锁、不可重入锁" class="headerlink" title="可重入锁、不可重入锁"></a>可重入锁、不可重入锁</h2><h3 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h3><p>当前线程执行中已经获取到了该锁，再次获取该锁时就会获取不到而被阻塞</p>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>当前线程执行中已经获取了该锁，并且可以再次获取该锁而不会出现死锁；synchronized和ReentrantLock都是可重入锁</p>
<hr>
<h2 id="synchronized-和reentrantlock的异同"><a href="#synchronized-和reentrantlock的异同" class="headerlink" title="synchronized 和reentrantlock的异同"></a><strong>synchronized</strong> 和reentrantlock的异同</h2><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>synchronized是jvm实现的，reentrantlock是jdk实现的</p>
<h3 id="等待可中断"><a href="#等待可中断" class="headerlink" title="等待可中断"></a>等待可中断</h3><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，选择处理其他事情。reentrant可中断，synchronized不可以</p>
<h3 id="相同："><a href="#相同：" class="headerlink" title="相同："></a>相同：</h3><p>二者都可以解决线程安全问题</p>
<h3 id="不同："><a href="#不同：" class="headerlink" title="不同："></a>不同：</h3><p>synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器；Lock需要手动的启动同步（Lock（），同时结束同步也需要手动的实现（unlock（））</p>
<hr>
<h2 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h2><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>等其他线程运行结束之后，才执行指定线程</p>
<h3 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h3><p>一：用countDownLatch</p>
<p>二：用FutureTask</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC（Java Util Concurrent）同步器工具</title>
    <url>/2021/07/22/JUC%EF%BC%88Java%20Util%20Concurrent%EF%BC%89%E5%90%8C%E6%AD%A5%E5%99%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="1、CountDownLatch"><a href="#1、CountDownLatch" class="headerlink" title="1、CountDownLatch"></a>1、CountDownLatch</h2><p>这是一个同步工具类，用于协调多个线程之间的同步。</p>
<p>它能够使得一个线程在等待其他线程完成各自的工作之后，再继续执行。</p>
<p>使用一个计数器进行实现，当计数器的值为0时，表示所有线程都已完成任务，在countdownlatch上等待的ju线程可以恢复执行接下来的任务。</p>
<p>用法：</p>
<p>1、在某一个线程开始运行前，等待n个线程运行结束</p>
<p>将CountDownLatch的计数器初始化为n，每执行完一个线程就把计数器减1，当计数器为0时，CountDownLatch上的await就会被唤醒；一个典型的应用场景就是启动一个服务时，主线程等待其他组件加载完毕再进行执行。</p>
<p>2、实现多个线程的并行运行。</p>
<p>类似赛跑；初始化一个共享的CountDownLatch（1），多个线程执行任务前首先进行CountDownLatch.await（），当主线程调用countdown（）时，计数器变为0，多个线程同时被唤醒。</p>
<p>缺点：</p>
<p>CountDownLatch是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其进行赋值。</p>
<h2 id="2、CyclicBarrier"><a href="#2、CyclicBarrier" class="headerlink" title="2、CyclicBarrier"></a>2、CyclicBarrier</h2><p>允许一组线程互相等待，直到到达某个公共屏障；这个barrier可重用，所以称它为循环barrier。</p>
<p>与CountDownLatch不同的是barrier是加数计数方式，CountDownLatch是减数计数方式。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>句柄Handle</title>
    <url>/2021/07/25/%E5%8F%A5%E6%9F%84Handle/</url>
    <content><![CDATA[<h2 id="对象句柄："><a href="#对象句柄：" class="headerlink" title="对象句柄："></a>对象句柄：</h2><p>一个唯一的整数,作为对象的身份id,区分不同的对象，和同类中的不同实例。</p>
<p>每次操作对象就是根据句柄去找到对象操作对象的. 即使没有对象,我们也可以让句柄单独存在。</p>
<h2 id="jvm中的对象访问句柄："><a href="#jvm中的对象访问句柄：" class="headerlink" title="jvm中的对象访问句柄："></a>jvm中的对象访问句柄：</h2><p>由于reference类型在Java虚拟机规范里只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。</p>
<h3 id="1、使用句柄访问方式"><a href="#1、使用句柄访问方式" class="headerlink" title="1、使用句柄访问方式"></a>1、使用句柄访问方式</h3><p>如果使用句柄访问方式，Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。使用句柄方式最大的好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p>
<h3 id="2、使用直接指针访问方式"><a href="#2、使用直接指针访问方式" class="headerlink" title="2、使用直接指针访问方式"></a>2、使用直接指针访问方式</h3><p>如果使用该方式，Java堆对象的布局就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址。使用直接指针方式最大的好处就是速度更快，他节省了一次指针定位的时间开销。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在对象分配的时候,句柄使用较多.在对象访问的时候,其实是可以权衡的,如果使用直接指针的方式进行对象访问,那么更多的就是关注堆中已分配对象的快速访问;如果使用句柄访问的方式,更多的是考虑到GC的时候,对象的移动十分频繁(具体参照JVM垃圾回收算法),那么句柄访问方式会更有优势。所以目前来看，就HotSpot来说，对象分配更多使用句柄，对象访问使用直接指针。</p>
]]></content>
      <categories>
        <category>JVM相关</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>java内存区域</title>
    <url>/2021/07/28/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>一共分为五大区域，堆和方法区是线程共享的，其他三个是线程隔离的。</p>
<img src="/2021/07/28/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/image-20210802162802207.png" alt="java内存区域划分" style="zoom: 67%;">

<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>存放实例对象和数组对象；</p>
<p>GC的主要区域；</p>
<p>可细分为新生代和老年代；</p>
<p>堆中对象的访问方式：通过reference数据来操作堆上的具体数据。</p>
<p>句柄：</p>
<p>采用句柄的话，会在堆中开辟一块内存用来当作句柄池，reference中存放的就是句柄地址；优点是稳定。</p>
<p>直接指针：</p>
<p>存放的就是对象地址；优点是效率高。</p>
<p>==空间不足会抛出OutOfMemoryError==</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>用于存储已经被虚拟机加载的类的信息、常量、静态变量、运行时常量池。其中运行时常量池用于存放编译期生成的各种字面量和符号引用。（jdk8之前是用永久代的方式实现方法区，jdk8之后采用元空间来实现方法区）</p>
<p>字面量：</p>
<p>文本字符串；</p>
<p>8种基本类型；</p>
<p>声明为final的常量；</p>
<p>符号引用：</p>
<p>类和方法的限定名；</p>
<p>方法的名称和描述符；</p>
<p>==空间不足会抛出OutOfMemoryError==</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>java方法执行的内存模型，线程私有，每个方法执行都会创建一个栈帧，每个方法从调用至结束都对应着一个栈帧从入栈到出栈的过程。</p>
<p>StackOverFlowError ：线程请求的栈的深度大于虚拟机所允许的深度。</p>
<p>OutOfMemoryError ：虚拟机栈可以进行动态扩展，但是扩展的栈无法申请的到足够的内存。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>java调用本地方法（可以为其他语言提供接口），会报OutOfMemoryError和StackOverFlowError</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>每个线程都会有一个程序计数器，==唯一一个没有OutOfMemoryError情况的内存区域==。</p>
]]></content>
      <categories>
        <category>JVM相关</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>如何判断对象已经死亡</title>
    <url>/2021/07/30/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%B7%B2%E7%BB%8F%E6%AD%BB%E4%BA%A1/</url>
    <content><![CDATA[<h2 id="1、可达性分析法（常用）"><a href="#1、可达性分析法（常用）" class="headerlink" title="1、可达性分析法（常用）"></a>1、可达性分析法（常用）</h2><p>通过一系列GCRoots的对象作为起点，从起点开始向下搜素，节点所走过的路径称为引用链，当一个对象到GCRoots没有任何引用链时，该对象不可用。</p>
<p>GCRoots：可以是虚拟机栈中的引用对象、方法区中类静态属性引用的对象、方法区中常量引用的对象。</p>
<h2 id="2、引用计数法（JVM未采用）"><a href="#2、引用计数法（JVM未采用）" class="headerlink" title="2、引用计数法（JVM未采用）"></a>2、引用计数法（JVM未采用）</h2><p>对一个对象来说，每当有一个地方引用它，计数器就+1；引用失效就-1；当计数器为0时该对象已经不可能再被使用。</p>
<p>缺点：无法解决两个对象互相引用的情况，这就是==死循环==。</p>
<h2 id="但是"><a href="#但是" class="headerlink" title="但是"></a>但是</h2><p>回收一个对象起码需要两次标记，可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法，当该对象没有覆盖finalize方法或者finalize方法已经被调用过时，这种情况视为没必要执行；被判定需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被回收。</p>
]]></content>
      <categories>
        <category>JVM相关</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>强软弱虚引用</title>
    <url>/2021/07/31/%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>一个对象有强引用时，GC绝不回收，宁可报错OutOfMemoryError也不回收.</p>
<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>只要内存空间足够，就不会回收它；空间不够时才回收这些对象的内存。只要GC没回收它，该对象就一直可被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用关联的对象只能活到下一次垃圾回收之前。</p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>如果一个对象仅持有虚引用，其实就跟没有任何引用一样，随时可被回收。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虚引用必须和引用队列（Reference Queue）联合使用。当垃圾回收器准备回收一个对象时，发现该对象还有虚引用，那么就会将这个虚引用加入到与之关联的引用队列中，这样可以通过判断引用队列中是否已经加入虚引用来判断被引用的对象是否要被GC回收，便于在回收之前做一些必要行动。</p>
<p>虚引用和软引用、弱引用的区别</p>
<p>软、弱是在GC回收该对象之后，才将引用加入到引用队列中；</p>
<p>虚引用是在GC回收对象之前，将该引用加入到引用队列中。</p>
]]></content>
      <categories>
        <category>JVM相关</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>永久代和元空间</title>
    <url>/2021/07/29/%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%92%8C%E5%85%83%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p>
<p>-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</p>
<p>-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</p>
<p>除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：</p>
<p>-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</p>
<p>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</p>
<h2 id="为什么要将永久代转为元空间"><a href="#为什么要将永久代转为元空间" class="headerlink" title="为什么要将永久代转为元空间"></a>为什么要将永久代转为元空间</h2><p>1、字符串存在永久代中，容易出现性能问题和内存溢出。</p>
<p>2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p>
<p>3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p>
<p>4、Oracle 可能会将HotSpot 与 JRockit 合二为一。</p>
<p>来自 <a href="https://www.cnblogs.com/paddix/p/5309550.html">https://www.cnblogs.com/paddix/p/5309550.html</a> </p>
]]></content>
      <categories>
        <category>JVM相关</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>符号引用和直接引用</title>
    <url>/2021/07/26/%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="符号引用："><a href="#符号引用：" class="headerlink" title="符号引用："></a>符号引用：</h2><p>符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用和虚拟机的布局无关。</p>
<p>个人理解为：在编译的时候一个每个java类都会被编译成一个class文件，但在编译的时候虚拟机并不知道所引用类的地址，多以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。</p>
<h2 id="直接引用："><a href="#直接引用：" class="headerlink" title="直接引用："></a>直接引用：</h2><p>直接引用可以是：直接指向目标的指针、相对偏移量、能间接定位到目标的句柄。直接引用和虚拟机的布局是相关的，不同的虚拟机对于相同的符号引用所翻译出来的直接引用一般是不同的。如果有了直接引用，那么直接引用的目标一定被加载到了内存中。</p>
]]></content>
      <categories>
        <category>JVM相关</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>逃逸分析</title>
    <url>/2021/07/27/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>关于这个逃逸问题，我的了解主要来源于这篇[文章](<a href="https://blog.csdn.net/hollis_chuang/article/details/80922794">深入理解Java中的逃逸分析_HollisChuang’s Blog-CSDN博客_逃逸分析</a>)</p>
<p>人家写的不错，在此便不再多做解释，可从原文章详细阅读。</p>
]]></content>
      <categories>
        <category>JVM相关</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM中类的加载机制</title>
    <url>/2021/05/23/JVM%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>加载过程一共分为5个步骤</p>
<p>加载–验证–准备–解析–初始化–使用–卸载</p>
<h1 id="加载："><a href="#加载：" class="headerlink" title="加载："></a>加载：</h1><ol>
<li>通过类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个类字节流代表的静态存储结构转为方法区的运行时数据结构</li>
<li>在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口。</li>
</ol>
<p>这个过程主要就是类加载器完成。</p>
<h1 id="验证："><a href="#验证：" class="headerlink" title="验证："></a>验证：</h1><p>此阶段主要确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的自身安全。</p>
<ol>
<li>文件格式验证：基于字节流验证。</li>
<li>元数据验证：基于方法区的存储结构验证。</li>
<li>字节码验证：基于方法区的存储结构验证。</li>
<li>符号引用验证：基于方法区的存储结构验证。</li>
</ol>
<h1 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h1><p>为类变量分配内存，并将其初始化为默认值。（此时为默认值，在初始化的时候才会给变量赋值）即在方法区中分配这些变量所使用的内存空间。</p>
<p>public static int value = 123;</p>
<p>此时在准备阶段过后的初始值为0而不是123；将value赋值为123的putstatic指令是程序被编译后，存放于类构造器<client>方法之中.</client></p>
<p>下面这个不一样，此时value的值在准备阶段过后就是123</p>
<p>public static final int value = 123; </p>
<h1 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h1><p>把类型中的符号引用转换为直接引用，直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。</p>
<p>主要有以下四种：</p>
<p>类或接口的解析；</p>
<p>字段解析；</p>
<p>类方法解析；</p>
<p>接口方法解析</p>
<h1 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h1><p>初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证<client>方法执行之前，父类的<client>方法已经执行完毕。如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>()方法。</client></client></client></client></client></p>
<p>java中，对于初始化阶段，有且只有以下六种情况才会对要求类立刻“初始化”（加载，验证，准备，自然需要在此之前开始）：</p>
<ol>
<li>使用new关键字实例化对象、访问或者设置一个类的静态字段（被final修饰、编译器优化时已经放入常量池的例外）、调用类方法，都会初始化该静态字段或者静态方法所在的类。</li>
<li>初始化类的时候，如果其父类没有被初始化过，则要先触发其父类初始化。</li>
<li>使用java.lang.reflect包的方法进行反射调用的时候，如果类没有被初始化，则要先初始化。</li>
<li>虚拟机启动时，用户会先初始化要执行的主类（含有main）</li>
<li>jdk     1.7后，如果java.lang.invoke.MethodHandle的实例最后对应的解析结果是     REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄，并且这个方法所在类没有初始化，则先初始化。</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法的三种写法</title>
    <url>/2021/08/03/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E4%B8%89%E7%A7%8D%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<p>总结二分边界的写法是因为很容易出错，比如说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这种属于向下取整，容易出现left=3，right=4，mid=3的死循环</span></span><br><span class="line"><span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>第一种写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (low &lt; high) &#123;<span class="comment">//退出循环时必定low==high</span></span><br><span class="line">    <span class="keyword">long</span> mid = low + (high - low) / <span class="number">2</span>;<span class="comment">//向下取整</span></span><br><span class="line">    <span class="keyword">long</span> r = mid * mid;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; x) high = mid;</span><br><span class="line">    <span class="comment">//当需要在右区间查找时，改变low的值，使得向下取整不会发生死循环</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; x) low = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">int</span>) mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) low - <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">    <span class="keyword">long</span> mid = low + (high - low + <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//直接改为向上取整，避免了向下取整带来的死循环</span></span><br><span class="line">    <span class="keyword">long</span> r = mid * mid;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; x) high = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; x) low = mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">int</span>) mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) low;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第三种写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123;<span class="comment">//注意此处退出循环时low！=high</span></span><br><span class="line">    <span class="keyword">long</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">long</span> r = mid * mid;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; x) high = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; x) low = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">int</span>) mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) low - <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>个人心得</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的垃圾收集器</title>
    <url>/2021/05/25/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    <content><![CDATA[<p>收集算法是内存回收的方法论，垃圾收集器是具体实现。</p>
<p>衡量垃圾收集器的三项重要指标：内存占用、吞吐量、延迟。</p>
<h1 id="CMS（Concurrent-Mark-Sweep）："><a href="#CMS（Concurrent-Mark-Sweep）：" class="headerlink" title="CMS（Concurrent Mark Sweep）："></a>CMS（Concurrent Mark Sweep）：</h1><p>采用标记-清除算法，以获取最短回收停顿时间为目标的收集器。</p>
<p>分为四个步骤：</p>
<h2 id="初始标记："><a href="#初始标记：" class="headerlink" title="初始标记："></a>初始标记：</h2><p>暂停其他线程，记录下与GCRoots直接相连的对象，速度很快；</p>
<h2 id="并发标记："><a href="#并发标记：" class="headerlink" title="并发标记："></a>并发标记：</h2><p>从GCRoots的直接关联对象开始遍历整个对象图的过程，整个过程时间较长但是不需要停顿用户线程，可以与垃圾收集线程一起工作；</p>
<h2 id="重新标记："><a href="#重新标记：" class="headerlink" title="重新标记："></a>重新标记：</h2><p>为了修正并发标记期间因为用户线程产生的标记变动那一部分对象。该阶段停顿时间比初始标记时间长，比并发标记时间短。</p>
<h2 id="并发清除："><a href="#并发清除：" class="headerlink" title="并发清除："></a>并发清除：</h2><p>清理删除掉标记阶段判断的已经死亡对象，由于不需要移动存活对象，这个阶段也可以和用户线程同时并发。</p>
<p>其中初始标记和并发标记需要stop the world。</p>
<p><img src="/2021/05/25/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210803095001438.png" alt="CMS垃圾收集器"></p>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><p>1：无法处理浮动垃圾（在并发标记和并发清理阶段产生的垃圾），只能下次清理时再清理掉，所以必须预留一部分空间供并发收集时的程序运作使用。</p>
<p>2：会产生空间碎片。</p>
<hr>
<h1 id="G1（Garbage-First）："><a href="#G1（Garbage-First）：" class="headerlink" title="G1（Garbage First）："></a>G1（Garbage First）：</h1><p>采用标记-整理算法。</p>
<h2 id="四个步骤："><a href="#四个步骤：" class="headerlink" title="四个步骤："></a>四个步骤：</h2><p>初始标记、并发标记、最终标记、筛选回收。</p>
<p>前两个步骤和CMS一样，</p>
<p>最终标记：将并发阶段对象的变化记录在日志里面，该阶段需要停顿线程。</p>
<p>筛选回收：对每一块待回收的区域的价值和成本进行筛选，根据用户期望的GC停顿时间选择最好的回收方案并回收。</p>
<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>并发性强、分代收集、空间整合（不会产生空间碎片）、可预测停顿时间。</p>
<h2 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h2><p>内存占用高</p>
<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>将连续的java堆划分为多个大小相同的独立区域（region），每个region都可以根据需要扮演新生代的eden空间、survivor空间或者是老年代空间。收集器能堆扮演不同角色的region采用不同的策略去收集；</p>
<p>region还有一类特殊的humongous区域，专门用于存储大对象（超过region的一半即为大对象）；</p>
<p>为什么G1能建立可预测的停顿时间模型？</p>
<p>因为G1将region作为单次回收的最小单元，即每次回收都是region的整数倍，更具体的思路是让G1收集器跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间以及所需要的时间的经验值），根据用户设定的允许的停顿收集时间（200ms就很合理），优先处理回收价值收益最大的region，保证G1在有限时间内获取尽可能高的收集效率。</p>
<p><img src="/2021/05/25/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210803095542074.png" alt="Garbage First垃圾收集器"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集算法简述</title>
    <url>/2021/05/26/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="1、标记-清除算法"><a href="#1、标记-清除算法" class="headerlink" title="1、标记-清除算法"></a>1、标记-清除算法</h1><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。不需要移动被回收的对象，只需要对不存活的对象进行处理；在存活对象较多时效率较高。</p>
<p>缺点：执行效率不稳定；会产生大量不连续的空间碎片。</p>
<h1 id="2、标记-复制算法"><a href="#2、标记-复制算法" class="headerlink" title="2、标记-复制算法"></a>2、标记-复制算法</h1><p>为了克服句柄的开销和解决内存碎片问题。将堆分为一个对象面和多个空闲面，程序在对象面分配空间，空间不足时，基于copying算法的垃圾收集从GCRoots中扫描活动对象，将活动对象复制到空闲面 ，这样空闲面就变成了对象面，程序会在新的对象面中分配内存。适用于存活对象较少时使用。</p>
<p>详细：这个是将年轻代的内存空间分为三块（8：1：1），一块eden，两块survivor，每次使用eden和一个survivor；进行垃圾回收时将存活对象放入剩下的survivor中；如果存活对象超过10%（也就是说剩余的survivor放不下），将多出的对象直接放入老年代。</p>
<p>缺点：</p>
<p>在对象的存活率较高时，效率就会降低</p>
<h1 id="3、标记-整理算法"><a href="#3、标记-整理算法" class="headerlink" title="3、标记-整理算法"></a>3、标记-整理算法</h1><p>与标记-清除算法差不多，先进行标记，后续将存活的对象向一侧进行移动，然后清理掉边界之外的内存。适合存活对象较多。</p>
<p>缺点：这种对象移动操作必须全程暂停用户应用程序；</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>移动对象时，内存回收较为复杂；不移动对象时，内存分配更加复杂；但是总的来看，移动对象会更加划算，因为内存分配和访问相比垃圾收集频率要高。</p>
<p>还有一种和稀泥的方法，平时采用标记清除，等到空间碎片忍不了的时候，再用标记移动。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>类的加载器和双亲委派模型</title>
    <url>/2021/05/22/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<img src="/2021/05/22/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/image-20210803095848598.png" alt="双亲委派模型" style="zoom:67%;">

<p>除了顶层的启动类加载器之外，其他加载器都有自己的父类加载器。（注意，这里的父类加载器通常是指用组合的方式，而不是继承关系来复用父类的加载器。）</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>当一个类的加载器收到类加载的请求，先把这个请求委派给父类加载器去完成（所以所有的加载请求最终都应该传送至顶层的启动类加载器中），当父类加载器反馈自己无法完成加载请求时，子加载器才会自己尝试完成加载。</p>
<p>优点：这种模型使得java类随其加载器一起具备了一种优先级的关系。可保证在各个类的加载器环境中，加载的最顶层的类时同一个父类。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>老年代对象</title>
    <url>/2021/05/24/%E8%80%81%E5%B9%B4%E4%BB%A3%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>Minor GC：发生在新生代垃圾收集，比较频繁，时间短</p>
<p>Major GC：发生在老年的垃圾收集</p>
<p>Full GC：新生代、老年代一起清理</p>
<p>大多数情况下，对象在新生代进行内存分配，Eden没有足够的空间时，会发起Minor GC</p>
<p>什么时候对象会进入老年代？</p>
<p>1、大对象直接进入老年代（在Garbage First里面，对象大小超过0.5个region时，直接放入老年代）</p>
<p>2、空间分配担保</p>
<p>就是存活的对象在剩余的那个survivor放不下时，就直接进入老年代</p>
<p>3、年龄判定</p>
<p>每经过一次GC，就给存活的对象年龄+1，超过设定值（15）就进入老年代；</p>
<p>还可以动态判定，同一个年龄的对象大小总和超过survivor空间的一半，则年龄大于等于该对象的直接进入老年代。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-二叉树的遍历</title>
    <url>/2021/06/24/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h1><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<h2 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h2><p>BFS</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>没什么好分析的，就是层序遍历，需要用到几个集合，得多熟悉：LinkedList，ArrayDeque，ArrayList，我回头做个关于集合的总结，要好好掌握。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.offerLast(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = stack.size();</span><br><span class="line">            ArrayList&lt;Integer&gt; curList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (size&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode treeNode = stack.removeFirst();</span><br><span class="line">                curList.add(treeNode.val);</span><br><span class="line">                <span class="keyword">if</span>(treeNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.offerLast(treeNode.left);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(treeNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    stack.offerLast(treeNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            resList.add(curList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h1><h2 id="知识点：BFS"><a href="#知识点：BFS" class="headerlink" title="知识点：BFS"></a>知识点：BFS</h2><h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><p>同上</p>
<h2 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> mark = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Deque&lt;Integer&gt; curList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = stack.size();</span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode treeNode = stack.removeFirst();</span><br><span class="line">                <span class="keyword">if</span>(mark)&#123;</span><br><span class="line">                    curList.offerFirst(treeNode.val);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    curList.offerLast(treeNode.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.offerLast(treeNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.offerLast(treeNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            mark=!mark;</span><br><span class="line">            resList.add(<span class="keyword">new</span> LinkedList&lt;&gt;(curList));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="1104-二叉树寻路"><a href="#1104-二叉树寻路" class="headerlink" title="1104. 二叉树寻路"></a><a href="https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/">1104. 二叉树寻路</a></h1><p>在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。</p>
<p>如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；</p>
<p>而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。</p>
<p><img src="/2021/06/24/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20210729101603254.png" alt="二叉树寻路"></p>
<p>给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。</p>
<p>示例 1：</p>
<p>输入：label = 14</p>
<p>输出：[1,3,4,14]</p>
<p>示例 2：</p>
<p>输入：label = 26</p>
<p>输出：[1,2,6,10,26]</p>
<p>提示：</p>
<p>1 &lt;= label &lt;= 10^6</p>
<h2 id="知识点：二叉树"><a href="#知识点：二叉树" class="headerlink" title="知识点：二叉树"></a>知识点：二叉树</h2><h2 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h2><p>这个和普通二叉树的区别在于偶数行进行了镜像式转换，考虑到对称的特点：任意两个对称位置上的数字和相等。故根据这一特点对每行数字进行查找，如果是偶数行，则需进行反转。<a href="https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/solution/er-cha-shu-xun-lu-by-leetcode-solution-ryx0/">题解</a>讲的很细致。</p>
<h2 id="代码如下：-2"><a href="#代码如下：-2" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">pathInZigZagTree</span><span class="params">(<span class="keyword">int</span> label)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">1</span>,rowStart = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//确定label所在行数</span></span><br><span class="line">        <span class="keyword">while</span>(rowStart*<span class="number">2</span>&lt;=label)&#123;</span><br><span class="line">            row++;</span><br><span class="line">            rowStart*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(row%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            label = getReverse(label,row);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (row&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(row%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                res.add(getReverse(label, row));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(label);</span><br><span class="line">            &#125;</span><br><span class="line">            --row;</span><br><span class="line">            label&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getReverse</span><span class="params">(<span class="keyword">int</span> label, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;row-<span class="number">1</span>)+(<span class="number">1</span>&lt;&lt;row)-<span class="number">1</span>-label;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="987-二叉树的垂序遍历"><a href="#987-二叉树的垂序遍历" class="headerlink" title="987. 二叉树的垂序遍历"></a><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/">987. 二叉树的垂序遍历</a></h1><p>给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。</p>
<p>对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。</p>
<p>二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。</p>
<p>返回二叉树的 垂序遍历 序列。</p>
<img src="/2021/06/24/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20210731103159133.png" alt="二叉树的垂序遍历" style="zoom: 67%;">

<img src="/2021/06/24/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20210731103316323.png" alt="二叉树的垂序遍历示例2" style="zoom:67%;">

<h2 id="知识点：二叉树遍历"><a href="#知识点：二叉树遍历" class="headerlink" title="知识点：二叉树遍历"></a>知识点：二叉树遍历</h2><h2 id="分析：-3"><a href="#分析：-3" class="headerlink" title="分析："></a>分析：</h2><p>既然是根据节点的列坐标进行排序，首先对二叉树进行深度优先遍历，记录所有节点的横纵坐标，然后根据纵坐标进行排序，为了方便，再根据横坐标进行第二优先排序，最后根据节点数值大小进行第三优先排序。</p>
<h2 id="代码如下：-3"><a href="#代码如下：-3" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LC987_vertical_order_traversal_of_a_binary_tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mytreenode.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VerticalOrderTraversalOfABinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root,<span class="number">0</span>,<span class="number">0</span>,nodes);</span><br><span class="line">        Collections.sort(nodes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1[<span class="number">0</span>]!=o2[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> o1[<span class="number">0</span>]-o2[<span class="number">0</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1[<span class="number">1</span>]!=o2[<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> o1[<span class="number">2</span>]-o2[<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lastCol = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] node:nodes)&#123;</span><br><span class="line">            <span class="keyword">int</span> col = node[<span class="number">0</span>],row = node[<span class="number">1</span>],value = node[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//如果不是同一列</span></span><br><span class="line">            <span class="keyword">if</span>(col!=lastCol)&#123;</span><br><span class="line">                lastCol = col;</span><br><span class="line">                ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.get(size-<span class="number">1</span>).add(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行深度优先遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row 当前行数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col 当前列数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodes 存放数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> row, <span class="keyword">int</span> col, List&lt;<span class="keyword">int</span>[]&gt; nodes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;col,row,root.val&#125;);</span><br><span class="line">        dfs(root.left,row+<span class="number">1</span>, col-<span class="number">1</span>, nodes);</span><br><span class="line">        dfs(root.right,row+<span class="number">1</span>,col+<span class="number">1</span>,nodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-重排链表</title>
    <url>/2021/06/10/leetcode-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h1><p>反转一个单链表。</p>
<p> 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</p>
<p> 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析：</strong></h2><p>没啥好分析的,递归就行了.</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a><strong>代码如下：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//记录下一个节点</span></span><br><span class="line">            ListNode tmpNext=head.next;</span><br><span class="line">            <span class="comment">//使当前节点指向前一个节点</span></span><br><span class="line">            head.next=pre;</span><br><span class="line">            <span class="comment">//更新前节点</span></span><br><span class="line">            pre=head;</span><br><span class="line">            <span class="comment">//更新head</span></span><br><span class="line">            head=tmpNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// head.next=pre;</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h1><p>给你单链表的头指针head和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回反转后的链表。</p>
<p> 输入：head = [1,2,3,4,5], left = 2, right = 4</p>
<p> 输出：[1,4,3,2,5]</p>
<h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a><strong>分析：</strong></h2><p>说白了就是反转指定区间的链表，其他不变；这个可以用头插法（就是新增节点插在头部），其实不难，就是注意细节问题。</p>
<h2 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a><strong>代码如下：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>||left==right)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>,head);</span><br><span class="line">        ListNode preNode = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index&lt;left)&#123;</span><br><span class="line">            preNode = preNode.next;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = right-left;</span><br><span class="line">        ListNode curNode = preNode.next;</span><br><span class="line">        ListNode suc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            suc = curNode.next;</span><br><span class="line">            curNode.next = suc.next;</span><br><span class="line">            suc.next = preNode.next;</span><br><span class="line">            preNode.next = suc;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<img src="/2021/06/10/leetcode-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/image-20210804104939017.png" alt="两两交换链表中的节点" style="zoom:67%;">

<p>示例 1：</p>
<p>输入：head = [1,2,3,4] 输出：[2,1,4,3]</p>
<h2 id="知识点：链表"><a href="#知识点：链表" class="headerlink" title="知识点：链表"></a><strong>知识点：链表</strong></h2><h2 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a><strong>分析：</strong></h2><p>除了互相交换的两个节点之外，还需要前一个节点进行辅助。</p>
<h2 id="代码如下：-2"><a href="#代码如下：-2" class="headerlink" title="代码如下："></a><strong>代码如下：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>,head);</span><br><span class="line">        ListNode preHead = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(preHead.next!=<span class="keyword">null</span>&amp;&amp;preHead.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode start = preHead.next;</span><br><span class="line">            ListNode end = preHead.next.next;</span><br><span class="line">            preHead.next = end;</span><br><span class="line">            start.next = end.next;</span><br><span class="line">            end.next = start;</span><br><span class="line">            preHead = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h1><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>进阶：</p>
<p>你可以设计一个只使用常数额外空间的算法来解决此问题吗？</p>
<p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>除了反转之外，还涉及到一个检查剩余节点够不够反转的问题，在反转之前检查下即可。</p>
<h2 id="代码如下：-3"><a href="#代码如下：-3" class="headerlink" title="代码如下："></a><strong>代码如下：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>,head);</span><br><span class="line">        ListNode pre = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tail = pre;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                <span class="keyword">if</span>(tail==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode nextNode = tail.next;</span><br><span class="line">            ListNode[] ans = myReverse(head,tail);</span><br><span class="line">            head = ans[<span class="number">0</span>];</span><br><span class="line">            tail = ans[<span class="number">1</span>];</span><br><span class="line">            pre.next = head;</span><br><span class="line">            tail.next = nextNode;</span><br><span class="line">            pre = tail;</span><br><span class="line">            head = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode[] myReverse(ListNode head,ListNode tail)&#123;</span><br><span class="line">        ListNode pre = tail.next;</span><br><span class="line">        ListNode curNode = head;</span><br><span class="line">        <span class="keyword">while</span>(pre!=tail)&#123;</span><br><span class="line">            ListNode suc = curNode.next;</span><br><span class="line">            curNode.next = pre;</span><br><span class="line">            pre = curNode;</span><br><span class="line">            curNode = suc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListNode[]&#123;tail,head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a></h1><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，</p>
<p>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例 1:</p>
<p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</p>
<p>示例 2:</p>
<p>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</p>
<h2 id="知识点：链表-1"><a href="#知识点：链表-1" class="headerlink" title="知识点：链表"></a>知识点：链表</h2><h2 id="分析：-3"><a href="#分析：-3" class="headerlink" title="分析："></a>分析：</h2><p>仔细观察可发现，重新排列是将链表分为两段后进行挨个穿插得到；于是本题思路为，找到链表后半部分（注意如果是奇数则不包括中间那个）头部；对后半段进行反转；然后将两段链表进行穿插。</p>
<h2 id="代码如下：-4"><a href="#代码如下：-4" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先找到后半段链表</span></span><br><span class="line">        ListNode fast = head,slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span>&amp;&amp;fast.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode secHead = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// ListNode curNode = secHead;</span></span><br><span class="line">        <span class="comment">//反转第二段链表</span></span><br><span class="line">        <span class="keyword">while</span>(secHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmpNext = secHead.next;</span><br><span class="line">            secHead.next = pre;</span><br><span class="line">            pre = secHead;</span><br><span class="line">            secHead = tmpNext;</span><br><span class="line">        &#125;</span><br><span class="line">        secHead = pre;</span><br><span class="line">        ListNode firHead = head;</span><br><span class="line">        <span class="comment">//拼接两段链表</span></span><br><span class="line">        <span class="keyword">while</span>(firHead!=<span class="keyword">null</span>&amp;&amp;secHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode firNext = firHead.next;</span><br><span class="line">            ListNode secNext = secHead.next;</span><br><span class="line"></span><br><span class="line">            firHead.next = secHead;</span><br><span class="line">            firHead = firNext;</span><br><span class="line"></span><br><span class="line">            secHead.next = firHead;</span><br><span class="line">            secHead = secNext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-岛屿问题</title>
    <url>/2021/06/08/leetcode-%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h1><h2 id="知识点：DFS"><a href="#知识点：DFS" class="headerlink" title="知识点：DFS"></a>知识点：DFS</h2><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>这题让求的是岛屿的数量有多少个，就其解法思路上并不困难。循环遍历每一块陆地，每遇到一个陆地就对其上下左右四个方向进行查找，每找到一个就让该陆地置0，这样在最外层遍历时就不会重复遇到，dfs的主要作用就是对遇到的陆地进行四个方向的查找。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length==<span class="number">0</span>)&#123;<span class="comment">//简单判断是否为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count= <span class="number">0</span>,m =grid.length,n=grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//外层遍历</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;<span class="comment">//只要找到一个陆地，起码就是一个岛屿，对其进行dfs</span></span><br><span class="line">                    count++;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> gr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> gc = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>||r&gt;=gr||c&lt;<span class="number">0</span>||c&gt;=gc||grid[r][c]==<span class="string">&#x27;0&#x27;</span>)&#123;<span class="comment">//此处要注意边界条件</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;<span class="comment">//遍历之前记得让当前岛屿下沉，不然之后会出现重复查找</span></span><br><span class="line">        dfs(grid,r+<span class="number">1</span>,c);</span><br><span class="line">        dfs(grid,r-<span class="number">1</span>,c);</span><br><span class="line">        dfs(grid,r,c+<span class="number">1</span>);</span><br><span class="line">        dfs(grid,r,c-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h1><h2 id="知识点：dfs"><a href="#知识点：dfs" class="headerlink" title="知识点：dfs"></a>知识点：dfs</h2><h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><p>这两道题型基本一致，只是在本题中需要记录的数据不是数量，而是记录下每次dfs的最大值，关键点在dfs的编写中，每次dfs返回一个数字：0或者1。对于每个陆地而言，最小面积是1，最终面积取决于有多少和它间接、直接相连的陆地。</p>
<h2 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h2><p>还有个岛屿的周长，我觉得有个想法挺独树一帜的，值得学习</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;<span class="comment">//</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;<span class="comment">//外层还是遍历</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    res=Math.max(res,dfs(grid,i,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//要确定当前节点在范围内,且是个岛</span></span><br><span class="line">        <span class="keyword">if</span>(m&lt;<span class="number">0</span>||m&gt;=grid.length||n&lt;<span class="number">0</span>||n&gt;=grid[<span class="number">0</span>].length||grid[m][n]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将当前节点置零</span></span><br><span class="line">        grid[m][n]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+dfs(grid,m-<span class="number">1</span>,n)+dfs(grid,m+<span class="number">1</span>,n)+dfs(grid,m,n+<span class="number">1</span>)+dfs(grid,m,n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a><a href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a></h1><h2 id="知识点：dfs-1"><a href="#知识点：dfs-1" class="headerlink" title="知识点：dfs"></a>知识点：dfs</h2><h2 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h2><p>思路挺好，值得学习。题目中已经确定只有一个岛屿了，只是让求出岛屿的周长。难点在于怎么确定岛屿的哪一条边是有效周长，有个思路很好：在每个陆地向上下左右四个方向查找的时候，如果遇到边界或者是水域，则周长+1，这个想法挺好的，可以说很完美的贴切了岛屿边的这个定义。</p>
<h2 id="代码如下：-2"><a href="#代码如下：-2" class="headerlink" title="代码如下："></a>代码如下：</h2><p> 注：其实这个查找周长也可以扩展一下，改为查找最大周长。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    res=dfs(grid,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果从陆地遇到边界，则周长+1</span></span><br><span class="line">        <span class="keyword">if</span>(!(r&gt;=<span class="number">0</span>&amp;&amp;r&lt;grid.length&amp;&amp;c&gt;=<span class="number">0</span>&amp;&amp;c&lt;grid[<span class="number">0</span>].length))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果从陆地遇到水域，则周长+1</span></span><br><span class="line">        <span class="keyword">if</span>(grid[r][c]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//肯定是个2，那就说明已经找过了</span></span><br><span class="line">        <span class="keyword">if</span>(grid[r][c]!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对遍历过的点，置为2</span></span><br><span class="line">        grid[r][c]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(grid,r+<span class="number">1</span>,c)+dfs(grid,r-<span class="number">1</span>,c)+dfs(grid,r,c+<span class="number">1</span>)+dfs(grid,r,c-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode-图相关</title>
    <url>/2021/08/05/leetcode-%E5%9B%BE%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="802-找到最终的安全状态"><a href="#802-找到最终的安全状态" class="headerlink" title="802. 找到最终的安全状态"></a><a href="https://leetcode-cn.com/problems/find-eventual-safe-states/">802. 找到最终的安全状态</a></h1><p>在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。</p>
<p>对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全 的。</p>
<p>返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。</p>
<p>该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。</p>
<img src="/2021/08/05/leetcode-%E5%9B%BE%E7%9B%B8%E5%85%B3/image-20210805095032341.png" alt="图相关1" style="zoom:67%;">

<p>提示：</p>
<p>n == graph.length</p>
<p>1 &lt;= n &lt;= 104</p>
<p>0 &lt;= graph[i].length &lt;= n</p>
<p>graph[i] 按严格递增顺序排列。</p>
<p>图中可能包含自环。</p>
<p>图中边的数目在范围 [1, 4 * 104] 内。</p>
<h2 id="知识点：dfs、图"><a href="#知识点：dfs、图" class="headerlink" title="知识点：dfs、图"></a>知识点：dfs、图</h2><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>一个节点是否安全，取决于它能到达的节点是否安全；</p>
<p>我们将节点的状态设置为3种：0：未遍历到、1：不安全（在环上）、2：安全的</p>
<p>在对每个节点查找之前，将该节点设置为不安全状态，之后对节点到达的每个节点进行查询是否安全</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">eventualSafeNodes</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = graph.length;</span><br><span class="line">        <span class="keyword">int</span>[] color = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(safe(graph,color,i))&#123;</span><br><span class="line">                ans.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">safe</span><span class="params">(<span class="keyword">int</span>[][] graph,<span class="keyword">int</span>[] color,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(color[index]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> color[index]==<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        color[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:graph[index])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!safe(graph,color,x))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        color[index] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="847-访问所有节点的最短路径"><a href="#847-访问所有节点的最短路径" class="headerlink" title="847. 访问所有节点的最短路径"></a><a href="https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/">847. 访问所有节点的最短路径</a></h1><p>存在一个由 n 个节点组成的无向连通图，图中的节点按从 0 到 n - 1 编号。</p>
<p>给你一个数组 graph 表示这个图。其中，graph[i] 是一个列表，由所有与节点 i 直接相连的节点组成。</p>
<p>返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。</p>
<p><img src="/2021/08/05/leetcode-%E5%9B%BE%E7%9B%B8%E5%85%B3/image-20210806105902911.png" alt="847-1" style="zoom:67%;"><img src="/2021/08/05/leetcode-%E5%9B%BE%E7%9B%B8%E5%85%B3/image-20210806105915015.png" alt="847-2" style="zoom:67%;"></p>
<p>提示：</p>
<p>n == graph.length</p>
<p>1 &lt;= n &lt;= 12</p>
<p>0 &lt;= graph[i].length &lt; n</p>
<p>graph[i] 不包含 i</p>
<p>如果 graph[a] 包含 b ，那么 graph[b] 也包含 a</p>
<p>输入的图总是连通图。</p>
<h2 id="知识点：图、bfs、状态压缩dp"><a href="#知识点：图、bfs、状态压缩dp" class="headerlink" title="知识点：图、bfs、状态压缩dp"></a>知识点：图、bfs、状态压缩dp</h2><h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><p>（其实这个题目我没明白透彻），要找到经过所有节点的最短路径，采用bfs的话，第一次找到的所有节点都被访问过的路径即为最短路径；</p>
<p>我们需要建立一个三维数组，第一维存放当前位于的节点；第二维存放到这个节点为止已经经过了哪些节点（这个用一个数字表示，但是采用的是二进制）；第三维存放到这个节点为止，距离是多少</p>
<p>除此之外，还得建立个数组，用于区分哪些节点已经访问过了</p>
<p>最后，细看<a href="https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/solution/fang-wen-suo-you-jie-dian-de-zui-duan-lu-mqc2/">题解</a>。</p>
<h2 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPathLength</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][<span class="number">1</span>&lt;&lt;n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,<span class="number">1</span>&lt;&lt;i,<span class="number">0</span>&#125;);</span><br><span class="line">            seen[i][<span class="number">1</span>&lt;&lt;i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] tuple = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> u = tuple[<span class="number">0</span>],mask = tuple[<span class="number">1</span>],dist = tuple[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(mask==(<span class="number">1</span>&lt;&lt;n)-<span class="number">1</span>)&#123;</span><br><span class="line">                ans = dist;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//搜索相邻的节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v:graph[u])&#123;</span><br><span class="line">                <span class="comment">//将mask的第v位设置为1</span></span><br><span class="line">                <span class="keyword">int</span> maskV = mask|(<span class="number">1</span>&lt;&lt;v);</span><br><span class="line">                <span class="keyword">if</span>(!seen[v][maskV])&#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;v,maskV,dist+<span class="number">1</span>&#125;);</span><br><span class="line">                    seen[v][maskV] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="457-环形数组是否存在循环"><a href="#457-环形数组是否存在循环" class="headerlink" title="457. 环形数组是否存在循环"></a><a href="https://leetcode-cn.com/problems/circular-array-loop/">457. 环形数组是否存在循环</a></h1><p>存在一个不含 0 的 环形 数组 nums ，每个 nums[i] 都表示位于下标 i 的角色应该向前或向后移动的下标个数：</p>
<p>如果 nums[i] 是正数，向前 移动 nums[i] 步</p>
<p>如果 nums[i] 是负数，向后 移动 nums[i] 步</p>
<p>因为数组是 环形 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。</p>
<p>数组中的 循环 由长度为 k 的下标序列 seq ：</p>
<p>遵循上述移动规则将导致重复下标序列 seq[0] -&gt; seq[1] -&gt; … -&gt; seq[k - 1] -&gt; seq[0] -&gt; …</p>
<p>所有 nums[seq[j]] 应当不是 全正 就是 全负</p>
<p>k &gt; 1</p>
<p>如果 nums 中存在循环，返回 true ；否则，返回 false 。</p>
<p>示例 1：</p>
<p>输入：nums = [2,-1,1,2,2]</p>
<p>输出：true</p>
<p>解释：存在循环，按下标 0 -&gt; 2 -&gt; 3 -&gt; 0 。循环长度为 3 。</p>
<p>示例 2：</p>
<p>输入：nums = [-1,2]</p>
<p>输出：false</p>
<p>解释：按下标 1 -&gt; 1 -&gt; 1 … 的运动无法构成循环，因为循环的长度为 1 。根据定义，循环的长度必须大于 1 。</p>
<p>示例 3:</p>
<p>输入：nums = [-2,1,-1,-2,-2]</p>
<p>输出：false</p>
<p>解释：按下标 1 -&gt; 2 -&gt; 1 -&gt; … 的运动无法构成循环，因为 nums[1] 是正数，而 nums[2] 是负数。</p>
<p>所有 nums[seq[j]] 应当不是全正就是全负。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 5000</p>
<p>-1000 &lt;= nums[i] &lt;= 1000</p>
<p>nums[i] != 0</p>
<p>进阶：你能设计一个时间复杂度为 O(n) 且额外空间复杂度为 O(1) 的算法吗？</p>
<h2 id="知识点：图、双指针"><a href="#知识点：图、双指针" class="headerlink" title="知识点：图、双指针"></a>知识点：图、双指针</h2><h2 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h2><p>这个题目有点，麻烦，其实也不是很麻烦。要判断有没有能不能形成环（而且长度大于1），常见做法就是快慢指针，和普通题目的不同之处在于元素分为正负两种，既然是环，那必定只能是符号相同，所以要加个符号判断；另外为了降低时间复杂度，还可以对已经判断过的元素进行标记（如果没法成环，再走到这个元素依旧没法成环）。</p>
<h2 id="代码如下：-2"><a href="#代码如下：-2" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">circularArrayLoop</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//判0是为了优化时间复杂度，去掉也是正确结果</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> slow = i,fast = next(nums,slow);</span><br><span class="line">            <span class="keyword">while</span>(nums[slow]*nums[fast]&gt;<span class="number">0</span>&amp;&amp;nums[slow]*nums[next(nums,fast)]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(slow==fast)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(slow!=next(nums,slow))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                slow = next(nums,slow);</span><br><span class="line">                fast = next(nums,next(nums,fast));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> add = i;</span><br><span class="line">            <span class="keyword">while</span>(nums[add]*nums[next(nums,add)]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = add;</span><br><span class="line">                add = next(nums,add);</span><br><span class="line">                nums[tmp] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">return</span> ((cur+nums[cur])%n+n)%n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>dfs、图</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-丑数</title>
    <url>/2021/08/09/leetcode-%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h1 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263. 丑数"></a><a href="https://leetcode-cn.com/problems/ugly-number/">263. 丑数</a></h1><p>给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。</p>
<p>丑数 就是只包含质因数 2、3 和/或 5 的正整数。</p>
<p>示例 1：</p>
<p>输入：n = 6</p>
<p>输出：true</p>
<p>解释：6 = 2 × 3</p>
<p>示例 2：</p>
<p>输入：n = 8</p>
<p>输出：true</p>
<p>解释：8 = 2 × 2 × 2</p>
<p>示例 3：</p>
<p>输入：n = 14</p>
<p>输出：false</p>
<p>解释：14 不是丑数，因为它包含了另外一个质因数 7 。</p>
<p>示例 4：</p>
<p>输入：n = 1</p>
<p>输出：true</p>
<p>解释：1 通常被视为丑数。</p>
<h2 id="知识点：dfs"><a href="#知识点：dfs" class="headerlink" title="知识点：dfs"></a>知识点：dfs</h2><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>简单题目，没啥好分析的。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(n/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(n/<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(n/<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a><a href="https://leetcode-cn.com/problems/ugly-number-ii/"><strong>264.</strong> <strong>丑数</strong> <strong>II</strong></a></h2><p>给你一个整数 n ，请你找出并返回第 n 个 <strong>丑数</strong> 。</p>
<p><strong>丑数</strong> 就是只包含质因数 2、3 和/或 5 的正整数。</p>
<p><strong>示例 1：</strong></p>
<p> 输入：n = 10</p>
<p> 输出：12</p>
<p> 解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</p>
<h2 id="知识点：dp"><a href="#知识点：dp" class="headerlink" title="知识点：dp"></a><strong>知识点：dp</strong></h2><h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a><strong>分析：</strong></h2><p>这个可以用dp解决，也不复杂。</p>
<h2 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a><strong>代码如下：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        res[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//这个三个dp是指针，代表位置</span></span><br><span class="line">        <span class="keyword">int</span> dp2=<span class="number">1</span>,dp3=<span class="number">1</span>,dp5=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num2,num3,num5;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            num2=res[dp2]*<span class="number">2</span>;</span><br><span class="line">            num3=res[dp3]*<span class="number">3</span>;</span><br><span class="line">            num5=res[dp5]*<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">int</span> num=Math.min(Math.min(num2, num3),num5);</span><br><span class="line">            <span class="keyword">if</span>(num==num2)&#123;</span><br><span class="line">                res[i]=num2;</span><br><span class="line">                dp2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num==num3)&#123;</span><br><span class="line">                res[i]=num3;</span><br><span class="line">                dp3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num==num5)&#123;</span><br><span class="line">                res[i]=num5;</span><br><span class="line">                dp5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="313-超级丑数"><a href="#313-超级丑数" class="headerlink" title="313. 超级丑数"></a><a href="https://leetcode-cn.com/problems/super-ugly-number/">313. 超级丑数</a></h1><p>超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。</p>
<p>给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。</p>
<p>题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。</p>
<p>示例 1：</p>
<p>输入：n = 12, primes = [2,7,13,19]</p>
<p>输出：32 </p>
<p>解释：给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。</p>
<p>示例 2：</p>
<p>输入：n = 1, primes = [2,3,5]</p>
<p>输出：1</p>
<p>解释：1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。</p>
<p>提示：</p>
<p>1 &lt;= n &lt;= 106</p>
<p>1 &lt;= primes.length &lt;= 100</p>
<p>2 &lt;= primes[i] &lt;= 1000</p>
<p>题目数据 保证 primes[i] 是一个质数</p>
<p>primes 中的所有值都 互不相同 ，且按 递增顺序 排列</p>
<h2 id="知识点：动态规划"><a href="#知识点：动态规划" class="headerlink" title="知识点：动态规划"></a>知识点：动态规划</h2><h2 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h2><p>这个和丑数II如出一辙，只有质因数的个数变化。</p>
<h2 id="代码如下：-2"><a href="#代码如下：-2" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] primes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = primes.length;</span><br><span class="line">        <span class="keyword">int</span>[] indexes = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Arrays.fill(indexes,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] tmpNums = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">                tmpNums[j] = res[indexes[j]]*primes[j];</span><br><span class="line">                min = Math.min(min,tmpNums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = min;</span><br><span class="line">            <span class="comment">//这里要一个个检查，所有和最小值相等的索引都要++</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmpNums[j]==min)&#123;</span><br><span class="line">                    indexes[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-泰波那契</title>
    <url>/2021/08/08/leetcode-%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91/</url>
    <content><![CDATA[<h1 id="1137-第-N-个泰波那契数"><a href="#1137-第-N-个泰波那契数" class="headerlink" title="1137. 第 N 个泰波那契数"></a><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></h1><p>泰波那契序列 Tn 定义如下： </p>
<p>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2</p>
<p>给你整数 n，请返回第 n 个泰波那契数 Tn 的值。</p>
<p>示例 1：</p>
<p>输入：n = 4</p>
<p>输出：4</p>
<p>解释：</p>
<p>T_3 = 0 + 1 + 1 = 2</p>
<p>T_4 = 1 + 1 + 2 = 4</p>
<p>示例 2：</p>
<p>输入：n = 25</p>
<p>输出：1389537</p>
<p>提示：</p>
<p>0 &lt;= n &lt;= 37</p>
<p>答案保证是一个 32 位整数，即 answer &lt;= 2^31 - 1。</p>
<h2 id="知识点：动态规划"><a href="#知识点：动态规划" class="headerlink" title="知识点：动态规划"></a>知识点：动态规划</h2><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>注意优化时间。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tribonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fir = <span class="number">0</span>,sec = <span class="number">0</span>,thr = <span class="number">1</span>,ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            fir = sec;</span><br><span class="line">            sec = thr;</span><br><span class="line">            thr = ans;</span><br><span class="line">            ans = fir+sec+thr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-等差数列</title>
    <url>/2021/08/10/leetcode-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413. 等差数列划分"></a><a href="https://leetcode-cn.com/problems/arithmetic-slices/">413. 等差数列划分</a></h1><p>如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p>
<p>例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。</p>
<p>给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的子数组个数。</p>
<p>子数组 是数组中的一个连续序列。</p>
<p>示例 1：</p>
<p>输入：nums = [1,2,3,4]</p>
<p>输出：3</p>
<p>解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。</p>
<p>示例 2：</p>
<p>输入：nums = [1]</p>
<p>输出：0</p>
<p><strong>提示：</strong></p>
<ul>
<li>1     &lt;= nums.length &lt;= 5000</li>
<li>-1000     &lt;= nums[i] &lt;= 1000</li>
</ul>
<h2 id="知识点：动态规划"><a href="#知识点：动态规划" class="headerlink" title="知识点：动态规划"></a>知识点：动态规划</h2><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>这个看看<a href="https://leetcode-cn.com/problems/arithmetic-slices/solution/deng-chai-shu-lie-hua-fen-by-leetcode-so-g7os/">题解</a>吧，我没有需要补充的。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">0</span>,count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">2</span>]-nums[i-<span class="number">1</span>]==nums[i-<span class="number">1</span>]-nums[i])&#123;</span><br><span class="line">                ++dp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count += dp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="446-等差数列划分-II-子序列"><a href="#446-等差数列划分-II-子序列" class="headerlink" title="446. 等差数列划分 II - 子序列"></a><a href="https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/">446. 等差数列划分 II - 子序列</a></h1><p>给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。</p>
<p>如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。</p>
<p>例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。</p>
<p>再例如，[1, 1, 2, 5, 7] 不是等差序列。</p>
<p>数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。</p>
<p>例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。</p>
<p>题目数据保证答案是一个 32-bit 整数。</p>
<p>示例 1：</p>
<p>输入：nums = [2,4,6,8,10]</p>
<p>输出：7</p>
<p>解释：所有的等差子序列为：</p>
<p>[2,4,6]</p>
<p>[4,6,8]</p>
<p>[6,8,10]</p>
<p>[2,4,6,8]</p>
<p>[4,6,8,10]</p>
<p>[2,4,6,8,10]</p>
<p>[2,6,10]</p>
<p>示例 2：</p>
<p>输入：nums = [7,7,7,7,7]</p>
<p>输出：16</p>
<p>解释：数组中的任意子序列都是等差子序列。</p>
<p><strong>提示：</strong></p>
<ul>
<li>1      &lt;= nums.length &lt;= 1000</li>
<li>-231 &lt;= nums[i] &lt;= 231 - 1</li>
</ul>
<h2 id="知识点：动态规划-1"><a href="#知识点：动态规划-1" class="headerlink" title="知识点：动态规划"></a>知识点：动态规划</h2><h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><p>这是上一道题目的进阶版：子序列可以是不连续的。挺复杂的，看看<a href="https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/solution/deng-chai-shu-lie-hua-fen-ii-zi-xu-lie-b-77pl/">题解</a>吧。</p>
<h2 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,len = nums.length;</span><br><span class="line">        Map&lt;Long,Integer&gt;[] hash = <span class="keyword">new</span> Map[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            hash[i] = <span class="keyword">new</span> HashMap&lt;Long,Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">long</span> d = <span class="number">1L</span>*nums[i]-nums[j];</span><br><span class="line">                <span class="keyword">int</span> count = hash[j].getOrDefault(d, <span class="number">0</span>);</span><br><span class="line">                ans+=count;</span><br><span class="line">                hash[i].put(d,hash[i].getOrDefault(d, <span class="number">0</span>)+count+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-二叉树的右视图</title>
    <url>/2021/08/11/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<h2 id="知识点：bfs、dfs、树"><a href="#知识点：bfs、dfs、树" class="headerlink" title="知识点：bfs、dfs、树"></a><strong>知识点：bfs、dfs、树</strong></h2><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析：</strong></h2><p>本题可用dfs或bfs两种解法，bfs的话，就是每层遍历到最后一个节点的时候，将该节点的值加入返回队列；dfs的话，按照根-&gt;右子树-&gt;左子树的顺序来，每当深度更新时，就把第一个遍历到的节点的值加入返回值。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a><strong>代码如下：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; nodes=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            nodes.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!nodes.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size=nodes.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode tmpNode=nodes.poll();</span><br><span class="line">                <span class="keyword">if</span>(tmpNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    nodes.offer(tmpNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmpNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    nodes.offer(tmpNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i==size-<span class="number">1</span>)&#123;</span><br><span class="line">                    res.add(tmpNode.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dept=<span class="number">0</span>;</span><br><span class="line">        dfs(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node,<span class="keyword">int</span> dept)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dept==res.size())&#123;<span class="comment">//如果当前深度和返回值数量相等，说明未包含该层</span></span><br><span class="line">            res.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dept++;</span><br><span class="line">        dfs(node.right,dept);</span><br><span class="line">        dfs(node.left,dept);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>dfs、bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode数字1的个数</title>
    <url>/2021/08/13/leetcode-%E6%95%B0%E5%AD%971%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>n = 13<br> <strong>输出：</strong>6</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>n = 0<br> <strong>输出：</strong>0</p>
<h2 id="知识点：动态规划"><a href="#知识点：动态规划" class="headerlink" title="知识点：动态规划"></a>知识点：动态规划</h2><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p><a href="https://leetcode-cn.com/problems/number-of-digit-one/solution/shu-zi-1-de-ge-shu-by-leetcode-solution-zopq/">题解</a>从每个数位可能出现1的情况做了分析，进而推广到每个数位；最后将每个数位出现1的个数相加起来。</p>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> mulk = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k =<span class="number">0</span>;n&gt;=mulk;k++)&#123;</span><br><span class="line">            ans += (n/(mulk*<span class="number">10</span>))*mulk+Math.min(Math.max(n%(mulk*<span class="number">10</span>)-mulk+<span class="number">1</span>,<span class="number">0</span>),mulk);</span><br><span class="line">            mulk*=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
