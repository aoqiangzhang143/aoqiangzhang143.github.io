{"meta":{"title":"Mithrandir","subtitle":"将此博客当作一路成长走过的路。","description":"且将新火试新茶，诗酒趁年华","author":"aoqiangzhang143","url":"http://example.com","root":"/"},"pages":[{"title":"archives","date":"2021-05-27T01:33:43.000Z","updated":"2021-05-27T01:33:43.928Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-05-26T13:31:13.000Z","updated":"2021-05-27T01:36:57.220Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"公益404","date":"2021-05-27T01:34:24.000Z","updated":"2021-05-27T01:37:28.781Z","comments":true,"path":"commonweal/index.html","permalink":"http://example.com/commonweal/index.html","excerpt":"","text":""},{"title":"日程表","date":"2021-05-27T01:34:01.000Z","updated":"2021-05-27T01:37:49.200Z","comments":true,"path":"schedule/index.html","permalink":"http://example.com/schedule/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-05-26T13:30:53.000Z","updated":"2021-05-27T01:36:04.485Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"站点地图","date":"2021-05-27T01:34:10.000Z","updated":"2021-05-27T01:38:10.193Z","comments":true,"path":"sitemap/index.html","permalink":"http://example.com/sitemap/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2021-05-26T11:13:32.332Z","updated":"2021-05-26T11:13:32.332Z","comments":true,"path":"2021/05/26/hello-world/","link":"","permalink":"http://example.com/2021/05/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"搜索算法","slug":"搜索算法","date":"2021-05-25T16:00:00.000Z","updated":"2021-05-27T02:25:22.120Z","comments":true,"path":"2021/05/26/搜索算法/","link":"","permalink":"http://example.com/2021/05/26/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/","excerpt":"","text":"有序表查找二分查找代码如下：123456789101112131415public int binarySearch(int[] arr,int target)&#123; int low=0,height=arr.length-1; int mid; while(low&lt;=height)&#123; mid=(low+height)/2; if(arr[mid]&lt;target)&#123; low=mid+1; &#125;else if(arr[mid]&gt;target)&#123; height=mid-1; &#125;else&#123; return mid; &#125; &#125; return -1;&#125; 插值查找适用于数值分布均匀的查找表。 代码如下：123456789101112131415public int binarySearch(int[] arr,int target)&#123; int low=0,height=arr.length-1; int mid; while(low&lt;=height)&#123; mid=low+(hight-low)(arr[mid]-arr[low])/(arr[height]-arr[low]); if(arr[mid]&lt;target)&#123; low=mid+1; &#125;else if(arr[mid]&gt;target)&#123; height=mid-1; &#125;else&#123; return mid; &#125; &#125; return -1;&#125; 斐波那契查找利用了斐波那契数列 12345678910111213141516171819202122232425262728293031323334353637383940414243 public static int fibSearch(int[] arr,int target)&#123; int low=0,heigh=arr.length-1; int[] f=fib(); //k为合适的斐波那契数 int k=0; while(heigh&gt;f[k]-1)&#123; ++k; &#125; //定义斐波那契数长度的数组 int[] nums = Arrays.copyOf(arr, f[k]); for(int i=heigh;i&lt;f[k];i++)&#123; nums[i]=nums[heigh]; &#125; int mid; while (low&lt;=heigh)&#123; mid=low+f[k-1]-1; if(target&gt;arr[mid])&#123; k-=2; low=mid+1; &#125;else if(target&lt;arr[mid])&#123; --k; heigh=mid-1; &#125;else&#123; if(mid&lt;heigh)&#123; return mid; &#125;else&#123; return heigh; &#125; &#125; &#125; return -1; &#125;//创建一个斐波那契数列public static int[] fib()&#123; int[] f=new int[20]; f[0]=1; f[1]=1; for(int i=2;i&lt;20;i++)&#123; f[i]=f[i-1]+f[i-2]; &#125; return f; &#125;","categories":[{"name":"HelloWorld系列","slug":"HelloWorld系列","permalink":"http://example.com/categories/HelloWorld%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://example.com/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"排序算法总结","slug":"排序算法","date":"2021-05-25T16:00:00.000Z","updated":"2021-05-27T02:24:53.339Z","comments":true,"path":"2021/05/26/排序算法/","link":"","permalink":"http://example.com/2021/05/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"冒泡排序简析：比较相邻的两个元素，如果当前数字比后面的数字大，就交换位置 下列代码做了改进，从数组的末尾开始比较，除了能将最小元素移动至第一位外，还将第二小的元素尽可能的移动至靠近适合它的位置。 123456789101112public void bubbleSort(int[] arr)&#123; int i,j,len=arr.length-1; for(i=0;i&lt;len;i++)&#123; for(j=len-1;j&gt;=i;--j)&#123; if(arr[j]&gt;arr[j+1])&#123; int tmp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=tmp; &#125; &#125; &#125;&#125; 选择排序简析：在未排序的序列中，找到最小的元素，放到排列元素的起始位置；然后再从未排序的序列中找到最小的元素，放到已排序序列的末尾，依次类推，直至末尾。 1234567891011121314public void selectSort(int[] arr)&#123; int minIndex; for(int i=0;i&lt;arr.length;i++)&#123; minIndex=i; for(int j=i;j&lt;arr.length;j++)&#123; if(arr[j]&lt;arr[minIndex])&#123; minIndex=j; &#125; &#125; int tmp=arr[minIndex]; arr[minIndex]=arr[i]; arr[i]=tmp; &#125;&#125; 插入排序简析：对于未排序的序列，在已排序的序列中从后往前扫描，找到合适的位置并插入。 123456789101112public void InsertSort(int[] arr)&#123; int len=arr.length; for(int i=1;i&lt;len;i++)&#123; int insertVal=arr[i];//要插入的值 int insertIndex=i-1;//要插入的值的前一个坐标 while(inserIndex&gt;=0&amp;&amp;insertVal&lt;arr[insertIndex])&#123; arr[insertIndex+1]=arr[insertIndex]; intsertIndex--; &#125;//跳出循环时说明要插入的位置在insertIndex后面 arr[insertIndex+1]=insertVal; &#125;&#125; 希尔排序简析：希尔排序是插入排序的优化版，通过设置不同的步长并逐步减少步长，以步长为单次移动距离，可大幅缩短所需时间。 12345678910111213141516171819public void shellSort(int[] arr)&#123; int len=arr.length; for(int step=len/2;step&gt;0;step/=2)&#123; for(int i=step;i&lt;len;i++)&#123; //记录下要移动的元素下标 int tmpIndex=i; //记录下要移动的元素值 int tmpVal=arr[tmpIndex]; //如果需要移动，那就移动至合适的位置 if(tmpVal&lt;arr[tmmIndex-step])&#123; while(temIndex-step&gt;=0&amp;&amp;tmpVal&lt;arr[tmpIndex-step])&#123; arr[tmpIndex]=arr[tmpIndex-step]; tmpIndex-=step; &#125; &#125;//tmpIndex已经是合适的位置 arr[tmpIndex]=tmpVal; &#125; &#125;&#125; 归并排序简析：将已有序的子序列合并；起始默认单个元素既是一个有序序列。 12345678910111213141516171819202122232425262728293031323334353637383940public class MergeSort &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;8, 4, 5, 7, 1, 3, 6, 2&#125;; int[] tmp = new int[arr.length]; sort(arr,0,arr.length-1,tmp); System.out.println(Arrays.toString(arr)); &#125; private static void sort(int[] arr,int left,int right,int[] tmp) &#123; if(left&gt;=right)&#123; return; &#125; int mid=left+(right-left)/2; sort(arr, left,mid,tmp); sort(arr, mid+1, right,tmp); if(arr[mid]&lt;=arr[mid+1])&#123; return; &#125; merge(arr,left,right,mid,tmp); &#125; private static void merge(int[] arr, int left, int right, int mid,int[] tmp) &#123; int i=left; int j=mid+1; for (int k = left; k &lt;= right; k++) &#123; tmp[k]=arr[k]; &#125; for(int k=left ;k&lt;=right;k++)&#123; if(i==mid+1)&#123; arr[k]=tmp[j++]; &#125;else if(j==right+1)&#123; arr[k]=tmp[i++]; &#125;else if(tmp[i]&lt;=tmp[j])&#123; arr[k]=tmp[i++]; &#125;else&#123; arr[k]=tmp[j++]; &#125; &#125; &#125;&#125; 快速排序简析：通过指定一个pivot，使得数组以pivot为基准，大于pivot的都移动至pivot右边，小于pivot的都移动至其左边，然后对pivot两边的数组再次进行递归排序即可。 123456789101112131415161718192021222324public vodi quickSort(int[] arr,int l,int r)&#123; if(l&lt;r)&#123; int left=l,right=r; int pivot=arr[l]; while(left&lt;right)&#123; while(left&lt;right&amp;&amp;arr[right]&gt;=pivot)&#123;//先找到一个需要移动的right。 //注意，此处必须先寻找right，因为left位置的元素已经取出（就是pivot），所以可以先对left的位置赋值 --right; &#125; if(left&lt;right)&#123; arr[left++]=arr[right]； &#125; while(left&lt;right&amp;&amp;arr[left]&lt;=pivot)&#123; ++left; &#125; if(left&lt;right)&#123; arr[right--]=arr[left]; &#125; &#125; arr[right]=pivot;//这个赋值给left或者right都可以 quickSort(arr,l,right-1); quickSort(arr,right+1,r); &#125;&#125; 代码2： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @author Mithrandir * @date 2021-03-2021/3/27-21:36 */public class QuickSortAnother &#123; public static void main(String[] args) &#123; int[] arr=&#123;1,6,5,4,3,2,9,1&#125;; quicksort(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); &#125; /** * 随机将一个数字放至其合适的位置，并对该位置左右两区间进行排序 * @param arr 待排序的数组 * @param left 数组的左端 * @param right 数组的右端 */ private static void quicksort(int[] arr,int left,int right) &#123; if(left&gt;=right)&#123; return; &#125; int mid=partition(arr,left,right); quicksort(arr, left, mid-1); quicksort(arr, mid+1, right); &#125; /** * 这个要完成的功能是对数组内的一个随机数字安排至合适的位置，并以该位置为根据将数组分为左右区间 * @param arr * @param left * @param right * @return */ private static int partition(int[] arr, int left, int right) &#123; Random random = new Random(); //来区间内位置的一个随机位置 int tmpIndex=random.nextInt(right-left+1)+left; //将该位置的数字放到数组的最右侧 swap(arr,tmpIndex,right); //定义一个索引 int index=left; for(int i=left;i&lt;right;i++)&#123; if(arr[i]&lt;arr[right])&#123;//凡是小于我们的随机数的值，一律从左开始排 swap(arr, i, index++); &#125; &#125; //此时，index左侧的所有值，均小于随机数，将随机数放到index的位置 swap(arr,index, right); return index; &#125; private static void swap(int[] arr, int i, int j) &#123; int tmp=arr[i]; arr[i]=arr[j]; arr[j]=tmp; &#125;&#125; 计数排序简析：计数排序适用于元素数值较为集中，且元素要是确定范围内的整数 123456789101112131415161718192021222324252627282930313233public void countingSort(int[] arr)&#123; if(arr.length==0)&#123; return; &#125; //找到arr里的最大最小值 int min=arr[0],max=arr[0]; for(int i=1;i&lt;arr.length;i++)&#123; if(arr[i]&gt;max)&#123; max=arr[i]; &#125; if(arr[i]&lt;min)&#123; min=arr[i]; &#125; &#125; //定义一个关键值 int bias=0-min; //准备一个额外数组 int[] bucket=new int[max-min+1]; //遍历整个数组，记录每个元素出现的次数 for(int i=0;i&lt;arr.length;i++)&#123; bucket[arr[i]+bias]++; &#125; //接下来准备重新排列arr,index为arr的索引，i为bucket的索引 int index=0,i=0; while(index&lt;arr.length)&#123; if(bucket[i]!=0)&#123; arr[index++]=i-bias; bucket[i]--; &#125;else&#123; i++; &#125; &#125;&#125; 基数排序简析：基数和计数都是用了桶来进行排序，不同的是，基数对所有元素的分配做了优化：按照每个元素的同一位（即个位，十位等）进行摆放，也就是说，所用到的桶一共有10层（0~9），在一轮循环中，每一层放的数据在某一位都相同。基数排序用的空间取决于元素的个数，而计数排序所用的额外空间取决于元素的范围（即最小-最大）。 123456789101112131415161718192021222324252627282930313233343536373839public static void review(int[] arr) &#123; //第一步，先找到数组中的最大值 int size = arr.length; int max = arr[0]; for (int i = 1; i &lt; size; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; //根据最大值找到最大长度 String str = max + &quot;&quot;; int maxLength = str.length(); //创建一个桶，用于盛放处理后的数组 int[][] bucket = new int[10][size]; //还得创建一个计数器，用于计算每个位置放了多少个数据 int[] numsCounter = new int[10]; //接下来就进入每一层的操作：放入桶，从桶中取出 //定义两个变量，k用于确定数据的哪一层，m用于对每个数据进行取余操作 for (int k = 0, m = 1; k &lt; maxLength; m *= 10, k++) &#123; //先将数据取出，根据个（十、百）位数的大小放入桶中 for (int i = 0; i &lt; size; i++) &#123; //取出个位 int num = arr[i] / m % 10; //放入个位对应的桶中 bucket[num][numsCounter[num]++] = arr[i]; &#125; //此时已完成所有数据入桶,按照顺序将其取出 //定义一个索引，用于在arr中重新排序 int index = 0; for (int i = 0; i &lt; bucket.length; i++) &#123; if (numsCounter[i] != 0) &#123;//i的取值范围是0~9，numsCounter[i]!=0说明该位置存放的有数据，需要取出 for (int j = 0; j &lt; numsCounter[i]; j++) &#123; arr[index++] = bucket[i][j]; &#125; &#125; numsCounter[i] = 0; &#125; &#125; &#125;","categories":[{"name":"HelloWorld系列","slug":"HelloWorld系列","permalink":"http://example.com/categories/HelloWorld%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"}]}],"categories":[{"name":"HelloWorld系列","slug":"HelloWorld系列","permalink":"http://example.com/categories/HelloWorld%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://example.com/tags/%E6%90%9C%E7%B4%A2/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"}]}