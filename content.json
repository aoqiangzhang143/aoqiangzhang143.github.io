{"meta":{"title":"Mithrandir","subtitle":"将此博客当作一路成长走过的路。","description":"且将新火试新茶，诗酒趁年华","author":"aoqiangzhang143","url":"http://example.com","root":"/"},"pages":[{"title":"archives","date":"2021-05-27T01:33:43.000Z","updated":"2021-05-27T01:33:43.928Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-05-26T13:31:13.000Z","updated":"2021-05-27T01:36:57.220Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"公益404","date":"2021-05-27T01:34:24.000Z","updated":"2021-05-27T01:37:28.781Z","comments":true,"path":"commonweal/index.html","permalink":"http://example.com/commonweal/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-05-26T13:30:53.000Z","updated":"2021-05-27T01:36:04.485Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"日程表","date":"2021-05-27T01:34:01.000Z","updated":"2021-05-27T01:37:49.200Z","comments":true,"path":"schedule/index.html","permalink":"http://example.com/schedule/index.html","excerpt":"","text":""},{"title":"站点地图","date":"2021-05-27T01:34:10.000Z","updated":"2021-05-27T01:38:10.193Z","comments":true,"path":"sitemap/index.html","permalink":"http://example.com/sitemap/index.html","excerpt":"","text":""},{"title":"","date":"2021-05-27T08:19:00.191Z","updated":"2021-05-27T08:19:00.191Z","comments":true,"path":"lib/canvas-ribbon/README.html","permalink":"http://example.com/lib/canvas-ribbon/README.html","excerpt":"","text":"canvas-ribbon.js for NexT Installation If you want to use the CDN instead of clone this repo, please jump to the Step 3. Step 1 &rarr; Go to NexT dir Change dir to NexT directory. There must be layout, source, languages and other directories: 123$ cd themes/next$ ls_config.yml crowdin.yml docs gulpfile.js languages layout LICENSE.md package.json README.md scripts source Step 2 &rarr; Get module Install module to source/lib directory: 1$ git clone https://github.com/theme-next/theme-next-canvas-ribbon source/lib/canvas-ribbon Step 3 &rarr; Set it up Enable module in NexT _config.yml file: 12canvas_ribbon: enable: true And, if you wants to use the CDN, then need to set: 123vendors: ... canvas_ribbon: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js Update 12$ cd themes/next/source/lib/canvas-ribbon$ git pull"},{"title":"","date":"2021-05-27T08:19:00.192Z","updated":"2021-05-27T08:19:00.192Z","comments":true,"path":"lib/canvas-ribbon/canvas-ribbon.js","permalink":"http://example.com/lib/canvas-ribbon/canvas-ribbon.js","excerpt":"","text":"/** * Copyright (c) 2016 hustcc * License: MIT * Version: v1.0.1 * GitHub: https://github.com/hustcc/ribbon.js **/ /*jshint -W030 */ ! function() { function attr(node, attr, default_value) { return Number(node.getAttribute(attr)) || default_value; } // get user config var scripts = document.getElementsByTagName('script'), script = scripts[scripts.length - 1]; // 当前加载的script config = { z: attr(script, \"zIndex\", -1), // z-index a: attr(script, \"alpha\", 0.6), // alpha s: attr(script, \"size\", 90), // size }; var canvas = document.createElement('canvas'), g2d = canvas.getContext('2d'), pr = window.devicePixelRatio || 1, width = window.innerWidth, height = window.innerHeight, f = config.s, q, t, m = Math, r = 0, pi = m.PI*2, cos = m.cos, random = m.random; canvas.width = width * pr; canvas.height = height * pr; g2d.scale(pr, pr); g2d.globalAlpha = config.a; canvas.style.cssText = 'opacity: ' + config.a + ';position:fixed;top:0;left:0;z-index: ' + config.z + ';width:100%;height:100%;pointer-events:none;'; // create canvas document.getElementsByTagName('body')[0].appendChild(canvas); function redraw() { g2d.clearRect(0, 0, width, height); q = [{x: 0, y: height * 0.7 + f}, {x: 0, y: height * 0.7 - f}]; while(q[1].x < width + f) draw(q[0], q[1]); } function draw(i, j) { g2d.beginPath(); g2d.moveTo(i.x, i.y); g2d.lineTo(j.x, j.y); var k = j.x + (random()*2-0.25)*f, n = line(j.y); g2d.lineTo(k, n); g2d.closePath(); r -= pi / -50; g2d.fillStyle = '#'+(cos(r)*127+128"},{"title":"","date":"2021-05-27T04:33:51.869Z","updated":"2021-05-27T04:33:51.869Z","comments":true,"path":"lib/bookmark/README.html","permalink":"http://example.com/lib/bookmark/README.html","excerpt":"","text":"Bookmark for NexT Introduce Bookmark is a plugin that allow the users save their reading position. The users could just click the bookmark icon (like 🔖) in left-top of the page to save the position. And when they visit your blog in the next time, they can continue the last reading position by clicking the bookmark icon from the home page. Installation If you want to use the CDN instead of clone this repo, please jump to the Step 3. Step 1 &rarr; Go to NexT dir Change dir to NexT directory. There must be layout, source, languages and other directories: 123$ cd themes/next$ lsbower.json _config.yml docs gulpfile.coffee languages layout LICENSE.md package.json README.md scripts source test Step 2 &rarr; Get module Install module to source/lib directory: 1$ git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark Step 3 &rarr; Set it up Enable module in NexT _config.yml file: 1bookmark: true And, if you wants to use the CDN, then need to set: 123vendors: ... bookmark: https://cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@latest/bookmark.min.js Update 12$ cd themes/next/source/lib/bookmark$ git pull"},{"title":"","date":"2021-05-27T04:33:51.870Z","updated":"2021-05-27T04:33:51.870Z","comments":true,"path":"lib/bookmark/bookmark.min.js","permalink":"http://example.com/lib/bookmark/bookmark.min.js","excerpt":"","text":"!function(o){\"use strict\";var n=o.localStorage;null==n&&(n={getItem:function(){return null},setItem:function(){},removeItem:function(){},clear:function(){}});var t,e=function(){var o=n.getItem(\"bookmark\");if(null==o)return null;try{return JSON.parse(o)}catch(o){return null}},a=function(){var n=o.document.createElement(\"style\");n.type=\"text/css\";var e=\".book-mark-link{border-bottom:none;display:block;position:fixed;color:#222;font-size:26px !important;top:-10px;left:20px;transition:.3s;}.book-mark-link:hover,.book-mark-link-fixed{top:-2px}@media(max-width:1090px){.book-mark-link{display:none}}\";e=o.document.createTextNode(e),n.appendChild(e),o.document.head.appendChild(n),t=$(''),$(o.document.body).append(t);var a=0;$(o).on(\"scroll.bookmark\",function(){var n=o.document.documentElement.scrollTop;n>0?0===a&&(t.removeClass(\"book-mark-link-fixed\"),a=n):a>0&&(!t.hasClass(\"book-mark-link-fixed\")&&t.addClass(\"book-mark-link-fixed\"),a=0)})},r=function(e,a){null==a&&(a={});var r=o.document.documentElement.scrollTop;return a.lastUri=e,a[e]=r,n.setItem(\"bookmark\",JSON.stringify(a)),t.animate({top:-26},\"fast\",function(){setTimeout(function(){t.css(\"top\",\"\")},400)}),a};o.bookmark={loadBookmark:function(){var o=e();null!=o&&$(function(){a(),t.attr(\"href\",o.lastUri+\"#book:mark\")})},scrollToMark:function(n,l){var i=o.location.pathname,c=e();$(function(){var e;a(),t.click(function(){return c=r(i,c),!1}),\"auto\"===n&&o.addEventListener(\"beforeunload\",function(){r(i,c)}),null!=c&&([l,\"#comments\"].filter(function(n){return n===o.location.hash}).length>0||(e=c[i],isNaN(e)||$(function(){$(o.document.documentElement).animate({scrollTop:e},\"fast\")})))})}}}(window);"},{"title":"","date":"2021-05-27T04:33:51.870Z","updated":"2021-05-27T04:33:51.870Z","comments":true,"path":"lib/bookmark/index.js","permalink":"http://example.com/lib/bookmark/index.js","excerpt":"","text":"(function (global) { 'use strict'; var storage = global.localStorage; if (storage == null) { // if the localStorage is not exists storage = { // eslint-disable-next-line getItem: function () { return null }, setItem: function () { }, removeItem: function () { }, clear: function () { }, }; } // get the saved bookmark object var getBookmark = function () { var mark = storage.getItem('bookmark'); if (mark == null) { return null; } try { return JSON.parse(mark); } catch (e) { // invalid object saved in the storage // console.warn('Invalid bookmark object.'); return null; } }; var link; // register everything var init = function () { // bookmark-link style var style = global.document.createElement('style'); style.type = 'text/css'; var text = '.book-mark-link{' + 'border-bottom:none;' + 'display:block;' + 'position:fixed;' + 'color:#222;' + 'font-size:26px !important;' + 'top:-10px;left:20px;' + 'transition:.3s;' + '}' + '.book-mark-link:hover,.book-mark-link-fixed{top:-2px}' // do not show when the width is not enough + '@media(max-width:1090px){.book-mark-link{display:none}}'; text = global.document.createTextNode(text); style.appendChild(text); global.document.head.appendChild(style); // create a link element // eslint-disable-next-line max-len link = $(''); $(global.document.body).append(link); var currentTop = 0; // scroll event $(global).on('scroll.bookmark', function () { var top = global.document.documentElement.scrollTop; if (top > 0) { if (currentTop === 0) { link.removeClass('book-mark-link-fixed'); currentTop = top; } } else { if (currentTop > 0) { !link.hasClass('book-mark-link-fixed') && link.addClass('book-mark-link-fixed'); currentTop = 0; } } }); }; var loadBookmark = function () { var mark = getBookmark(); if (mark == null) { return; } // found the bookmark $(function () { init(); link.attr('href', mark.lastUri + '#book:mark'); }); }; var doScroll = function (top) { if (!isNaN(top)) { $(function () { // eslint-disable-next-line max-len $(global.document.documentElement).animate({ 'scrollTop': top }, 'fast'); }); } }; var doSaveScroll = function (path, mark) { if (mark == null) { mark = {}; } var top = global.document.documentElement.scrollTop; mark.lastUri = path; mark[path] = top; storage.setItem('bookmark', JSON.stringify(mark)); link.animate({ top: -26 }, 'fast', function () { setTimeout(function () { link.css('top', ''); }, 400); }); return mark; }; var scrollToMark = function (trigger, hash) { var path = global.location.pathname; var mark = getBookmark(); $(function () { init(); // save the position by clicking the icon link.click(function () { mark = doSaveScroll(path, mark); return false; }); // register beforeunload event when the trigger is auto if (trigger === 'auto') { // register beforeunload event global.addEventListener('beforeunload', function () { doSaveScroll(path, mark); }); } // auto scroll to the position if (mark == null) { return; } // and if the page opens with a specific hash, just jump out var skips = [hash, '#comments']; // eslint-disable-next-line if (skips.filter(function (h) { return h === global.location.hash }).length > 0) { return; } doScroll(mark[path]); }); }; global.bookmark = { loadBookmark: loadBookmark, scrollToMark: scrollToMark, }; })(window);"},{"title":"","date":"2021-05-27T04:33:51.871Z","updated":"2021-05-27T04:33:51.871Z","comments":true,"path":"lib/bookmark/package.json","permalink":"http://example.com/lib/bookmark/package.json","excerpt":"","text":"{\"name\":\"theme-next-bookmark\",\"version\":\"1.0.2\",\"description\":\"A plugin of local-bookmarks for NexT theme.\",\"main\":\"index.js\",\"scripts\":{\"test\":\"eslint index.js\",\"dist\":\"eslint index.js && uglifyjs --compress --mangle -o bookmark.min.js -- index.js\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/theme-next/theme-next-bookmark.git\"},\"keywords\":[\"hexo\",\"theme-next\",\"plugin\",\"bookmark\"],\"author\":\"Tsanie Lily\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/theme-next/theme-next-bookmark/issues\"},\"homepage\":\"https://github.com/theme-next/theme-next-bookmark#readme\",\"devDependencies\":{\"eslint\":\"^4.17.0\",\"eslint-config-google\":\"^0.9.1\",\"uglify-js\":\"^3.3.10\"}}"},{"title":"","date":"2021-05-27T04:33:51.871Z","updated":"2021-05-27T04:33:51.871Z","comments":true,"path":"lib/bookmark/renovate.json","permalink":"http://example.com/lib/bookmark/renovate.json","excerpt":"","text":"{\"extends\":[\"config:base\"]}"}],"posts":[{"title":"leetcode-网络延迟时间","slug":"leetcode-网络延迟时间","date":"2021-08-01T16:00:00.000Z","updated":"2021-08-02T02:23:43.207Z","comments":true,"path":"2021/08/02/leetcode-网络延迟时间/","link":"","permalink":"http://example.com/2021/08/02/leetcode-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/","excerpt":"","text":"743. 网络延迟时间有 n 个网络节点，标记为 1 到 n。给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。 现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。 示例1： 12输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2输出：2 示例2： 12输入：times = [[1,2,1]], n = 2, k = 1输出：1 知识点：图分析：从k节点开始，找到遍历至其他所有节点的最短路径；可利用贪心思想，定义一个距离数组，将到达每个节点的最短路径放入，然后取出最大值即可。 代码如下：12345678910111213141516171819202122232425262728293031class Solution &#123; public int networkDelayTime(int[][] times, int n, int k) &#123; final int INF = Integer.MAX_VALUE/2; int[][] g = new int[n][n]; for(int i=0;i&lt;n;i++)&#123; Arrays.fill(g[i],INF); &#125; for(int[] t:times)&#123; int x = t[0]-1,y = t[1]-1; g[x][y] = t[2]; &#125; int[] dist = new int[n]; Arrays.fill(dist,INF); dist[k-1] = 0; boolean[] used = new boolean[n]; for(int i=0;i&lt;n;i++)&#123; int x = -1; for(int y=0;y&lt;n;++y)&#123; if(!used[y]&amp;&amp;(x==-1||dist[y]&lt;dist[x]))&#123; x=y; &#125; &#125; used[x] = true; for(int y=0;y&lt;n;++y)&#123; dist[y] = Math.min(dist[y],dist[x]+g[x][y]); &#125; &#125; int ans = Arrays.stream(dist).max().getAsInt(); return ans==INF?-1:ans; &#125;&#125;","categories":[{"name":"leetcode刷题笔记","slug":"leetcode刷题笔记","permalink":"http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"图","slug":"图","permalink":"http://example.com/tags/%E5%9B%BE/"}]},{"title":"StackOverFlow和OutOfMemory对比","slug":"StackOverFlow和OutOfMemory对比","date":"2021-07-23T16:00:00.000Z","updated":"2021-08-02T08:11:05.053Z","comments":true,"path":"2021/07/24/StackOverFlow和OutOfMemory对比/","link":"","permalink":"http://example.com/2021/07/24/StackOverFlow%E5%92%8COutOfMemory%E5%AF%B9%E6%AF%94/","excerpt":"","text":"由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数（设置本地方法栈大小）虽然存在，但实际上是没有任何效果的，栈容量只能由-Xss参数来设定。关于虚拟机栈和本地方法栈，在《Java虚拟机规范》中描述了两种异常： 1)如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。 2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出DutOfMemory Error异常。 《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机的选择是不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。 Java堆溢出： 只要不断的创建对象，达到最大堆容量限制之后就会抛出OOM异常； 虚拟机栈和本地方法栈溢出： 不断创建线程，会导致OOM异常 方法区溢出： 通过String::inner()这个本地方法，不断添加对象，将导致OOM异常","categories":[{"name":"JVM相关","slug":"JVM相关","permalink":"http://example.com/categories/JVM%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"基础知识点","slug":"基础知识点","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"创建线程的四种方式","slug":"创建线程的四种方式","date":"2021-07-20T16:00:00.000Z","updated":"2021-08-02T08:02:42.253Z","comments":true,"path":"2021/07/21/创建线程的四种方式/","link":"","permalink":"http://example.com/2021/07/21/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"start和run的区别 调用start是开启一个线程，并自动执行run方法； 调用run是在当前线程去调用run方法，本质上是调用一个类中的方法，并未开启新的线程。 1、使用线程池12345678910111213141516171819202122//演示一下public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; 参数名 作用 corePoolSize 核心线程池大小 maximumPoolSize 最大线程池大小 keepAliveTime 线程池中超过corePoolSize数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true)使得核心线程有效时间 TimeUnit keepAliveTime时间单位 workQueue 任务缓存队列，用来存放等待执行的任务 threadFactory 新建线程工厂 RejectedExecutionHandler 当提交任务数超过maxmumPoolSize+workQueue之和时，任务会交给RejectedExecutionHandler来处理 线程池增长策略：1.当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。 2.当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行 3.当workQueue已满，且当前线程池中的线程数量&lt;maximumPoolSize时，新提交任务会创建新线程执行任务 4.当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理 5.当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程 线程池的拒绝策略：1、AbortPolicy（默认）：抛出异常 2、DiscardPolicy：删除不能被执行的任务 补充 6.当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭 7.有界任务队列 有界任务队列可以用ArrayBlockingQueue来实现，若有新的任务需要执行，线程池会创建新的线程，直到创建的线程数量达到corePoolSize时，会将新的任务添加入等待队列；若等待队列已满，超过ArrayBlockingQueue的初始化容量时，则会继续创建线程，直到线程数量达到maximumPoolSize，超过maximumPoolSize之后则执行拒绝策略。 8.无界任务队列 无界任务队列可以使用LinkedBlockingQueue来实现，使用无界任务队列可以无限制添加新的任务，任务的最大数量为corePoolSize，此时maximumPoolSize是无效的，若再有新的任务加入，则直接进入等待队列。 9.优先任务队列 通过PriorityBlockingQueue实现，这也是一个无界队列，此队列可自定义规则根据任务优先级顺序先后执行 优点： (1) 降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗； （2）提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行； （3）方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换 2、实现runnable接口3、实现callable接口相较于实现runnable方法，线程可以有返回值，可以抛出异常 4、继承Thread类","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://example.com/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"基础知识点","slug":"基础知识点","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"HappenBefore原则","slug":"HappenBefore原则","date":"2021-07-19T16:00:00.000Z","updated":"2021-08-02T07:56:26.383Z","comments":true,"path":"2021/07/20/HappenBefore原则/","link":"","permalink":"http://example.com/2021/07/20/HappenBefore%E5%8E%9F%E5%88%99/","excerpt":"","text":"定义了哪些指令不能重排：单线程的happen before原则写在前面的操作happen before后面的操作 锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。 volatile的happen-before原则：对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。 happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。 线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。 线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。 线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。 对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。 哪些会进行重排：执行程序时为了提高性能，编译器和处理器经常会对指令进行重新排序。 编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 内存系统的重排序：由于处理器使用的是缓存和读写缓冲区，看上去像是乱序执行。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://example.com/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"基础知识点","slug":"基础知识点","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"医院挂号系统知识点总结","slug":"尚医通医院预约挂号系统知识点总结","date":"2021-07-18T16:00:00.000Z","updated":"2021-07-23T02:22:29.076Z","comments":true,"path":"2021/07/19/尚医通医院预约挂号系统知识点总结/","link":"","permalink":"http://example.com/2021/07/19/%E5%B0%9A%E5%8C%BB%E9%80%9A%E5%8C%BB%E9%99%A2%E9%A2%84%E7%BA%A6%E6%8C%82%E5%8F%B7%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"","text":"在此对尚医通在线预约挂号系统进行一个总结，以致自省。 功能划分一、后台管理系统1、医院设置管理包括 ​ 医院设置列表显示（包括该医院的网址、医院编号、联系人、联系方式） ​ 医院设置添加（添加新的医院设置） ​ 进行医院锁定（锁定之后不可再进行预约） ​ 医院设置的删除 ​ 医院列表（显示医院的名称、等级、地址） ​ 医院详情（该医院的具体详细信息） ​ 医院的排班情况（分科室） ​ 医院上线、下线 2、数据管理​ 数据字典的树形显示、 ​ 数据的导入、导出功能（通过excel表格形式） 3、用户管理​ 用户列表（查看所有用户） ​ 用户详情（查看用户名称、证件信息等） ​ 用户锁定（违规操作锁定账号） ​ 认证审批列表（用户注册时，需后台进行审批的列表，可查看用户信息、进行判定通过或者不通过） 二、前台用户系统1、首页数据显示​ 显示下属医院、 ​ 显示所有等级和地区信息（并可根据不同等级和地区进行医院查询） ​ 并可根据医院名称进行搜索 2、通过显示医院进入医院的详情页面​ 查看医院详情 ​ 查看各个科室及下属部门 ​ 点击不同的科室进行挂号 3、用户注册/登录​ 通过手机号进行注册/登录（本来是要通过整合阿里云的短信功能，但是一直申请不下来） 4、用户的实名认证功能​ 挂号之前需要用户进行填写姓名和身份证，提交之后会显示认证状态，后台通过之后才可以进行挂号 5、就诊人信息​ 用户完成注册之后，挂号之前需要填写就诊人信息（姓名、证件类型、证件号码、性别、出生日期、手机号码），包括就诊人列表、添 加、详情、删除 6、预约挂号功能​ 用户完成注册之后，通过进入医院界面，选择科室之后，会显示可预约的日期以及当前选择日期的可预约情况（上午、下午、主治医师信息、剩余可预约数量），选择日期和科室之后，跳转至挂号详情页面，确认挂号信息，生成挂号订单，之后可进行订单支付或者订单取消 前后端知识点后端技术 SpringBoot一个Spring的脚手架，快速构建Spring工程 SpringCloudNacos：注册服务中心，实现不同服务之间的调用，需要在注册服务中心进行注册 Feign：用于发现服务，从而进行调用 Spring Cloud Gateway：通过网关根据不同的路径进行转发至不同的接口，从而调用不同的服务;网关核心功能是路由转发，因此不要有耗时操作在网关上处理，让请求快速转发到后端服务上，网关还能做统一的熔断、限流、认证、日志监控等。 工作原理： 客户端向Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。 Filter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等， 在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用 gateway可参考springcloud(十五)：服务网关 Spring Cloud GateWay 入门 - 纯洁的微笑博客 (ityouknow.com) Redis一个内存数据库，基于key-value进行存储，优点是查询效率高 （1）作为缓存使用，将不经常变动的数据存放入redis中，如：医院信息 （2）验证码有效时间 MongoDBNoSql型数据库 （1）将医院的基本信息、科室信息、排班信息等存储在MongoDB中，通过SpringBoot整合MongoTemplate和MongoRepository对数据库进行操作 EasyExcel阿里开发的一个操作Excel的工具，可对excel表格进行快速读取 MyBatisPlus本身就是对MyBatis的增强，通过该工具实现对数据库的快速操作 （1）接口继承IService （2）在mapper中继承BaseMapper；BaseMapper封装了增删改查的基本操作 RabbitMQ（补）订单的相关操作，订单修改发送mq消息，mq消息的好处：使得项目的并发功能更加强大 Docker下载镜像、创建容器 （1）MongoDB容器的创建 （2）RabbitMQ容器的创建 swagger-ui这也是个工具，用于后端接口进行阶段性调试时使用；写好一个接口可进行功能测试。 HttpServletRequestHttpServletRequest对象代表客户端的请求,当客户端通过http协议请求访问；服务器的时候,http请求头的所有信息都封装在这个对象中，通过这个对象，可以获取客户端请求的所有信息。 http请求包含请求行/状态行、请求头、请求体。 request如果是post才有请求体，get则没有请求体，直接跟在？后面，用&amp;隔开。 请求头header一般用来存放一些cookie，token信息； 请求体body一般用来存储post的参数和参数数据； ————————————————版权声明：本文为CSDN博主「金麟十三少」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/u012373281/article/details/91350377 JWTJson web token，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。 原理​ 由于http协议本身是一种无状态的协议，这意味着当用户使用账户和密码进行用户认证完成后并不能存在登录状态。导致下次请求依旧需要再次认证。因为服务器仅仅通过http协议，并不能知道是哪个用户发出的请求，所以需要借助一些处理机制来记录认证状态，从而完成请求和响应。 认证方式：传统session认证session认证是将用户的认证信息存储在服务器端，并且会在认证通过后将这一份认证信息传递给浏览器端，浏览器将其保存为cookie。浏览器在下次发送请求时会将该cookie携带并且发送给我们的服务器，这样我们的应用就能识别请求来自哪个用户了，这就是基于传统的session认证。 但是基于session认证的的应用本身很难扩展，随着不同客户端用户的增加，独立的服务器无法承载越来越多的用户，这时候session认证的问题也就暴露出来了。 基于session认证的常见问题1）session：由于每个用户经过我们的认证服务器认证之后，都要在该认证服务器端做一次记录，通常而言该记录保存在内存中，这就导致内存占用量随着认证用户数量的增加而越来越大，==服务器的开销也会越来越大==。2）扩展性：用户认证之后，服务器端将认证记录存储在内存中，这意味着该用户的下次请求还必须要请求在这台服务器上，只有这样授权才能通过。这种方式下也就限制了==负载均衡器的能力==。也就限制了应用的扩展能力。3）CSRF:因为基于cookie来进行用户识别，所以当cookie被劫持，用户就很容易受到跨站请求==伪造的攻击==。 基于token的认证认证流程： 用户使用用户名（账户）、密码请求服务器进行登录。 服务器验证用户信息，对比用户名和密码是否存在且一致。 验证用户信息没有问题后，服务器端根据token生成的机制生成token。 服务器端返回给用户一个token。客户端（浏览器）存储token，并且每次请求时附送上这个token。 服务器端通过验证机制验证token，并且返回数据。这个token在验证后每次请求时都要传递给服务器端，通过请求头传递。另外服务器要支持CORS（跨来源资源共享）策略，一般在服务端这样做： 1Access-Control-Allow-Origin：* 版权声明：本文为CSDN博主「敬苍生」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_32609199/article/details/109569396 JWT结构JWT由三段信息构成，通过 .链接在一起构成jwt字符串。 headerjwt的头部承载两部分信息： 声明token类型，这里是jwt声明token的加密方式 通常使用 HMAC SHA256等完整的头部如下： 1234&#123; &#x27;typ&#x27;: &#x27;JWT&#x27;, &#x27;alg&#x27;: &#x27;HS256&#x27;&#125; 通过对该json字符串进行BASE64压缩就得到了header部分。 1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 payload有关实体的声明，存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分 声明有三种类型: registered, public 和 private。 Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。 ​ 标准中注册的声明 (建议但不强制使用) ： iss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的. iat: jwt的签发时间 jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 Public claims : 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密. Private claims : 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。 对该json字符串进行BASE64压缩就得到了第二部分。从这里可以看出payload完全是明文暴露的，==请不要放置一些重要信息==。————————————————版权声明：本文为CSDN博主「敬苍生」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_32609199/article/details/109569396 signaturejwt的第三部分是一个签证信息，以token的前两部分作为明文，用共同协商好的秘钥进行签名（对称签名和非对称签名）。这个签证信息由三部分组成： header (base64后的) payload (base64后的) secret 签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。 通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。 注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。 总结 因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。 因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。 便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。 它不需要在服务端保存会话信息, 所以它易于应用的扩展 无状态和可扩展性：Tokens存储在客户端。完全无状态，可扩展。我们的负载均衡器可以将用户传递到任意服务器，因为在任何地方都没有状态或会话信息。 安全：Token不是Cookie。（The token, not a cookie.）每次请求的时候Token都会被发送。而且，由于没有Cookie被发送，还有助于防止CSRF攻击。即使在你的实现中将token存储到客户端的Cookie中，这个Cookie也只是一种存储机制，而非身份认证机制。没有基于会话的信息可以操作，因为我们没有会话! 过期性：token在一段时间以后会过期，这个时候用户需要重新登录。这有助于我们保持安全。还有一个概念叫token撤销，它允许我们根据相同的授权许可使特定的token甚至一组token无效。———————————————— 版权声明：本文为CSDN博主「敬苍生」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_32609199/article/details/109569396 QueryWrapper的用法构造器条件关系 上图绿色框为抽象类abstract 蓝色框为正常class类，可new对象 黄色箭头指向为父子类关系，箭头指向为父类 常用函数 前端技术 vue一个快速构建页面的框架；指令：v-if、v-for、插值表达式 Element-ui一个前端组件库，可以快速实现组件效果 Nuxt一个服务端渲染技术 Npm项目里用的最多的就是下载依赖 我学到了什么： swagger-ui这个小工具，用于调试接口很好用，可提高排错效率 result：一个结果集，这个很实用，相当于对函数的返回类型进行统一，使得代码通用性更高 HttpServletRequest","categories":[{"name":"项目Hospital","slug":"项目Hospital","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AEHospital/"}],"tags":[]},{"title":"回文字符串","slug":"回文字符串","date":"2021-07-17T16:00:00.000Z","updated":"2021-07-19T11:13:26.965Z","comments":true,"path":"2021/07/18/回文字符串/","link":"","permalink":"http://example.com/2021/07/18/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"5. 最长回文子串知识点：manacher算法题目描述：给你一个字符串 s，找到 s 中最长的回文子串。 分析：manacher算法的快捷在于将每个节点的最大臂长都记录在内，这样下次再查找的时候就不必再做重复工作；另外，对字符串进行处理（加特殊符号），使得字符串的长度全部都为奇数。 复杂度分析：时间复杂度：O(n)，其中 n 是字符串的长度。由于对于每个位置，扩展要么从当前的最右侧臂长 right 开始，要么只会进行一步，而 right 最多向前走 O(n) 步，因此算法的复杂度为 O(n)。 空间复杂度：O(n)，我们需要 O(n) 的空间记录每个位置的臂长。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public String longestPalindrome(String s) &#123; //先对字符串进行处理：+特殊字符 StringBuffer t = new StringBuffer(&quot;$&quot;); for(int i=0;i&lt;s.length();i++)&#123; t.append(s.charAt(i)); t.append(&#x27;$&#x27;); &#125; s = t.toString(); //定义start为最长字符串的起始位置，end为最长字符串的结束位置 int start = 0,end = -1; //定义right为当前回文串的最右侧，center为最长回文串的对称中心 int right = -1,center = -1; List&lt;Integer&gt; armLength = new ArrayList&lt;&gt;(); for(int i=0;i&lt;s.length();i++)&#123; int curArmLength = 0; if(i&lt;=right)&#123;//若当前位置在最长回文串范围内部 int iSym = center*2-i; //minArm是当前可确定的最短臂长 int minArm = Math.min(right-i,armLength.get(iSym)); //之后对当前臂长开始向两侧伸展 curArmLength = getArmLength(s,i-minArm,i+minArm); &#125;else&#123;//没有就重头开始找咯 curArmLength = getArmLength(s,i,i); &#125; //每一轮都要对数据进行更新 armLength.add(curArmLength); if(right&lt;i+curArmLength)&#123;//如果之前的right不行了，就进行更新 center=i; right = i+curArmLength; &#125; if(end-start&lt;curArmLength*2+1)&#123; start = i-curArmLength; end = i+curArmLength; &#125; &#125; //再次处理字符串，消除特殊字符 StringBuffer res = new StringBuffer(); for(int i=start;i&lt;=end;i++)&#123; if(s.charAt(i)!=&#x27;$&#x27;)&#123; res.append(s.charAt(i)); &#125; &#125; return res.toString(); &#125; //找到字符串的臂长 public int getArmLength(String s,int left,int right)&#123; while(left&gt;=0 &amp;&amp; right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123; --left; ++right; &#125; return (right-left-2)/2; &#125;&#125; 214. 最短回文串给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。 示例 1： 输入：s = “aacecaaa” 输出：”aaacecaaa” 示例 2： 输入：s = “abcd” 输出：”dcbabcd” 知识点：字符串、manacher、KMP分析：这个题目前没解决，走了个递归的路子，我尝试用manacher进行计算，超时了，但是有人的manacher没超时，说明我的manacher还有待改进；这个题用KMP是最好的，还有个解法是用的字符串哈希，那个是“投机取巧”了(我也不会用)。 已经掌握KMP模式匹配算法。 KMP代码如下：1234567891011121314151617181920212223242526272829303132class Solution &#123; public String shortestPalindrome(String s) &#123; int len = s.length(); //next[i]为到下标为i的位置时前缀后缀匹配个数 int[] next = new int[len]; //从1开始是因为next[0]肯定是0 for(int i=1,size = 0;i&lt;len;i++)&#123; //如果不相等，就把size改为上一个相等位置的长度 while(size&gt;0&amp;&amp;s.charAt(i)!=s.charAt(size))&#123; size = next[size-1]; &#125; if(s.charAt(i)==s.charAt(size))&#123; ++size; &#125; next[i] = size; &#125; int index = 0; for(int i=len-1;i&gt;=0;i--)&#123; //将s和其倒序字符串进行最大前缀后缀匹配个数 while(index&gt;0&amp;&amp;s.charAt(i)!=s.charAt(index))&#123; index = next[index-1]; &#125; if(s.charAt(index)==s.charAt(i))&#123; ++index; &#125; &#125; //如果s本身是回文字符串，那么index就是s的length String add = (index==len?&quot;&quot;:s.substring(index)); StringBuilder sb = new StringBuilder(add); return sb.reverse().append(s).toString(); &#125;&#125;","categories":[{"name":"leetcode刷题笔记","slug":"leetcode刷题笔记","permalink":"http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"leetcode子序列问题","slug":"leetcode子序列问题","date":"2021-06-26T16:00:00.000Z","updated":"2021-07-27T02:53:11.037Z","comments":true,"path":"2021/06/27/leetcode子序列问题/","link":"","permalink":"http://example.com/2021/06/27/leetcode%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/","excerpt":"","text":"300. 最长递增子序列给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2： 输入：nums = [0,1,0,3,2,3] 输出：4 示例 3： 输入：nums = [7,7,7,7,7,7,7] 输出：1 提示： 1 &lt;= nums.length &lt;= 2500 -104 &lt;= nums[i] &lt;= 104 进阶： 你可以设计时间复杂度为 O(n2) 的解决方案吗？ 你能将算法的时间复杂度降低到 O(n log(n)) 吗? 知识点：动态规划、二分查找分析：这个题目核心思想是：让子序列增长的慢，使得每个长度的子序列的最大值（也就是最后一个）保持当前长度的最小值（尽量小），故得到最长的递增子序列。这个题解不错，仔细看看。 代码如下：123456789101112131415161718192021222324252627282930class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int len = nums.length,res = 1; if(len==0)&#123; return 0; &#125; int[] d = new int[len+1]; d[res] = nums[0]; for(int i=1;i&lt;len;i++)&#123; if(nums[i]&gt;d[res])&#123; //如果下一个数本身就比当前子序列最大值大，那直接加进去就行 d[++res] = nums[i]; &#125;else&#123; //如果下一个数比较小，那么我们给这个数找一个合适的位置 int left = 1,right = res,pos = 0; while(left&lt;=right)&#123; int mid = left+(right-left)/2; if(d[mid]&lt;nums[i])&#123; pos = mid; left = mid+1; &#125;else&#123; right = mid-1; &#125; &#125; d[pos+1] = nums[i]; &#125; &#125; return res; &#125;&#125; 1035. 不相交的线在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。 现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足： nums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。 以这种方法绘制线条，并返回可以绘制的最大连线数。 知识点：dp分析：求最长公共子序列，代码都不用改。 代码如下：12345678910111213141516class Solution &#123; public int maxUncrossedLines(int[] nums1, int[] nums2) &#123; int len1 = nums1.length,len2 = nums2.length; int[][] dp = new int[len1+1][len2+1]; for(int i=1;i&lt;=len1;i++)&#123; for(int j= 1;j&lt;=len2;j++)&#123; if(nums1[i-1]==nums2[j-1])&#123; dp[i][j] = dp[i-1][j-1]+1; &#125;else&#123; dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]); &#125; &#125; &#125; return dp[len1][len2]; &#125;&#125; 1143.最长公共子序列给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。 示例 1： 输入：text1 = “abcde”, text2 = “ace” 输出：3 解释：最长公共子序列是 “ace” ，它的长度为 3 。 知识点：dp、数组分析：这个解法我没看太明白。 二维动态规划，双层for循环，外层遍历text1，内层遍历text2。贴个题解二维动态规划的常规套路，讲的不赖。 1.状态定义： 比如对于本题而言，可以定义 dpi 表示 text1[0:i-1] 和 text2[0:j-1] 的最长公共子序列。 （注：text1[0:i-1] 表示的是 text1 的 第 0 个元素到第 i - 1 个元素，两端都包含） 之所以 dpi 的定义不是 text1[0:i] 和 text2[0:j] ，是为了方便当 i = 0 或者 j = 0 的时候，dpi表示的为空字符串和另外一个字符串的匹配，这样 dpi 可以初始化为 0. 2.状态转移方程 知道状态定义之后，开始写状态转移方程。 当 text1[i - 1] == text2[j - 1] 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 1，所以 dpi = dpi - 1 + 1；举个例子，比如对于 ac 和 bc 而言，他们的最长公共子序列的长度等于 a 和 b 的最长公共子序列长度 0 + 1 = 1。 当 text1[i - 1] != text2[j - 1] 时，说明两个子字符串的最后一位不相等，那么此时的状态 dpi 应该是 dpi - 1 和 dpi 的最大值。举个例子，比如对于 ace 和 bc 而言，他们的最长公共子序列的长度等于 ① ace 和 b 的最长公共子序列长度0 与 ② ac 和 bc 的最长公共子序列长度1 的最大值，即 1。 综上状态转移方程为： dpi = dpi - 1 + 1dpi=dpi−1+1, 当 text1[i - 1] == text2[j - 1];text1[i−1]==text2[j−1]; dpi = max(dpi - 1, dpi)dpi=max(dpi−1,dpi), 当 text1[i - 1] != text2[j - 1]text1[i−1]!=text2[j−1] 3.状态初始化 初始化就是要看当 i = 0 与 j = 0 时， dpi 应该取值为多少。 当 i = 0 时，dp0 表示的是 text1中取空字符串跟 text2 的最长公共子序列，结果肯定为 0. 当 j = 0 时，dpi 表示的是 text2text2 中取空字符串 跟 text1text1 的最长公共子序列，结果肯定为 0. 综上，当 i = 0 或者 j = 0 时，dpi 初始化为 0. 代码如下：123456789101112131415161718class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; char[] array1 = text1.toCharArray(); char[] array2 = text2.toCharArray(); int len1 = array1.length,len2 = array2.length; int[][] dp = new int[len1+1][len2+1]; for(int i=1;i&lt;=len1;i++)&#123; for(int j = 1;j&lt;=len2;j++)&#123; if(array1[i-1]==array2[j-1])&#123; dp[i][j] = dp[i-1][j-1]+1; &#125;else&#123; dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]); &#125; &#125; &#125; return dp[len1][len2]; &#125;&#125; 1713. 得到子序列的最少操作次数给你一个数组 target ，包含若干 互不相同 的整数，以及另一个整数数组 arr ，arr 可能 包含重复元素。 每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = [1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2] 。你可以在数组最开始或最后面添加整数。 请你返回 最少 操作次数，使得 target 成为 arr 的一个子序列。 一个数组的子序列指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。 示例 1： 输入：target = [5,1,3], arr = [9,4,2,3,4] 输出：2 解释：你可以添加 5 和 1 ，使得 arr 变为 [5,9,4,1,2,3,4] ，target 为 arr 的子序列。 示例 2： 输入：target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1] 输出：3 提示： 1 &lt;= target.length, arr.length &lt;= 105 1 &lt;= target[i], arr[i] &lt;= 109 target 不包含任何重复元素。 知识点：贪心、二分查找分析：这个题解讲的比较好，我没什么好补充的。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; //最少操作数=target.length-arr中已存在的target子序列最大长度 public int minOperations(int[] target, int[] arr) &#123; int len = target.length; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;len;i++)&#123; map.put(target[i],i); &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int num:arr)&#123; if(map.containsKey(num))&#123; int index = map.get(num); int pos = binarySearch(list,index); if(pos!=list.size())&#123; list.set(pos,index); &#125;else&#123; list.add(index); &#125; &#125; &#125; return len-list.size(); &#125; //通过二分查找，将当前遍历到的较小的数字放置合适的位置 public int binarySearch(List&lt;Integer&gt; list,int target)&#123; int size = list.size(); if(size==0||list.get(size-1)&lt;target)&#123; return size; &#125; int left = 0,right = size-1; while(left&lt;right)&#123; int mid = (right-left)/2+left; if(list.get(mid)&lt;target)&#123; left=mid+1; &#125;else&#123; right = mid; &#125; &#125; return left; &#125;&#125;","categories":[{"name":"leetcode刷题笔记","slug":"leetcode刷题笔记","permalink":"http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"动态规划、二分查找","slug":"动态规划、二分查找","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"leetcode-逆序对相关","slug":"leetcode-逆序对相关","date":"2021-06-24T16:00:00.000Z","updated":"2021-07-25T11:28:23.251Z","comments":true,"path":"2021/06/25/leetcode-逆序对相关/","link":"","permalink":"http://example.com/2021/06/25/leetcode-%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9B%B8%E5%85%B3/","excerpt":"","text":"剑指 Offer 51. 数组中的逆序对在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 知识点：利用归并排序（这个题目算是个新的知识点，可以入库） 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123; int resCount = 0; public int reversePairs(int[] nums) &#123; int len = nums.length; if(len&lt;2)&#123; return 0; &#125; int[] tmpNums = new int[len]; merge(nums, tmpNums, 0, len - 1); return resCount; &#125; /** * @param nums 待排数组 * @param tmpNums 辅助数组 * @param left 待排数组左边界 * @param right 待排数组右边界 * 将待排数组分为两段，分别调用排序函数，并将两段数组排序成为一个 */ private void merge(int[] nums, int[] tmpNums, int left, int right) &#123; //待排数组仅一个数字时，直接返回 if (left &gt;= right) &#123; return; &#125; //将待排数组分为两段 int mid = left + (right - left) / 2; merge(nums, tmpNums, left, mid); merge(nums, tmpNums, mid + 1, right); if (nums[mid] &lt;= nums[mid + 1]) &#123; return; &#125; sort(nums, tmpNums, left, mid,right); &#125; /** * 将数组nums在下标left和right内进行有序排列 * * @param nums 待排数组 * @param tmpNums 辅助数组 * @param left 待排左边界 * @param right 待排右边界 */ private void sort(int[] nums, int[] tmpNums, int left, int mid, int right) &#123; //将待排元素放入辅助数组中 for (int i = left; i &lt;= right; i++) &#123; tmpNums[i] = nums[i]; &#125; //此处rightIndex必须从mid+1开始，否则会出错 int index = left, leftIndex = left, rightIndex = mid+1; while (index &lt;= right) &#123; if (leftIndex &gt; mid) &#123;//此时左侧区间元素已经全部排序完毕 nums[index] = tmpNums[rightIndex]; rightIndex++; &#125; else if (rightIndex &gt; right) &#123;//此时右侧区间元素排序完毕 nums[index] = tmpNums[leftIndex]; leftIndex++; &#125; else if (tmpNums[leftIndex] &lt;= tmpNums[rightIndex]) &#123;//如果左侧元素较小，就把左侧元素放入nums数组中 nums[index] = tmpNums[leftIndex]; leftIndex++; &#125; else &#123;//如果右侧元素较小，就将右侧元素放入数组中 nums[index] = tmpNums[rightIndex]; rightIndex++; //此时变动逆序对个数 resCount+=mid-leftIndex+1; &#125; index++; &#125; &#125;&#125; 315. 计算右侧小于当前元素的个数给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。 示例： 输入：nums = [5,2,6,1] 输出：[2,1,1,0] 解释： 5 的右侧有 2 个更小的元素 (2 和 1) 2 的右侧仅有 1 个更小的元素 (1) 6 的右侧有 1 个更小的元素 (1) 1 的右侧有 0 个更小的元素 知识点：归并排序分析：这个题目和逆序基本一致，可以利用归并排序检索右侧小于当前元素的个数；需要注意的是，对局部区间进行排序之后，元素位置发生变化，会出现上次的索引和当前的索引对应的不是同一个元素的情况，故需要建立索引数组，整个排序区间对索引数组中索引的位置进行排序，即根据元素本身大小实现其索引有序；还有注意一点，在计算右侧小于当前元素个数时，为避免重复计算，需等待右侧区间元素大于左侧区间元素时，将右侧区间元素前面的元素计算个数并加入至左侧区间元素对应的结果中。 代码如下：1","categories":[{"name":"leetcode刷题笔记","slug":"leetcode刷题笔记","permalink":"http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"归并排序","slug":"归并排序","permalink":"http://example.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"}]},{"title":"leetcode-二叉树的遍历","slug":"leetcod-二叉树的层序遍历","date":"2021-06-23T16:00:00.000Z","updated":"2021-07-31T02:41:41.769Z","comments":true,"path":"2021/06/24/leetcod-二叉树的层序遍历/","link":"","permalink":"http://example.com/2021/06/24/leetcod-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"102. 二叉树的层序遍历给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 知识点：BFS 分析：没什么好分析的，就是层序遍历，需要用到几个集合，得多熟悉：LinkedList，ArrayDeque，ArrayList，我回头做个关于集合的总结，要好好掌握。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); if (root!=null)&#123; stack.offerLast(root); &#125; while(!stack.isEmpty())&#123; int size = stack.size(); ArrayList&lt;Integer&gt; curList = new ArrayList&lt;&gt;(); while (size&gt;0) &#123; TreeNode treeNode = stack.removeFirst(); curList.add(treeNode.val); if(treeNode.left!=null)&#123; stack.offerLast(treeNode.left); &#125; if(treeNode.right!=null)&#123; stack.offerLast(treeNode.right); &#125; size--; &#125; resList.add(curList); &#125; return resList; &#125;&#125; 103. 二叉树的锯齿形层序遍历知识点：BFS分析：同上 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; resList = new LinkedList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); if (root != null) &#123; stack.add(root); &#125; boolean mark = false; while (!stack.isEmpty()) &#123; Deque&lt;Integer&gt; curList = new LinkedList&lt;&gt;(); int size = stack.size(); while (size &gt; 0) &#123; TreeNode treeNode = stack.removeFirst(); if(mark)&#123; curList.offerFirst(treeNode.val); &#125;else&#123; curList.offerLast(treeNode.val); &#125; if (treeNode.left != null) &#123; stack.offerLast(treeNode.left); &#125; if (treeNode.right != null) &#123; stack.offerLast(treeNode.right); &#125; size--; &#125; mark=!mark; resList.add(new LinkedList&lt;&gt;(curList)); &#125; return resList; &#125;&#125; 1104. 二叉树寻路在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。 如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记； 而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。 给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。 示例 1： 输入：label = 14 输出：[1,3,4,14] 示例 2： 输入：label = 26 输出：[1,2,6,10,26] 提示： 1 &lt;= label &lt;= 10^6 知识点：二叉树分析：这个和普通二叉树的区别在于偶数行进行了镜像式转换，考虑到对称的特点：任意两个对称位置上的数字和相等。故根据这一特点对每行数字进行查找，如果是偶数行，则需进行反转。题解讲的很细致。 代码如下：1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;Integer&gt; pathInZigZagTree(int label) &#123; int row = 1,rowStart = 1; //确定label所在行数 while(rowStart*2&lt;=label)&#123; row++; rowStart*=2; &#125; if(row%2==0)&#123; label = getReverse(label,row); &#125; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); while (row&gt;0)&#123; if(row%2==0)&#123; res.add(getReverse(label, row)); &#125;else&#123; res.add(label); &#125; --row; label&gt;&gt;=1; &#125; Collections.reverse(res); return res; &#125; private int getReverse(int label, int row) &#123; return (1&lt;&lt;row-1)+(1&lt;&lt;row)-1-label; &#125;&#125; 987. 二叉树的垂序遍历给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。 对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。 二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。 返回二叉树的 垂序遍历 序列。 知识点：二叉树遍历分析：既然是根据节点的列坐标进行排序，首先对二叉树进行深度优先遍历，记录所有节点的横纵坐标，然后根据纵坐标进行排序，为了方便，再根据横坐标进行第二优先排序，最后根据节点数值大小进行第三优先排序。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package LC987_vertical_order_traversal_of_a_binary_tree;import mytreenode.TreeNode;import java.util.*;public class VerticalOrderTraversalOfABinaryTree &#123; public List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123; List&lt;int[]&gt; nodes = new ArrayList&lt;&gt;(); dfs(root,0,0,nodes); Collections.sort(nodes, new Comparator&lt;int[]&gt;() &#123; @Override public int compare(int[] o1, int[] o2) &#123; if(o1[0]!=o2[0])&#123; return o1[0]-o2[0]; &#125;else if(o1[1]!=o2[1])&#123; return o1[1]-o2[1]; &#125;else&#123; return o1[2]-o2[2]; &#125; &#125; &#125;); List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); int size = 0; int lastCol = Integer.MIN_VALUE; for(int[] node:nodes)&#123; int col = node[0],row = node[1],value = node[2]; //如果不是同一列 if(col!=lastCol)&#123; lastCol = col; ans.add(new ArrayList&lt;Integer&gt;()); size++; &#125; ans.get(size-1).add(value); &#125; return ans; &#125; /** * 进行深度优先遍历 * @param root 当前节点 * @param row 当前行数 * @param col 当前列数 * @param nodes 存放数组 */ private void dfs(TreeNode root, int row, int col, List&lt;int[]&gt; nodes) &#123; if(root==null)&#123; return; &#125; nodes.add(new int[]&#123;col,row,root.val&#125;); dfs(root.left,row+1, col-1, nodes); dfs(root.right,row+1,col+1,nodes); &#125;&#125;","categories":[{"name":"leetcode刷题笔记","slug":"leetcode刷题笔记","permalink":"http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"http://example.com/tags/BFS/"}]},{"title":"leetcode-接雨水","slug":"leetcode-接雨水","date":"2021-06-22T16:00:00.000Z","updated":"2021-07-23T08:33:22.916Z","comments":true,"path":"2021/06/23/leetcode-接雨水/","link":"","permalink":"http://example.com/2021/06/23/leetcode-%E6%8E%A5%E9%9B%A8%E6%B0%B4/","excerpt":"","text":"42. 接雨水给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 知识点：双指针 分析：根据木桶理论，每个位置能存放的雨水数量取决于该点左右两边的最高柱子中低的那个，即找出当前位置Math.min(leftMax,rightMax),然后该值减去当前节点的高度即为可存放雨水的数量。 代码如下：12345678910111213141516171819202122232425262728class Solution &#123; public int trap(int[] height) &#123; int maxLeft = 0,maxRight = 0,sum = 0; //left和right为计算存水量的位置 int left = 1,right = height.length-2; while(left&lt;=right)&#123;//此处必须可=，最后一个存水位置也要计算 if(height[left-1]&lt;height[right+1])&#123;//这说明右侧比较高，存水得按照左侧来计算 //看下左边最高能到哪个位置 maxLeft = Math.max(height[left-1],maxLeft); //只有当前柱子高度小于左侧最大值时才可以存水 if(height[left]&lt;maxLeft)&#123; sum+=maxLeft-height[left]; &#125; //如果当前这个柱子没法存水，那就考虑下一个 left++; //右侧同理 &#125;else&#123; maxRight = Math.max(maxRight,height[right+1]); if(maxRight&gt;height[right])&#123; sum+=maxRight-height[right]; &#125; right--; &#125; &#125; return sum; &#125;&#125;","categories":[{"name":"leetcode刷题笔记","slug":"leetcode刷题笔记","permalink":"http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"leetcode-N个数之和","slug":"leetcode-N个数之和","date":"2021-06-21T16:00:00.000Z","updated":"2021-07-22T10:19:55.368Z","comments":true,"path":"2021/06/22/leetcode-N个数之和/","link":"","permalink":"http://example.com/2021/06/22/leetcode-N%E4%B8%AA%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"2. 两数相加给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 知识点：链表 分析：这个题目不难，重点在于想清楚即可，还有处理好细节。 代码入下：123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode resHead = new ListNode(-1); ListNode curNode = resHead; int plus = 0; while(l1!=null||l2!=null)&#123; int num1 = l1==null?0:l1.val; int num2 = l2==null?0:l2.val; int sum = num1+num2+plus; plus = sum/10; int curNum = sum%10; curNode.next = new ListNode(curNum); curNode = curNode.next; if(l1!=null)&#123; l1 = l1.next; &#125; if(l2!=null)&#123; l2 = l2.next; &#125; &#125; if(plus!=0)&#123; curNode.next = new ListNode(plus); &#125; return resHead.next; &#125;&#125; 15. 三数之和知识点：双指针给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 分析：三个数之和为零，肯定得有负数，或者全是0，先对数组进行排序，然后开始遍历； 如果nums[i]&gt;0，则说明后面的数字已经全部大于0，不可能再有满足条件的数组，直接返回结果； 如果nums[i]+nums[left]+nums[right]=0，进行记录，并将left和right分别进行右移和左移，直到找到不重复的元素为止； 如果和小于0，让左指针右移；和大于0，就让右指针左移。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if(nums[i]&gt;0)&#123; return resList; &#125; if(i&gt;0&amp;&amp;nums[i]==nums[i-1])&#123; continue; &#125; int left = i+1,right = nums.length-1; while(left&lt;right)&#123; int curSum = nums[i]+nums[left]+nums[right]; if(curSum==0)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); resList.add(list); while (left&lt;right&amp;&amp;nums[left]==nums[left+1])&#123; left++; &#125; while(left&lt;right&amp;&amp;nums[right]==nums[right-1])&#123; --right; &#125; ++left; --right; &#125;else if(curSum&lt;0)&#123; left++; &#125;else&#123; right--; &#125; &#125; &#125; return resList; &#125;&#125;","categories":[{"name":"leetcode刷题笔记","slug":"leetcode刷题笔记","permalink":"http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"leetcode-股票问题","slug":"leetcode-股票问题","date":"2021-06-20T16:00:00.000Z","updated":"2021-07-30T02:45:02.386Z","comments":true,"path":"2021/06/21/leetcode-股票问题/","link":"","permalink":"http://example.com/2021/06/21/leetcode-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"121. 买卖股票的最佳时机给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 知识点：动态规划分析：其实这个题的本质就是求出两者之差，先找到一个值i，只要后面有比i大的，就记录下差值；不断将i往小处更新，不断比较差值。 代码如下：123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; int len = prices.length; int min = Integer.MAX_VALUE,res=0; //将min不断更新为较小值，只要超过min，便计算是否可取的更大利润并记录 for(int i=0;i&lt;len;i++)&#123; if(prices[i]&lt;min)&#123; min = prices[i]; &#125;else&#123; res = Math.max(res,prices[i]-min); &#125; &#125; return res; &#125;&#125; 122. 买卖股票的最佳时机 II给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 知识点：动态规划分析：想一下，多笔交易且必须卖出去之后再买进，也就是说，当前状态只有两种：持有股票、未持有股票。 持有股票：要么卖出去，要么什么都不做 未持有：要么买进，要么什么都不做 到最后一天的时候，肯定是不持有股票利润更高，做一个dp数组，用0和1分别表示未持有和持有，详情见代码。 一般来说，对于动态规划都会有空间方面的优化。 代码如下 ：1234567891011121314151617181920212223242526272829303132package LC0122_best_time_to_buy_and_sell_stock_II;public class BestTimeToBuyAndSellStockII &#123; public int maxProfit(int[] prices) &#123; int len = prices.length; int[][] dp = new int[2][len]; //dp均为当天交易完后的利润 //在第0天未持有股票利润 dp[0][0] = 0; //在第0天持有股票的利润 dp[1][0] = -prices[0]; for(int i=1;i&lt;len;i++)&#123; //第i天没持有股票，要么是前一天有，卖了；要么是昨天也没 dp[0][i] = Math.max(dp[1][i-1]+prices[i],dp[0][i-1]); //第i天持有股票，今天刚买，或者昨天就有，没卖 dp[1][i] = Math.max(dp[1][i-1],dp[0][i-1]-prices[i]); &#125; return dp[0][len-1]; &#125; //对上述dp代码进行空间优化 public int maxProfit(int[] prices)&#123; int len = prices.length; int hold = -prices[0],unhold = 0; for (int i = 0; i &lt; len; i++) &#123; int tmpHold = hold,tmpUnhold = unhold; hold = Math.max(tmpHold,tmpUnhold-prices[i]); unhold = Math.max(tmpUnhold,tmpHold+prices[i]); &#125; return unhold; &#125;&#125; 123. 买卖股票的最佳时机 III给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 知识点：动态规划分析：只能交易两次，也就是挣两个差值，最后一天结束的时候，有五种情况： 一次交易都没有 只买进了一次 买一次，卖一次，即完成一次交易 交易一次，买第二次 交易两次。 第一种为0，不必理会。以下四种的利润分别记为不用buy1，sell1，buy2，sell2。详情见代码 代码如下：123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; int buy1 = -prices[0]; int sell1 = 0; int buy2 = -prices[0]; int sell2 = 0; for(int i=1;i&lt;prices.length;i++)&#123; buy1 = Math.max(buy1,-prices[i]); sell1 = Math.max(sell1,buy1+prices[i]); buy2 = Math.max(buy2,sell1-prices[i]); sell2 = Math.max(sell2,buy2+prices[i]); &#125; return sell2; &#125;&#125; 188. 买卖股票的最佳时机 IV给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 知识点：数组、动态规划分析：这个其实也就是个变形，有点不太好理解，你就这么记吧；[题解](买卖股票的最佳时机 IV - 买卖股票的最佳时机 IV - 力扣（LeetCode） (leetcode-cn.com)) 代码如下：123456789101112131415161718192021222324class Solution &#123; public int maxProfit(int k, int[] prices) &#123; int len = prices.length; k = Math.min(k, len / 2); if(k==0)&#123; return 0; &#125; //手上持有股票的利润 int[] buy = new int[k]; //手上未持有股票的利润 int[] sell = new int[k]; for(int i = 0;i&lt;k;i++)&#123; buy[i] = -prices[0]; &#125; //已经完成第i笔交易，第j天 for(int i=1;i&lt;len;i++)&#123; for(int j = 0;j&lt;k;j++)&#123; buy[j] = Math.max((j==0?0:sell[j-1])-prices[i],buy[j]); sell[j] = Math.max(buy[j]+prices[i],sell[j]); &#125; &#125; return sell[k-1]; &#125;&#125; 714. 买卖股票的最佳时机含手续费给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 知识点：动态规划、数组分析：和II最为相似，只是加了个手续费而已。 代码如下：1234567891011class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int hold = -prices[0],unhold = 0; for(int i=0;i&lt;prices.length;i++)&#123; int tmpHold = hold,tmpUnhold = unhold; hold = Math.max(tmpHold,tmpUnhold-prices[i]); unhold = Math.max(tmpUnhold,tmpHold+prices[i]-fee); &#125; return unhold; &#125;&#125; 309. 最佳买卖股票时机含冷冻期给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 **知识点：动态规划分析：算下来，当前的状态就三种，一种是持有股票（当然不在冷冻期）；一种是未持有（在冷冻期）；还有一种未持有（不在冷冻期），详情见代码。 代码如下：12345678910111213141516171819202122class Solution &#123; public int maxProfit(int[] prices) &#123; //当前持有股票 int hold = -prices[0]; //当前不持有股票 int unhold = 0; //当前在冷冻期 int cold = 0; for(int i=0;i&lt;prices.length;i++)&#123; int tmpHold = hold; int tmpUnhold = unhold; int tmpCold = cold; //今天持有，那说明要么是昨天就有；要么昨天冷冻期，今天又买的 hold = Math.max(tmpHold,tmpCold-prices[i]); //今天未持有：要么昨天就没；要么昨天持有今天卖了 unhold = Math.max(tmpUnhold,tmpHold+prices[i]); //今天冷冻期：必定昨天卖了 cold = tmpUnhold; &#125; return Math.max(Math.max(unhold,cold),0); &#125;&#125;","categories":[{"name":"leetcode刷题笔记","slug":"leetcode刷题笔记","permalink":"http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode-进制相关","slug":"leetcode-进制相关","date":"2021-06-19T16:00:00.000Z","updated":"2021-07-30T02:01:38.094Z","comments":true,"path":"2021/06/20/leetcode-进制相关/","link":"","permalink":"http://example.com/2021/06/20/leetcode-%E8%BF%9B%E5%88%B6%E7%9B%B8%E5%85%B3/","excerpt":"","text":"171. Excel表列序号给定一个Excel表格中的列名称，返回其相应的列序号。 例如， A -&gt; 1 B -&gt; 2 C -&gt; 3 … Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 … 示例 1: 输入: “A” 输出: 1 示例 2: 输入: “AB” 输出: 28 示例 3: 输入: “ZY” 输出: 701 知识点：进制相关分析：这本质上是个26进制题目，将26进制转为10进制。 代码如下：1234567891011class Solution &#123; public int titleToNumber(String columnTitle) &#123; int sum = 0,multiple = 1; for(int i=columnTitle.length()-1;i&gt;=0;i--)&#123; int curNumber = columnTitle.charAt(i)-&#x27;A&#x27;+1; sum += curNumber*multiple; multiple *= 26; &#125; return sum; &#125;&#125; 168. Excel表列名称给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。 例如： A -&gt; 1 B -&gt; 2 C -&gt; 3 … Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 … 示例 1： 输入：columnNumber = 1 输出：”A” 示例 2： 输入：columnNumber = 28 输出：”AB” 示例 3： 输入：columnNumber = 701 输出：”ZY” 示例 4： 输入：columnNumber = 2147483647 输出：”FXSHRXW” 提示： 1 &lt;= columnNumber &lt;= 231 - 1 知识点：进制问题分析：A是从1开始的，所以当数字是1时，没法直接让它+‘A’来对应字符，必须先减1。 代码如下：1234567891011class Solution &#123; public String convertToTitle(int columnNumber) &#123; StringBuilder sb = new StringBuilder(); while(columnNumber&gt;0)&#123; columnNumber--; sb.append((char)(&#x27;A&#x27;+columnNumber%26)); columnNumber /= 26; &#125; return sb.reverse().toString(); &#125;&#125;","categories":[{"name":"leetcode刷题笔记","slug":"leetcode刷题笔记","permalink":"http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"进制问题","slug":"进制问题","permalink":"http://example.com/tags/%E8%BF%9B%E5%88%B6%E9%97%AE%E9%A2%98/"}]},{"title":"leetcode-无重复最长字符串","slug":"leetcode-无重复最长字符串","date":"2021-06-17T16:00:00.000Z","updated":"2021-07-21T01:34:20.052Z","comments":true,"path":"2021/06/18/leetcode-无重复最长字符串/","link":"","permalink":"http://example.com/2021/06/18/leetcode-%E6%97%A0%E9%87%8D%E5%A4%8D%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"3. 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 知识点：双指针、滑动窗口 分析：这个问题的解决模型是滑动窗口。同时定义两个指针，一个临时固定p1，一个不断扫描p2；当p2扫描至已包含的字符时，让p1后移，直至不包含重复字符。在此需要用到一个collection：HashSet，用于记录已扫描的字符和判断是否包含下一个字符；每次p1后移之前，记录下无重复的最大长度。 代码如下：123456789101112131415161718class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); HashSet&lt;Character&gt; set = new HashSet&lt;&gt;(); int right = -1,res = 0; for(int i=0;i&lt;len;i++)&#123; if(i!=0)&#123; set.remove(s.charAt(i-1)); &#125; while(right&lt;len-1&amp;&amp;!set.contains(s.charAt(right+1)))&#123; set.add(s.charAt(right+1)); ++right; &#125; res = Math.max(res,right-i+1); &#125; return res; &#125;&#125;","categories":[{"name":"leetcode刷题笔记","slug":"leetcode刷题笔记","permalink":"http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"Vue基础","slug":"vue基础","date":"2021-06-16T16:00:00.000Z","updated":"2021-08-02T07:46:50.325Z","comments":true,"path":"2021/06/17/vue基础/","link":"","permalink":"http://example.com/2021/06/17/vue%E5%9F%BA%E7%A1%80/","excerpt":"","text":"入门1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--插值表达式--&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;script&gt; new Vue(&#123; //取路径 el:&#x27;#app&#x27;, //定义变量名字和变量值 data:&#123; message:&#x27;Hello Vue&#x27; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 单向绑定和双向绑定 采用双向绑定时，相当于将修改权一并给出，若在网页端进行修改，其他位置的引用值一并变化 采用单向绑定时，修改该值仅仅是修改该位置的值，其他位置的引用值不会变化 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--单向绑定--&gt; &lt;div v-bind:style=&quot;msg&quot;&gt;单向绑定&lt;/div&gt; &lt;!--简写方式：直接写：--&gt; &lt;div :style=&quot;msg&quot;&gt;单向绑定简写&lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg:&quot;color:red;&quot; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--内容中可通过插值表达式取到值，在属性中使用单向绑定或者双向绑定--&gt; &#123;&#123;msg&#125;&#125; &lt;br/&gt; &lt;!--单向绑定--&gt; &lt;input type=&quot;text&quot; :value=&quot;msg&quot;/&gt; &lt;br/&gt; &lt;!--双向绑定--&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;/&gt; &lt;/div&gt; &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg:&quot;vue项目&quot; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件绑定1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;show1&quot;&gt;事件绑定&lt;/button&gt; &lt;!-- 简写方式如下 --&gt; &lt;button @click=&quot;show2&quot;&gt;事件绑定2&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg:&quot;vue项目&quot; &#125;, methods:&#123; show1()&#123; console.log(&quot;这是vue中定义的一个方法&quot;) &#125;, show2()&#123; console.log(&quot;这是vue中定义的第二个方法&quot;) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 条件渲染指令1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;ok&quot;/&gt; &lt;br/&gt; &lt;div v-if=&quot;ok&quot;&gt;已选&lt;/div&gt; &lt;div v-else&gt;未选&lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; ok:false &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 循环指令1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 循环遍历userList，每个遍历到的对象取名user;添加index是列表的索引（从0开始） --&gt; &lt;div v-for=&quot;(user,index) in userList&quot;&gt; &#123;&#123;index&#125;&#125;--&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.age&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; userList:[ &#123;&quot;name&quot;:&quot;Neo&quot;,age:31&#125;, &#123;&quot;name&quot;:&quot;Alex&quot;,age:29&#125; ] &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 生命周期created方法在页面渲染之前执行，mounted方法在页面渲染之后执行 代码测试： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt; &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg:&quot;hello&quot; &#125;, created()&#123; debugger console.log(&quot;created...&quot;)//页面渲染之前执行 &#125;, mounted()&#123; debugger console.log(&quot;mounted...&quot;)//页面渲染之后执行 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; axios通过axios发送ajax请求，来获取json中的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 通过列表进行输出 --&gt; &lt;table&gt; &lt;!-- 采用循环指令 --&gt; &lt;tr v-for=&quot;user in userList&quot;&gt; &lt;td&gt;&#123;&#123;user.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;user.age&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;axios.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; userList:[] &#125;, created()&#123;//在页面渲染之前执行 //调用方法，得到返回的json数据 this.getList() &#125;, methods:&#123; getList()&#123; //使用axios方式ajax请求 axios.get(&quot;user.json&quot;) .then(response =&gt; &#123;//请求成功 console.log(response) this.userList=response.data.data.items console.log(this.userList) &#125;) .catch(error =&gt; &#123;//请求失败 console.log(error) &#125;) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HelloWorld系列","slug":"HelloWorld系列","permalink":"http://example.com/categories/HelloWorld%E7%B3%BB%E5%88%97/"}],"tags":[]},{"title":"ES6语法","slug":"ES6语法","date":"2021-06-15T16:00:00.000Z","updated":"2021-08-02T07:48:57.955Z","comments":true,"path":"2021/06/16/ES6语法/","link":"","permalink":"http://example.com/2021/06/16/ES6%E8%AF%AD%E6%B3%95/","excerpt":"","text":"定义变量12345678//var是全局变量，let是局部变量var a = 1;let b = 2;//var可对一变量进行多次定义，let对同一变量尽可定义一次var a = 10;var a = 20;let b = 30; 定义常量常量定义时，声明时必须进行初始化；一旦声明不可更改 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; const A = 10; console.log(A) //10 const B = &quot;你好，ES&quot; //你好，ES console.log(B) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 解构赋值12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //解构赋值 let a = 1,b = 2, c = 3 console.log(a,b,c) //ES6可写法如下 let[x,y,z] = [1,2,3] console.log(x,y,z) //对象解构(常用) let user = &#123;name:&#x27;Helen&#x27;,age:18&#125; //传统方式 let name1 = user.name let age1 = user.age console.log(name1,age1) //ES6 let&#123;name,age&#125; = user console.log(name,age) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 模板字符串模板字符串可对定义的变量进行通过$进行引用，并进行简单的运算，以及在输出时进行换行 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let name = &quot;Luna&quot; let age = 19 let info = `My name is $&#123;name&#125; and I am $&#123;age+1&#125; years old next year.` console.log(info) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 定义对象12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; const name = &quot;Alex&quot;,age = 20 //传统写法 // const user = &#123;name:name,age:age&#125; // console.log(user) //ES6 const user = &#123;name,age&#125; //要想这样写，变量名称必须一致 console.log(user) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 对象拓展运算符主要用于对象的复制和对象的合并 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //对象复制 let person = &#123;name:&quot;Alex&quot;,age:38&#125; //通过...可对指定对象内所有属性进行遍历并进行赋值给当前对象 let someone = &#123;...person&#125; console.log(someone) //对象合并 let name1 = &#123;name:&quot;Hony&quot;&#125;,age1 = &#123;age:40&#125; let someother = &#123;...name1,...age1&#125; console.log(someother) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 箭头函数1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //传统方式定义函数 var f1 = function(a) &#123; return a+1 &#125; console.log(f1(4)) //箭头函数 //单个参数时，可省略（） var f2 = (a) =&gt; 2*a console.log(f2(2)) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HelloWorld系列","slug":"HelloWorld系列","permalink":"http://example.com/categories/HelloWorld%E7%B3%BB%E5%88%97/"}],"tags":[]},{"title":"MyHospital项目笔记","slug":"MyHospital","date":"2021-06-09T16:00:00.000Z","updated":"2021-07-24T02:46:37.432Z","comments":true,"path":"2021/06/10/MyHospital/","link":"","permalink":"http://example.com/2021/06/10/MyHospital/","excerpt":"","text":"ip和端口号总结：sql的IP地址：192.168.75.200，端口号：3306 nginx的端口号：30001 ——用于分发端口号 mongo的ip：192.168.75.200，端口号27017 ——-用于存储数据 nacos—–服务注册中心，端口号8848 redis的ip地址：192.168.75.200，端口号6379 rabbitmq：ip192.168.75.200,端口号15672 管理端口号5672 1、版本问题 ans：之前在测试MyBatis Plus的时候，这个2.2.1.RELEASE版本一直报红，我采用了2.5.0，但是在此处不知道为什么没用也未发现报红。 2、工具swagger2在前期进行测试的时候，类似测试获取数据这种操作，可以直接通过访问固定网页（如：http://localhost:8201/admin/hosp/hospitalSet/findall）进行测试；但是在测试删除功能（根据id进行删除）时，便没法通过直接访问网页进行删除；故，在这里采用swagger2进行测试，通过对swagger2进行配置，并采用注解的方式对网页显示进行优化，使得可阶段性对功能进行测试。 3、工具Result为了统一返回结果（有人用1表示成功，有人用true表示成功…），故创建一个结果类Result，用于统一对返回结果的管理。 之后函数返回类型便可设置为Result，将原本的返回结果进行包装即可返回。 123456789101112131415161718192021//1、查询医院设置表所有信息 @ApiOperation(value = &quot;获取所有医院设置&quot;) @GetMapping(&quot;findAll&quot;) public Result findAllHospitalSet()&#123; //调用service方法 List&lt;HospitalSet&gt; list = hospitalSetService.list(); //此处便对原本返回的list进行包装，源码在此处不再贴出，后续会上传至我的gitee return Result.ok(list); &#125; //2、逻辑删除医院设置 @ApiOperation(value = &quot;逻辑删除医院设置&quot;) @DeleteMapping(&quot;&#123;id&#125;&quot;) public Result removeHospSet(@PathVariable Long id)&#123; boolean flag = hospitalSetService.removeById(id); if(flag)&#123; return Result.ok(); &#125;else&#123; return Result.fail(); &#125; &#125; 4、babel问题在安装使用babel时，安装之后无法显示版本号，问题如下 ans：在安装时为全局配置，此处找不到babel应该是未进行环境路径配置，故在系统变量中添加路径 babel的路径可通过如下命令获得 然后添加进系统环境变量中，重启vscode 5、笔记：前端设置步骤1、添加路由在src/router/index.js中添加代码 2、设置跳转页面路径在路由代码中进行设置 3、在api文件夹创建js文件，定义接口路径红线处为后端代码中设置的路径 4、在页面引入js文件，使用axios进行接口调用，把接口返回数据在页面显示12345678910111213141516171819202122232425262728293031323334353637383940&lt;!--template是页面中显示的数据 --&gt;&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; 医院设置列表 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//引入接口定义的js文件import hospset from &#x27;@/api/hospset&#x27;export default &#123; data() &#123; return &#123; current:1,//当前页 limit:3,//每页显示记录数 searchObj:&#123;&#125;,//条件封装对象 list:[] //每页数据集合 &#125; &#125;, created()&#123;//在页面渲染之前执行 //一般调用methods定义的方法，得到数据 this.getList() &#125;, methods: &#123;//定义方法，进行请求接口调用 //医院设置列表 getList() &#123; hospset.getHospSetList(this.current,this.limit,this.searchObj) .then(response =&gt; &#123;//请求成功，response是接口返回数据 console.log(response) &#125;) .catch(error =&gt; &#123;//请求失败，error是错误提示 console.log(error) &#125;) &#125; &#125;&#125;&lt;/script&gt; 6、跨域问题三个地方，任何一个不相同便会产生跨域1、访问协议：http https 2、访问地址：192.128.1.1 172.11.1.1 3、端口号：9528 8201 解决方式：第一种：添加CrossOrigin注解 这个得配合nginx使用 第二种：采用gateway进行配置 7、粗心问题 我没添加@CrossOrigin注解，不同端口号是没法访问的，应该是No Access-Control-Allow-Origin，就是下面这个 ans：应该是在返回数据中未添加条件封装对象导致的 8、问题 当前前端已经可以获得数据，前端代码也已经编写完毕，应该是可以按照表格形式进行显示，但是没数据显示，为什么 ans：在调用函数中未返回结果，并未将获取到的response的data返回给当前list 改完结果如下： 9、问题在添加锁定和取消锁定功能时，写好代码之后，锁定和取消锁定按钮提示失败，为什么 ans：在api文件中取值路径写错了，id和status没res写$，修正后如下 10、问题再记录个问题，这个没来得及截图，（我可能误操作点着了什么，导致vscode关闭了，然后又打开）发现通过npm run dev无法进行运行，错误提示在D:\\Coding\\myproject\\hospital\\yygh路径下（我的vue-admin-template-master文件夹也是在这个路径下）没有package.json文件，可是package.json不是在vue-admin-template-master目录下吗 ans：怀疑是误删了什么资源文件，于是采用npm install 进行重新下载依赖，即可打开 11、问题为什么没法保存 ans：经debug发现，在添加医院设置时，主键id并未进行设置，故报错 可是我主键id设置了自增，不必手动进行设置即可；在mysql中添加数据发现确实必须要设置id，于是对id的自增属性进行重新设置，问题解决。 12、问题（redis）在设置redis进行缓存的时候出现问题，报错如下 org.springframework.data.redis.RedisConnectionFailureException: Unable to connect to Redis; nested exception is org.springframework.data.redis.connection.PoolException: Could not get a resource from the pool; nested exception is io.lettuce.core.RedisConnectionException: Unable to connect to 192.168.75.200:6379 之前报错说没法连接，没password，我在配置文件添加了password，ok 现在有说还是没法连接到redis，可是IP地址和端口号都没问题，我也关了防火墙：systemctl stop firewalld，为什么还是报错 而且还提示说我主机中的软件终止了一个已建立的连接 经查阅资料，将redis的config文件中的protected-mode改为no，看看有没有效果 –没效果 再把这个改为0.0.0.0 ans：我搞定了将protected-mode 改为no，再再把bind改为0.0.0.0 修改完redis配置记得重启redis服务 13、笔记：nginx解决多端口访问问题下载nginx，在nginx配置文件添加如下内容： （视频用的是9001）之后将前端的配置端口号改为30001，至此，所有端口号请求发送至30001，再由nginx对不同的关键字进行正则匹配，分发至各自端口号 14、MongoDB的安装和使用第一步： 使用docker拉取mongoDB镜像 1docker pull mongo:latest 第二步： 创建和启动容器 1docker run -d --restart=always -p 27017:27017 --name mymongo -v /data/db:/data/db -d mongo 进入创建的容器 1docker exec -it mymongo /bin/bash 注意：使用容器mongodb之前记得先启动docker，之后进入创建的容器 123service docker start//也可也如下启动dockersystemctl start docker 15、问题（说lombok不支持我的编译器）诡异，我前几个模块都用了lombok，现在跟我说不支持… ans：改了lombok版本号，就没出现这个错了 16、登录mysql1mysql -uroot -p123456 17、笔记（MongoDB数据访问）这个厉害，Spring Data提供了对mongodb数据访问的支持，只需要继承MongoRepository类，按照Spring Data规范进行命名函数即可自动生成 1、不是随便声明的，而需要符合一定的规范 2、 查询方法以find | read | get开头 3、 涉及条件查询时，条件的属性用条件关键字连接 4、 要注意的是：条件属性首字母需要大写 18、HttpServletRequest疑问(已解决)：D:\\Coding\\myproject\\hospital\\yygh_parent\\service\\service_hosp\\src\\main\\java\\com\\myproject\\yygh\\hosp\\controller\\api\\ApiController.java这个里面的这些功能是怎么通过HttpServletRequest request来得到数据的 19、问题在将cmn模块添加进nacos服务中时，启动该模块报错（可是我另外一个服务已经启动了，为什么cmn会报错，说是mongo打不开socket） 上网查资料说原因是springboot自动配置了支持mongodb。在启动springboot时会自动实例化一个mongo实例，需要禁用自动配置 ，增加 @SpringBootApplication(exclude = MongoAutoConfiguration.class) ans：搞定，成功启动 20、问题DictFeignClient这个接口定义了，也注解Repository了，在调用的时候也进行自动装配了，为什么会说找不到这个bean 网上有人说是没有指定包，我试下 ans：确实如此，也不尽然；在该服务下未引入需要用到的feign依赖，服务启动时也未注明引用包的路径，添加依赖和写好包的路径即可 21、问题之前采用的nginx，后来采用配置网关进行接口转发，但是服务启动后提示跨域问题 ans:要么接着使用@CrossOrigin注解，要么写个配置类 22、笔记：nuxt路由跳转nuxt中路由跳转分为两种：固定路由、动态路由 固定路由：跳转路径固定，只能是某个指定页面；默认vue文件名称：index.vue 动态路由：每次可根据参数跳转至不同页面 ​ 创建页面规则：在文件夹下创建vue文件；vue文件命名规范：_参数名称.vue；以下划线开头 23、疑问（已解决）HttpServletRequest是干嘛用的 –ans：见笔记 24、待定（搞定）在p143这里，我的就诊人信息刷新不出，不清楚是不是因为patient的信息写的不够完整；之后还要做添加就诊人员的信息，暂且放置。 25、QuerryWrapper温故(搞定)QuerryWrapper的条件查询和模糊查询，记得看一下源码人家是怎么实现的。 –ans：源码封装了sql语句，可以实现简单的查找 26、Feign温故（未搞定）Feign这个注解是干啥的 Feign的使用（未完成） 27、rabbitMQ温故（未搞定）rabbitMQ 28、rabbitmq启动这个是创建并启动： 1docker run -d -p 5672:5672 -p 15672:15672 --name rabbitmq rabbitmq:management 启动rabbitmq容器的话，先用 1docker exec -it rabbitmq /bin/bash 查找所有容器id，是一串数字，然后再启动该容器 1docker start 925153afeb449859b139ba8b9977312ec0dd1bfedf86772ddc735b72f466803b ,接下来即可启动rabbitmq。 29、问题（空指针异常p160）","categories":[{"name":"项目Hospital","slug":"项目Hospital","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AEHospital/"}],"tags":[]},{"title":"leetcode-回文字符串","slug":"leetcode-回文字符串","date":"2021-06-09T16:00:00.000Z","updated":"2021-06-10T12:53:24.431Z","comments":true,"path":"2021/06/10/leetcode-回文字符串/","link":"","permalink":"http://example.com/2021/06/10/leetcode-%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"5. 最长回文子串知识点：manacher算法题目描述：给你一个字符串 s，找到 s 中最长的回文子串。 分析：manacher算法的快捷在于将每个节点的最大臂长都记录在内，这样下次再查找的时候就不必再做重复工作；另外，对字符串进行处理（加特殊符号），使得字符串的长度全部都为奇数。 复杂度分析:时间复杂度：O(n)，其中 n 是字符串的长度。由于对于每个位置，扩展要么从当前的最右侧臂长 right 开始，要么只会进行一步，而 right 最多向前走 O(n) 步，因此算法的复杂度为 O(n)。 空间复杂度：O(n)，我们需要 O(n) 的空间记录每个位置的臂长。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public String longestPalindrome(String s) &#123; //处理字符串 StringBuffer t = new StringBuffer(&quot;$&quot;); for(int i=0;i&lt;s.length();i++)&#123; t.append(s.charAt(i)); t.append(&#x27;$&#x27;); &#125; s=t.toString(); //start为最长字符串的起始，end为其末端 int start=0,end=-1; //right为当前最长回文串的最右端，j为最长回文串对称中心 int right=-1,j=-1; List&lt;Integer&gt; armLength = new ArrayList&lt;&gt;(); for(int i=0;i&lt;s.length();i++)&#123; int curArmLength; if(i&lt;=right)&#123;//如果当前位置在最长回文串范围内部 int iSym=j*2-i; int minArm=Math.min(right-i,armLength.get(iSym));//找到可以确定的臂长 curArmLength=getArmLength(s,i-minArm,i+minArm);//扩展臂长 &#125;else&#123;//没有就重头开始找 curArmLength=getArmLength(s,i,i); &#125; //对数据进行更新 armLength.add(curArmLength); if(right&lt;i+curArmLength)&#123; j=i; right=i+curArmLength; &#125; if(end-start&lt;curArmLength*2+1)&#123; start=i-curArmLength; end=i+curArmLength; &#125; &#125; //再次处理字符串，消除特殊字符 StringBuffer res = new StringBuffer(); for(int i=start;i&lt;=end;i++)&#123; if(s.charAt(i)!=&#x27;$&#x27;)&#123; res.append(s.charAt(i)); &#125; &#125; return res.toString(); &#125; //找到字符串的臂长 public int getArmLength(String s,int left,int right)&#123; while(left&gt;=0&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123; --left; ++right; &#125; return (right-left-2)/2; &#125; 214. 最短回文串题目描述：给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。 示例 1： 输入：s = “aacecaaa” 输出：”aaacecaaa” 示例 2： 输入：s = “abcd” 输出：”dcbabcd” 知识点：字符串、manacher、KMP分析：这个题目前没解决，走了个递归的路子，我尝试用manacher进行计算，超时了，但是有人的manacher没超时，说明我的manacher还有待改进；这个题用KMP是最好的，还有个解法是用的字符串哈希，那个是“投机取巧”了(我也不会用)。 已经掌握KMP模式匹配算法。 KMP代码如下：12345678910111213141516171819202122232425262728293031class Solution &#123; public String shortestPalindrome(String s) &#123; int len = s.length(); //next为当前字符串的最大前缀后缀匹配个数 int[] next = new int[len]; for(int i=1,size=0;i&lt;len;i++)&#123; //这个是回溯的意思，如果当前字符和下一个字符不相等，那就将size改为上次相等的那个位置 while(size&gt;0&amp;&amp;s.charAt(i)!=s.charAt(size))&#123; size=next[size-1]; &#125; if(s.charAt(i)==s.charAt(size))&#123; ++size; &#125; next[i]=size; &#125; int index=0; for(int i=len-1;i&gt;=0;i--)&#123; //这个是相当于将S和其倒序字符串进行了求最大前缀后缀匹配个数 while(index&gt;0&amp;&amp;s.charAt(i)!=s.charAt(index))&#123; index=next[index-1]; &#125; if(s.charAt(index)==s.charAt(i))&#123; ++index; &#125; &#125; //注意此处的index，如果s为回文字符串，则index就是s的length String add = (index==len?&quot;&quot;:s.substring(index)); StringBuilder sb = new StringBuilder(add); return sb.reverse().append(s).toString(); &#125;&#125;","categories":[{"name":"leetcode刷题笔记","slug":"leetcode刷题笔记","permalink":"http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"leetcode-跳跃次数","slug":"leetcode-跳跃次数","date":"2021-06-09T16:00:00.000Z","updated":"2021-06-10T12:40:17.238Z","comments":true,"path":"2021/06/10/leetcode-跳跃次数/","link":"","permalink":"http://example.com/2021/06/10/leetcode-%E8%B7%B3%E8%B7%83%E6%AC%A1%E6%95%B0/","excerpt":"","text":"55. 跳跃游戏知识点：贪心算法题目描述：给定一个非负整数数组nums，你最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标 分析：维护每个位置所能到达的最右位置rightPositon，不断更新这个rightPositon，直到rightPositon大于等于最后的位置，或者遍历至数组最后一位也无法到达。 代码如下： 123456789101112131415class Solution &#123; public boolean canJump(int[] nums) &#123; int len = nums.length; int rightMost = 0;//维持一个最右边的位置 for(int i = 0;i&lt;len;i++)&#123; if(i&lt;=rightMost)&#123; rightMost = Math.max(rightMost,i+nums[i]);//动态维护最右侧的位置 if(rightMost&gt;=len-1)&#123;//此时说明已经可以到达最后位置 return true; &#125; &#125; &#125; return false; &#125;&#125; 45. 跳跃游戏 II知识点：贪心算法题目描述：给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。 分析：关键点在于什么时候记录跳跃次数step，明确一点，如果在某一点i，所能到达的最远处rightPosition也无法到达最后一个位置时，那就需要再跳一次，即step++；故，每当i所能到达的rightPosition未到达最后一个位置，i又已经到达了当前能到达的最远位置（已经不得不跳了），则step++。 代码如下：123456789101112131415class Solution &#123; public int jump(int[] nums) &#123; int size=nums.length; //end为未跳之前所能到达的最远位置 int end=0,mostRight=0,steps=0; for(int i=0;i&lt;size-1;i++)&#123; mostRight=Math.max(mostRight,i+nums[i]); if(i==end)&#123; end=mostRight; steps++; &#125; &#125; return steps; &#125;&#125;","categories":[{"name":"leetcode刷题笔记","slug":"leetcode刷题笔记","permalink":"http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"leetcode-重构二叉树","slug":"leetcode-重构二叉树","date":"2021-06-09T16:00:00.000Z","updated":"2021-06-10T12:48:32.863Z","comments":true,"path":"2021/06/10/leetcode-重构二叉树/","link":"","permalink":"http://example.com/2021/06/10/leetcode-%E9%87%8D%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"105. 从前序与中序遍历序列构造二叉树知识点：树、递归题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 分析： 二叉树遍历 前序 根节点 左子树 右子树 中序 左子树 根节点 右子树 后序 左子树 右子树 根节点 根据二叉树遍历的特点 ，前序遍历的第一个节点就是根节点；而在中序遍历中可根据根节点的坐标位置将整个数组分为左子树和右子树。在本题中，重点落在了中序遍历上，首先对中序遍历建立一个HashMap，k为数组的值，v为该值在中序遍历中的位置。根据前序遍历找到根节点root的位置，然后通过HashMap找到root在中序遍历中的位置，之后便可根据中序遍历确定左子树和右子树的长度；由于子树长度确定了，则可在前序遍历中确定左右子树的根节点，便可进行递归查找所有节点的位置。 代码如下：1234567891011121314151617181920212223242526272829class Solution &#123; //preorder和HashMap在两个函数中都会用到 int[] preorder; HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) &#123; this.preorder=preorder; for(int i=0;i&lt;inorder.length;i++)&#123; map.put(inorder[i],i); &#125; return recur(0,0,inorder.length-1); &#125; //rootIndex为前序遍历中根节点的位置，leftIndex为中序遍历中子树的左端，rightIndex为中序遍历中子树的右端， public TreeNode recur(int rootIndex,int leftIndex,int rightIndex)&#123; if(leftIndex&gt;rightIndex)&#123; return null; &#125; TreeNode root=new TreeNode(preorder[rootIndex]); int rootIndexInOrder=map.get(preorder[rootIndex]); //递归建立左子树 root.left=recur(rootIndex+1,leftIndex,rootIndexInOrder-1); //解释下rootIndex+rootIndexInOrder-leftIndex+1，这个式子为 //rootIndex+[（rootIndexInOrder-1）-leftIndex+1]+1， //其实就是找到前序遍历中右子树开始的那个位置，当前根节点的位置+左子树长度+1 //递归建立右子树 root.right=recur(rootIndex+rootIndexInOrder-leftIndex+1,rootIndexInOrder+1,rightIndex); //返回根节点 return root; &#125;&#125; 106. 从中序与后序遍历序列构造二叉树题目描述：根据一棵树的中序遍历与后序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 知识点：二叉树代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; Map&lt;Integer,Integer&gt; map= new HashMap&lt;&gt;(); int[] postorder; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; this.postorder=postorder; int len = inorder.length; for(int i=0;i&lt;inorder.length;i++)&#123; map.put(inorder[i],i); &#125; TreeNode root = dfs(len-1,0,len-1); return root; &#125; /** * 对当前节点的左右子树进行构建 * @param rootIndex 根节点在后序遍历中的位置 * @param leftIndex 当前子树在中序遍历中的左边界 * @param rightIndex 当前子树在中序遍历中的右边界 * @return 根节点 */ private TreeNode dfs(int rootIndex, int leftIndex, int rightIndex) &#123; if(leftIndex&gt;rightIndex)&#123; return null; &#125; TreeNode node = new TreeNode(postorder[rootIndex]); int rootInorder = map.get(postorder[rootIndex]); int leftLen = rootInorder-leftIndex; node.left=dfs(rootIndex-(rightIndex-leftIndex+1)+leftLen,leftIndex, rootInorder-1); node.right=dfs(rootIndex-1,rootInorder+1,rightIndex); return node; &#125;","categories":[{"name":"leetcode刷题笔记","slug":"leetcode刷题笔记","permalink":"http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"leetcode-岛屿问题","slug":"岛屿问题","date":"2021-06-07T16:00:00.000Z","updated":"2021-06-08T08:35:19.294Z","comments":true,"path":"2021/06/08/岛屿问题/","link":"","permalink":"http://example.com/2021/06/08/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/","excerpt":"","text":"200. 岛屿数量知识点：DFS分析：这题让求的是岛屿的数量有多少个，就其解法思路上并不困难。循环遍历每一块陆地，每遇到一个陆地就对其上下左右四个方向进行查找，每找到一个就让该陆地置0，这样在最外层遍历时就不会重复遇到，dfs的主要作用就是对遇到的陆地进行四个方向的查找。 代码如下：12345678910111213141516171819202122232425262728293031class Solution &#123; public int numIslands(char[][] grid) &#123; if(grid == null || grid.length==0)&#123;//简单判断是否为空 return 0; &#125; int count= 0,m =grid.length,n=grid[0].length; for(int i = 0;i&lt;m;i++)&#123; for(int j = 0;j&lt;n;j++)&#123;//外层遍历 if(grid[i][j]==&#x27;1&#x27;)&#123;//只要找到一个陆地，起码就是一个岛屿，对其进行dfs count++; dfs(grid,i,j); &#125; &#125; &#125; return count; &#125; void dfs(char[][] grid,int r,int c)&#123; int gr = grid.length; int gc = grid[0].length; if(r&lt;0||r&gt;=gr||c&lt;0||c&gt;=gc||grid[r][c]==&#x27;0&#x27;)&#123;//此处要注意边界条件 return; &#125; grid[r][c] = &#x27;0&#x27;;//遍历之前记得让当前岛屿下沉，不然之后会出现重复查找 dfs(grid,r+1,c); dfs(grid,r-1,c); dfs(grid,r,c+1); dfs(grid,r,c-1); &#125;&#125; 695. 岛屿的最大面积知识点：dfs分析：这两道题型基本一致，只是在本题中需要记录的数据不是数量，而是记录下每次dfs的最大值，关键点在dfs的编写中，每次dfs返回一个数字：0或者1。对于每个陆地而言，最小面积是1，最终面积取决于有多少和它间接、直接相连的陆地。 代码如下：还有个岛屿的周长，我觉得有个想法挺独树一帜的，值得学习 1234567891011121314151617181920212223class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; int res=0; for(int i=0;i&lt;grid.length;i++)&#123;// for(int j=0;j&lt;grid[0].length;j++)&#123;//外层还是遍历 if(grid[i][j]==1)&#123; res=Math.max(res,dfs(grid,i,j)); &#125; &#125; &#125; return res; &#125; public int dfs(int[][] grid,int m,int n)&#123; //要确定当前节点在范围内,且是个岛 if(m&lt;0||m&gt;=grid.length||n&lt;0||n&gt;=grid[0].length||grid[m][n]==0)&#123; return 0; &#125; //将当前节点置零 grid[m][n]=0; return 1+dfs(grid,m-1,n)+dfs(grid,m+1,n)+dfs(grid,m,n+1)+dfs(grid,m,n-1); &#125;&#125; 463. 岛屿的周长知识点：dfs分析：思路挺好，值得学习。题目中已经确定只有一个岛屿了，只是让求出岛屿的周长。难点在于怎么确定岛屿的哪一条边是有效周长，有个思路很好：在每个陆地向上下左右四个方向查找的时候，如果遇到边界或者是水域，则周长+1，这个想法挺好的，可以说很完美的贴切了岛屿边的这个定义。 代码如下： 注：其实这个查找周长也可以扩展一下，改为查找最大周长。 123456789101112131415161718192021222324252627282930class Solution &#123; public int islandPerimeter(int[][] grid) &#123; int res=0; for(int i=0;i&lt;grid.length;i++)&#123; for(int j=0;j&lt;grid[0].length;j++)&#123; if(grid[i][j]==1)&#123; res=dfs(grid,i,j); &#125; &#125; &#125; return res; &#125; public int dfs(int[][] grid,int r,int c)&#123; //如果从陆地遇到边界，则周长+1 if(!(r&gt;=0&amp;&amp;r&lt;grid.length&amp;&amp;c&gt;=0&amp;&amp;c&lt;grid[0].length))&#123; return 1; &#125; //如果从陆地遇到水域，则周长+1 if(grid[r][c]==0)&#123; return 1; &#125; //肯定是个2，那就说明已经找过了 if(grid[r][c]!=1)&#123; return 0; &#125; //对遍历过的点，置为2 grid[r][c]=2; return dfs(grid,r+1,c)+dfs(grid,r-1,c)+dfs(grid,r,c+1)+dfs(grid,r,c-1); &#125;&#125;","categories":[{"name":"leetcode刷题笔记","slug":"leetcode刷题笔记","permalink":"http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"leetcode-K字之谜","slug":"leetcode-K字之谜","date":"2021-06-06T16:00:00.000Z","updated":"2021-08-02T06:32:16.081Z","comments":true,"path":"2021/06/07/leetcode-K字之谜/","link":"","permalink":"http://example.com/2021/06/07/leetcode-K%E5%AD%97%E4%B9%8B%E8%B0%9C/","excerpt":"","text":"1337. 矩阵中战斗力最弱的 K 行给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。 请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。 如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。 军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。 示例 1： 12345678910111213141516输入：mat = [[1,1,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,0,0,0], [1,1,1,1,1]], k = 3输出：[2,0,3]解释：每行中的军人数目：行 0 -&gt; 2 行 1 -&gt; 4 行 2 -&gt; 1 行 3 -&gt; 2 行 4 -&gt; 5 从最弱到最强对这些行排序后得到 [2,0,3,1,4] 示例 2： 1234567891011121314输入：mat = [[1,0,0,0], [1,1,1,1], [1,0,0,0], [1,0,0,0]], k = 2输出：[0,2]解释： 每行中的军人数目：行 0 -&gt; 1 行 1 -&gt; 4 行 2 -&gt; 1 行 3 -&gt; 1 从最弱到最强对这些行排序后得到 [0,2,3,1] 知识点：二分查找、堆排序分析：这个题目的解决分为两步：找出每一行1的个数；按每行1的个数、行的索引进行排序。 代码如下：1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int[] kWeakestRows(int[][] mat, int k) &#123; int len = mat.length,n = mat[0].length; ArrayList&lt;int[]&gt; lists = new ArrayList&lt;&gt;(); for(int i=0;i&lt;len;i++)&#123; int left = 0,right = n-1,pos = -1; while(left&lt;=right)&#123; int mid = left+(right-left)/2; if(mat[i][mid]==0)&#123; right = mid-1; &#125;else&#123; pos = mid; left = mid+1; &#125; &#125; lists.add(new int[]&#123;pos+1,i&#125;); &#125; Collections.sort(lists, new Comparator&lt;int[]&gt;() &#123; @Override public int compare(int[] o1, int[] o2) &#123; if(o1[0]!=o2[0])&#123; return o1[0]-o2[0]; &#125;else&#123; return o1[1]-o2[1]; &#125; &#125; &#125;); int[] res = new int[k]; for(int i=0;i&lt;k;i++)&#123; res[i] = lists.get(i)[1]; &#125; return res; &#125;&#125; 注：我这里采用了普通排序，[题解](矩阵中战斗力最弱的 K 行 - 矩阵中战斗力最弱的 K 行 - 力扣（LeetCode） (leetcode-cn.com))里采用的是小顶堆，忘记的话可以看下。 215. 数组中的第K个最大元素在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4 知识点：堆、快排 分析： 可以维护一个大顶堆，删除k次最大元素，每次删除元素之后就重新调整堆内的数据位置，此时就是第K大的元素；这里简单创建并维护一个大顶堆。 代码入下：（堆排序法） 123456789101112131415161718192021222324252627package LC0215_kth_largest_element_in_an_array;import java.util.Comparator;import java.util.PriorityQueue;public class KthLargestElementInAnArray &#123; public int findKthLargest(int[] nums, int k) &#123; //建立大顶堆 PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125; &#125;); for(int num:nums)&#123; priorityQueue.offer(num); &#125; int ans = 0; while(k&gt;1)&#123; priorityQueue.poll(); --k; &#125; ans = priorityQueue.peek(); return ans; &#125;&#125; 除了直接用PriorityQueue之外，也得知道是怎么建立大顶堆的（小顶堆同理） 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; int len=nums.length; //创建一个大顶堆，len为堆的大小 buildHeap(nums,len); //要找到第k大的元素，需要剔除k-1个数据，也就是执行k-1次，所有i&gt;=nums.length-1-（k-2） for(int i=nums.length-1;i&gt;=nums.length-k+1;--i)&#123; //将最小的元素同最大的元素 swap(nums,0,i); --len; //每次消除元素之后，重新调整堆 maxHeapify(nums,0,len); &#125; return nums[0]; &#125; //创建一个大顶堆 public void buildHeap(int[] nums,int len)&#123; for(int i=len/2;i&gt;=0;i--)&#123;//此处i为堆中最靠后的一个有子树的节点，依次向上调整所有带有子树的节点 maxHeapify(nums,i,len); &#125; &#125; public void maxHeapify(int[] nums,int i,int size)&#123; //left为i的左子树，right为i的右子树 int left=2*i+1,right=2*i+2; //默认i为当前小子树中的最大值 int largest=i; if(left&lt;size&amp;&amp;nums[left]&gt;nums[largest])&#123; largest=left; &#125; if(right&lt;size&amp;&amp;nums[right]&gt;nums[largest])&#123; largest=right; &#125; if(largest!=i)&#123;//确保i位置的值为当前小子树的中的最大值 swap(nums,i,largest); maxHeapify(nums,largest,size);//并调整下更换过位置的子树 &#125; &#125; public void swap(int[] nums,int i,int j)&#123; int tmp=nums[i]; nums[i]=nums[j]; nums[j]=tmp; &#125;&#125; 这个题目还有个解法，可以用快排的思想来解决：我们找到一个数组内的随机数，然后将其放置在合适的位置，如果这个位置刚好是我们求的位置，那就直接返回这个数字即可。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 解法二：快排 * @param nums * @param k * @return */ public int findKthLargest2(int[] nums, int k) &#123; return quickSelect(nums,0,nums.length-1,nums.length-k); &#125; private int quickSelect(int[] nums, int left, int right, int index) &#123; int q = randomPartition(nums,left,right); if(q==index)&#123; return nums[q]; &#125;else&#123; return q&lt;index?quickSelect(nums, q+1, right, index):quickSelect(nums, left, q-1, index); &#125; &#125; /** * 在left和right之间随机一个位置，并将该位置的数字放置合适的位置 * @param nums * @param left * @param right * @return */ private int randomPartition(int[] nums, int left, int right) &#123; Random random = new Random(); int randomIndex = random.nextInt(right-left+1)+left; swap(nums,randomIndex,right); int x = nums[right],curIndex = left-1; for(int i=left;i&lt;right;i++)&#123; if(nums[i]&lt;x)&#123; swap(nums,++curIndex,i); &#125; &#125; swap(nums,curIndex+1,right); return curIndex+1; &#125; /** * 负责交换指定的两个位置 * @param nums * @param index1 * @param index2 */ private void swap(int[] nums, int index1, int index2) &#123; int num = nums[index1]; nums[index1] = nums[index2]; nums[index2] = num; &#125;","categories":[{"name":"leetcode刷题笔记","slug":"leetcode刷题笔记","permalink":"http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Spring实战第四版读书笔记","slug":"Spring实战第四版读书笔记","date":"2021-06-03T16:00:00.000Z","updated":"2021-06-10T01:50:49.559Z","comments":true,"path":"2021/06/04/Spring实战第四版读书笔记/","link":"","permalink":"http://example.com/2021/06/04/Spring%E5%AE%9E%E6%88%98%E7%AC%AC%E5%9B%9B%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Spring实战第四版spring本质上是简化java开发。 几个简写： EJB Enterprise JavaBean 企业级javabean JDO Java Data Object java数据对象 POJO Plian Old Java Object 简单老式java对象 DI Dependency Injection 依赖注入 AOP Aspect-Oriented Programing 面向切面编程 第一章：简介怎么简化java开发的：通过DI和AOP实现松耦合；基于切面和惯例进行声明式编程；通过切面和模板减少样板式代码 AOP的作用：AOP通过将遍布应用各处的功能分离出来，形成可重用的组件，从而确保pojo的简单性 Spring容器：将一个类转化为一个切面，首先需要将其声明为一个SpringBean，bean对象生存于Spring容器中； Spring的容器分为两大类：bean工厂和应用上下文。 第二章：装配bean装配bean有三种方式： 1、xml配置 2、java显示装配 3、自动装配【重要】 自动装配最为便捷。 以下为简单的自动装配 分别创建三个pojo并进行注解 12345678910package com.learn.springlearn.exm3;import org.springframework.stereotype.Component;//第一个pojo@Componentpublic class Cat &#123; public void voice()&#123; System.out.println(&quot;喵喵喵&quot;); &#125;&#125; 12345678910package com.learn.springlearn.exm3;import org.springframework.stereotype.Component;//第二个pojo@Componentpublic class Dog &#123; public void voice()&#123; System.out.println(&quot;汪汪叫&quot;); &#125;&#125; 123456789101112131415161718package com.learn.springlearn.exm3;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;//第三个pojo@Componentpublic class Human &#123; @Autowired private Cat cat; @Autowired private Dog dog; public void say()&#123; System.out.println(&quot;我有两只宠物&quot;); cat.voice(); dog.voice(); &#125;&#125; 之后将三个pojo存放至spring容器中 123456789package com.learn.springlearn.exm3;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScanpublic class Exm3Config &#123;&#125; 最后便可对其进行测试 12345678910111213141516171819202122package com.learn.exam3test;import com.learn.springlearn.exm3.Exm3Config;import com.learn.springlearn.exm3.Human;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@ContextConfiguration(classes = Exm3Config.class)//下面这个注解必须要加，不然会报nulllpointerexception@RunWith(SpringJUnit4ClassRunner.class)public class Exm3Test &#123; @Autowired private Human human; @Test public void test()&#123; human.say(); &#125;&#125; 第三章：高级装配配置profile bean：profile可以根据环境创建哪个bean和不创建哪个bean 激活profile：如果定义了spring.profiles.active，那就根据这个配置进行激活profile 没设置active的话，如果定义了spring.profiles.default，那就根据default进行jihuo 如果都没设置，那就只创建那些没定义在profile中的bean 条件化的bean通过注解Conditional实现，只有指定属性不存在的话，指定类就不会被实例化。 自动装配的歧义性一个接口会存在多个实现类，此时进行自动装配时，spring无法确定装配哪个类。。 解决方法： 1、设置首选bean：@Primary 2、采用限定符来确定装配指定的bean：@Qualifier（“iceCream”）；@Qualifier也可以用于bean上，相当于为该bean设置ID；@Qualifier也可以将每个bean的ID设置为该类的特性，一个bean会存在多个特性，但是同一个类不允许多次使用同一个注解，因此可自行创建注解 运行时值注入目的：使得一些值在运行时再确定 方法： 1、属性占位符 2、Spring表达式语言（SpEL）【重点】 SpEL的使用方法： 表示字面值：#{3.1459}，#{‘Hello’}，#{false} 引用bean、属性、方法 #{people}，#{people.name}，#{people.speak()} 第四章：面向切面的SpringAOP术语： 通知（Advice）：切面的工作被称为通知；通知包含了需要用于多个对象的横切行为。 连接点（Join Point）：在应用执行过程中插入到切面的一个点，切面代码利用这些点插入到应用的正常流程之中，并添加新的行为；连 接点是程序执行过程中能够应用通知的所有点。 切点（Pointcut）：通知定义了切面的“什么”和“何时”，切点定义了“何处”；切点定义了哪些连接点会得到通知。 切面（Aspect）：通知和切点构成了切面的全部内容。 引入（Introduction）：向现有的类添加新的方法和属性。 织入（Weaving）：将切面应用到目标对象并创建新的代理对象的过程。 第五章：构建Spring Web应用程序跟踪Spring MVC的请求 在请求离开浏览器时(1)，会带有用户所请求内容的信息，至少会包含请求的URL。但是还可能带有其他的信息，例如用户提交的表单信息。请求旅程的第一站是Spring的DispatcherServlet。与大多数基于Java的Web框架一样，Spring MVC所有的请求都会通过一个前端控制器（front controller）Serlet。前端控制器是常用的Web应用程序模式，在这里一个单实例的Serlet将请求委托给应用程序的其他组件来执行实际的处理。在Spring MVC中，DispatcherServlet就是前端控制器。DispatcherServlet的任务是将请求发送给Spring MVC控制器（controller)。控制器是一个用于处理请求的Spring组件。在典型的应用程序中可能会有多个控制器，Dispatcherservlet需要知道应该将请求发送给哪个控制器。所以DispatcherServlet以会查询一个或多个处理器映射（handler mapping)(2)来确定请求的下一站在哪里。处理器映射会根据请求所携带的URL信息来进行决策。一旦选择了合适的控制器，Dispatcherservlet会将请求发送给选中的控制器(3)。到了控制器，请求会卸下其负载（用户提交的信息）并耐心等待控制器处理这些信息。（实际上，设计良好的控制器本身只处理很少甚至不处理工作，而是将业务逻辑委托给一个或多个服务对象进行处理。)控制器在完成逻辑处理后，通常会产生一些信息，这些信息需要返回给用户并在浏览器上显示。这些信息被称为模型（model）。不过仅仅给用户返回原始的信息是不够的——这些信息需要以用户友好的方式进行格式化，一般会是HTML。所以，信息需要发送给一个视图（view），通常会是JSP。控制器所做的最后一件事就是将模型数据打包，并且标示出用于渲染输出的视图名。它接下来会将请求连同模型和视图名发送回DispatcherServlet(4)。这样，控制器就不会与特定的视图相耦合，传递给Dispatcherservlet的视图名并不直接表示某个特定的JSP。实际上，它甚至并不能确定视图就是JSP。相反，它仅仅传递了一个逻辑名称，这个名字将会用来查找产生结果的真正视图。Dispatcherservlet将会使用视图解析器（view resolver）(5)来将逻辑视图名匹配为一个特定的视图实现，它可能是也可能不是JSP。既然DispatcherServlet已经知道由哪个视图渲染结果，那请求的任务基本上也就完成了。它的最后一站是视图的实现（可能是JSP）(6)，在这里它交付模型数据。请求的任务就完成了。视图将使用模型数据渲染输出，这个输出会通过响应对象传递给客户端（不会像听上去那样硬编码）(7)。可以看到，请求要经过很多的步骤，最终才能形成返回给客户端的响应。大多数的步骤都是在Spring框架内部完成的，也就是图5.1所示的组件中。尽管本章的主要内容都关注于如何编写控制器，但在此之前我们首先看一下如何搭建Spring MVC的基础组件。 第六章：渲染web视图这个暂时跳过。 第七章：SpringMVC的高级技术这章看了一遍，不是很明白。 第八章：使用Spring Web Flow 第九章：保护Web应用注：第五~第九章将的是Spring在web中的应用，暂且跳过。 第十章：通过Spring和JDBC连接数据库通过jdbc消除样板式代码，使得在编程阶段能专注于代码本身； 简单讲了下jdbc的用法 第十一章：使用对象-关系映射持久化数据","categories":[{"name":"读书总结","slug":"读书总结","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"mybatisplus使用总结","slug":"mybatisplus使用总结","date":"2021-06-03T16:00:00.000Z","updated":"2021-08-02T07:45:48.260Z","comments":true,"path":"2021/06/04/mybatisplus使用总结/","link":"","permalink":"http://example.com/2021/06/04/mybatisplus%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"使用mybatis对数据库进行操作时，为方便定位错误，可在配置文件中进行配置使得myqsl语句在控制台进行输出 在application.properties配置 12#控制面板输出mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl MybatisPlus的主键策略默认采用的是雪花算法：分布式ID生成器 核心思想： 长度共64bit（一个long型）。 首先是一个符号位，1bit标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0。 41bit时间截(毫秒级)，存储的是时间截的差值（当前时间截 - 开始时间截)，结果约等于69.73年。 10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID，可以部署在1024个节点）。 12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID）。 优点：整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞，并且效率较高。 MyBatisPlus自动填充功能好处：自动实现set功能 使用方法： 举例：添加记录的创建时间和修改时间 1、在数据库表中创建对应列：create_time,update_time 2、在对应的实体类中添加对应属性：createTime,updateTime，并添加注解 3、创建一个类，实现MetaObjectHandler接口，并重写其中的两个方法","categories":[{"name":"HelloWorld系列","slug":"HelloWorld系列","permalink":"http://example.com/categories/HelloWorld%E7%B3%BB%E5%88%97/"}],"tags":[]},{"title":"mysql登录","slug":"mysql登录","date":"2021-06-02T16:00:00.000Z","updated":"2021-06-03T08:19:21.109Z","comments":true,"path":"2021/06/03/mysql登录/","link":"","permalink":"http://example.com/2021/06/03/mysql%E7%99%BB%E5%BD%95/","excerpt":"","text":"启动mysql：systemctl start mysqld 查看mysql启动状态：systemctl status mysqld 显示active表示已经激活。 进行登录：mysql -uroot -p","categories":[{"name":"项目Hospital","slug":"项目Hospital","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AEHospital/"}],"tags":[]},{"title":"IDEA快捷键总结","slug":"IDEA快捷键总结","date":"2021-06-01T16:00:00.000Z","updated":"2021-06-02T08:27:36.746Z","comments":true,"path":"2021/06/02/IDEA快捷键总结/","link":"","permalink":"http://example.com/2021/06/02/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93/","excerpt":"","text":"1 快捷键 功能 2 Ctrl+Shift+A 搜索操作方式 3 Ctrl+Space 基本代码补全，输入字母按后列出匹配的词组 4 Ctrl+Shift+Space 智能代码补全，列出与预期类型一致的方法或变量 5 Ctrl+Alt+Space 补全类名 6 Ctrl+Shift+Enter 补全语句 7 Ctrl+P 显示方法参数 8 Ctrl+Q 显示注释文档 9 Shift+F1 显示外部文档 10 Ctrl+mouse over code 显示描述信息 11 Ctrl+F1 示提示、警告、错误等信息 12 Alt+lnsert 生成代码，生成Getter、Setter构造器等 13 Ctrl+O 重写父类方法 14 Ctrl+I 实现接口方法 15 Ctrl+/ 使用“//”注释或取消注释 16 Ctrl+Shift+/ 使用“/** **/”注释或取消注释 17 Ctrl+W 选择代码块，连续按会增加选择外层的代码块 18 Ctrl+Shift+W 与“Ctrl+W”相反，减少选择代码块 19 Alt+Q 显示类描述信息 20 Alt+Enter-fixes 显示快速修复列表 21 Ctrl+Alt+L 格式化代码 22 Ctrl+Alt+O 优化 Imports 23 Ctrl+Alt+I 自动优化代码缩进 24 Tab/Shift+Tab 缩进代码/取消缩进代码 25 Ctrl+X or Shift+Delete 缩进代码/取消缩进代码 26 Ctrl+C or Ctrl+lnsert 剪切代码，未选择代码时剪切当前行 27 Ctrl+V or Shift+lnsert 粘贴代码 28 Ctrl+Shift+V 粘贴最近复制的内容 29 Ctrl+D 重复代码，未选择代码时重复当前行 30 Ctrl+Y 删除行，未选择时删除当前行 31 Ctrl+Shift+J 合并多行为一行 32 Ctrl+Enter 分割一行为多行 33 Shift+Enter 使光标所在位置的下一行为新行 34 Ctrl+Shift+U 对选中内容进行大小写切换 35 Ctrl+Shift+]/[ 选中到代码块的开始/结束 36 Ctrl+Delete 删除从光标所在位置到单词结束位置的字符 37 Ctrl+Backspace 删除从单词起始位置到光标所在位置的字符 38 Ctrl+NumPad+/- 展开或收起代码块 39 Ctrl+Shift+NumPad+ 展幵所有代码块 40 Ctrl+Shift+NumPad- 收起所有代码块 41 Ctrl+F4 关闭当前编辑页 42 Ctrl+F 查找 43 F3 查找下一个 44 Shift+F3 查找上一个 45 Ctrl+R 替换 46 Ctrl+Shift+F 目录内查找 47 Ctrl+Shift+R 目录内替换 48 Ctrl+Shift+S 语法模板搜索 49 Ctrl+Shift+M 语法模板替换 50 Alt+F7 查找被使用处 51 Ctrl+F7 查找当前文件中的使用处 52 Ctrl+Shift+F7 高亮当前文件中的使用处 53 Ctrl+Alt+F7 列出使用者 54 Ctrl+F9 Make模块、项目 55 Ctrl+Shift+F9 编译选中的文件、模块、项目 56 Alt+Shift+F10 选择配置后运行代码 57 Alt+Shift+F9 选择配置后调试代码 58 Shift+F10 运行代码 59 Shift+F9 调试代码 60 Ctrl+F2 停止调试 61 F8 单步调试，不进入函数内部 62 F7 单步调试，进入函数内部 63 Shift+F7 选择要进入的函数 64 Shift+F8 跳出函数 65 Alt+F9 运行到断点 66 Alt+F8 执行表达式查看结果 67 F9 继续执行，进入下一个断点或执行完程序 68 Ctrl+F8 设置/取消当前行断点 69 Ctrl+Shift+F8 查看断点 70 双击 Shift 查找所有 71 Ctrl+N 查找类 72 Ctrl+Shift+N 查找文件 73 Ctrl+Alt+Shift+N Go to symbol 74 Alt+Right/Left 左右切换Tab 75 F12 回到上一个打开的窗口 76 Esc 焦点回到编辑器 77 Shift+Esc 隐藏打开的视图 78 Ctrl+Shift+F4 关闭当前Tab 79 Ctrl+G 跳到指定行 80 Ctrl+E 显示最近打开的文件 81 Ctrl+Alt+Left 跳到光标的上一个位置 82 Ctrl+Alt+Right 跳到光标的下一个位置 83 Ctrl+Shift+Backspace 跳到上一个编辑处 84 Alt+F1 选择当前文件显示在不同的视图 85 Ctrl+Bor/Ctrl+Click 跳到类声明处 86 Ctrl+Alt+B 跳到实现类/方法 87 Ctrl+Shift+I 显示类/变量/方法定义 88 Ctrl+Shift+B 跳到类型定义处 89 Ctrl+U 跳到父类/方法 90 Alt+Up 光标移动到上一个方法 91 Alt+Down 光标移动到下一个方法 92 Ctrl+[ 光标移动到代码块的起始位置 93 Ctrl+] 光标移动到代码块的结束位置 94 Ctrl+F12 显示文件结构 95 Ctrl+H 显示类层级 96 Ctrl+Shift+H 显示方法层级 97 Ctrl+Alt+H 显示类/方法调用层级 98 F2 光标移动到下一个错误 99 Shift+F2 光标移动到上一个错误 100 F4 编辑源码，光标移到编辑器内 101 Ctrl+Enter 查看源码，光标没移到编辑器内 102 Alt+Home 显示导航面包屑 103 F11 当前行设置书签 104 Shift+F11 显示所有书签 105 Ctrl+F11 设置书签号［0-9］ 106 Ctrl+[0-9] 跳到书签号［0-9］所在位置 107 F5 复制类 108 F6 移动类 109 Alt+Delete 安全删除，删除前会提示调用处 110 Shift+F6 重命名 111 Ctrl+F6 重构方法参数、Exception等 112 Ctrl+Alt+N 合并多行为一行 113 Ctrl+Alt+M 提取为新方法 114 Ctrl+Alt+V 提取为新变量 115 Ctrl+Alt+F 提取为对象新属性 116 Ctrl+Alt+C 提取为新静态常量 117 Alt+0 聚焦到Messages窗口 118 Alt+1 焦到Project窗口 119 Alt+2 聚焦到Favorite窗口 120 Alt+3 聚焦到Find窗口 121 Alt+4 聚焦到Run窗口 122 Alt+5 聚焦到Debug窗口 123 Alt+6 聚焦到TODO窗口 124 Alt+7 聚焦到Structure窗口 125 Alt+8 聚焦到Hierarchy窗口 126 Alt+9 聚焦到Change窗口 127 Ctrl+S 保存文件 128 Ctrl+Alt+Y 与本地文件同步 129 Alt+Shift+F 添加到收藏夹 130 Alt+Shift+I 检查当前文件，包括Javadoc问题、可能存在的bug等 131 Ctrl+Alt+S 打开settings窗口 132 Ctrl+BackQuote (‘) 模式切换，包括文本外观、快捷键、编辑器外观、代码样式","categories":[{"name":"小技巧","slug":"小技巧","permalink":"http://example.com/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[]},{"title":"maven首次运行问题","slug":"maven首次运行问题","date":"2021-06-01T11:12:55.000Z","updated":"2021-06-01T11:20:35.140Z","comments":true,"path":"2021/06/01/maven首次运行问题/","link":"","permalink":"http://example.com/2021/06/01/maven%E9%A6%96%E6%AC%A1%E8%BF%90%E8%A1%8C%E9%97%AE%E9%A2%98/","excerpt":"","text":"第一次运行maven时，由于maven默认用的是jre，用命令行运行时会报错，如下图所示 根据提示错误，可知运行的是jre而不是jkd，查看maven版本 发现路径为jre，至此找到问题根源。 解决方法： 在maven\\bin\\setting文件中，在首行加上 set JAVA_HOME=C:\\JDK\\jdk1.8.0_291 将其所用的JAVA_HOME修改为本机所安装的jdk，之后问题解决，文件可正常编译。","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"http://example.com/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"运行Halo项目时遇到的问题","slug":"运行Halo项目时遇到的问题","date":"2021-05-31T02:51:55.000Z","updated":"2021-05-31T07:13:56.009Z","comments":true,"path":"2021/05/31/运行Halo项目时遇到的问题/","link":"","permalink":"http://example.com/2021/05/31/%E8%BF%90%E8%A1%8CHalo%E9%A1%B9%E7%9B%AE%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"这个问题在将jdk版本从8改为11之后就没遇到了; 但是在后续的运行中又出现了其他错误，经查阅资料，将IDEA从2019.3升级为2020.3之后解决； 后记：改完之后还需要将gradle的jdk版本以及项目运行依赖的jdk版本改为11（我装了8和11两个版本）； 最后一次运行报错是显示未找到默认主题，在halo-dev/halo-theme-anatole (github.com)进行下载并存放至Halo\\halo\\src\\main\\resources\\templates\\themes\\anatole后，成功运行。 至此成功运行。","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"http://example.com/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"AQS简述","slug":"AQS简述","date":"2021-05-28T16:00:00.000Z","updated":"2021-05-29T13:37:36.984Z","comments":true,"path":"2021/05/29/AQS简述/","link":"","permalink":"http://example.com/2021/05/29/AQS%E7%AE%80%E8%BF%B0/","excerpt":"","text":"AbstractQuenedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。 AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包 AQS的核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。 CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。 AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。 用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。 注意：AQS是自旋锁：在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功 转自：AQS原理","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"CAS简述","slug":"CAS简述","date":"2021-05-28T16:00:00.000Z","updated":"2021-05-29T13:35:37.384Z","comments":true,"path":"2021/05/29/CAS简述/","link":"","permalink":"http://example.com/2021/05/29/CAS%E7%AE%80%E8%BF%B0/","excerpt":"","text":"在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁 锁机制存在以下问题： （1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。 （2）一个线程持有锁会导致其它所有需要此锁的线程挂起。 （3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。 volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。 独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。 一、什么是CASCAS,compare and swap的缩写，中文翻译成比较并交换。 我们都知道，在java语言之前，并发就已经广泛存在并在服务器领域得到了大量的应用。所以硬件厂商老早就在芯片中加入了大量直至并发操作的原语，从而在硬件层面提升效率。在intel的CPU中，使用cmpxchg指令。 在Java发展初期，java语言是不能够利用硬件提供的这些便利来提升系统的性能的。而随着java不断的发展,Java本地方法(JNI)的出现，使得java程序越过JVM直接调用本地方法提供了一种便捷的方式，因而java在并发的手段上也多了起来。而在Doug Lea提供的cucurenct包中，CAS理论是它实现整个java包的基石。 CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” 通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。 类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算。 二、CAS的目的利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。 三、CAS存在的问题CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作 \\1. ABA****问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。 从****Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 关于ABA问题参考文档: http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html 2. 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。 3. 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS****操作。 四、 concurrent包的实现 由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式： A线程写volatile变量，随后B线程读这个volatile变量。 A线程写volatile变量，随后B线程用CAS更新这个volatile变量。 A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。 A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。 Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式： 首先，声明共享变量为volatile； 然后，使用CAS的原子条件更新来实现线程之间的同步； 同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。 转自https://blog.csdn.net/ls5718/article/details/52563959 这个讲的也挺好","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"native关键字","slug":"native关键字","date":"2021-05-28T16:00:00.000Z","updated":"2021-05-29T13:16:54.526Z","comments":true,"path":"2021/05/29/native关键字/","link":"","permalink":"http://example.com/2021/05/29/native%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"native关键字native是与C++联合开发的时候用的！java自己开发不用的！ 使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用。 这些函数的实现体在DLL中，JDK的源代码中并不包含，你应该是看不到的。对于不同的平台它们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的。 1。native 是用做java 和其他语言（如c++）进行协作时用的也就是native 后的函数的实现不是用java写的 2。既然都不是java，那就别管它的源代码了，呵呵 native的意思就是通知操作系统， 这个函数你必须给我实现，因为我要使用。 所以native关键字的函数都是操作系统实现的，java只能调用。 java是跨平台的语言，既然是跨了平台，所付出的代价就是牺牲一些对底层的控制，而java要实现对底层的控制，就要一些其他语言的帮助，这个就是native的作用了","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"wait和sleep的异同","slug":"wait和sleep的异同","date":"2021-05-28T16:00:00.000Z","updated":"2021-05-29T13:31:07.038Z","comments":true,"path":"2021/05/29/wait和sleep的异同/","link":"","permalink":"http://example.com/2021/05/29/wait%E5%92%8Csleep%E7%9A%84%E5%BC%82%E5%90%8C/","excerpt":"","text":"相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。 不同点：1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait() 2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中 3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 Sleep()方法是属于Thread类中的，而wait()方法是属于Object类中的。 Sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持着，当指定的时间结束后又会自动恢复运行状态。 在调用sleep方法时，线程不会释放对象锁。 在调用wait方法时，线程会释放对象锁，进入等待此对象的等待锁定池，只有此对象调用notify方法后本线程才进入对象锁定池准备。 sleep可以在任何地方使用，而wait只能在同步方法或者同步块中使用。 另外，sleep是静态方法，wait是非静态方法。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"快速失败、安全失败","slug":"快速失败、安全失败","date":"2021-05-28T16:00:00.000Z","updated":"2021-05-29T13:29:02.295Z","comments":true,"path":"2021/05/29/快速失败、安全失败/","link":"","permalink":"http://example.com/2021/05/29/%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E3%80%81%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5/","excerpt":"","text":"快速失败：在使用迭代器对集合进行迭代的过程中，如果 A 线程正在对集合进行遍历，此时 B 线程对集合进行修改（增加、删除、修改），或者 A 线程在遍历过程中对集合进行修改，都会导致 A 线程抛出 ConcurrentModificationException 异常。 安全失败：采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。 由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"简单死锁的测试","slug":"简单死锁的测试","date":"2021-05-28T16:00:00.000Z","updated":"2021-05-29T13:32:30.639Z","comments":true,"path":"2021/05/29/简单死锁的测试/","link":"","permalink":"http://example.com/2021/05/29/%E7%AE%80%E5%8D%95%E6%AD%BB%E9%94%81%E7%9A%84%E6%B5%8B%E8%AF%95/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738/** * @author Mithrandir * @date 2021-04-2021/4/12-10:19 * 测试死锁 */public class DeadLock &#123; public static void main(String[] args) &#123; new Thread(new myThread1()).start(); new Thread(new myThread2()).start(); &#125;&#125;class myThread2 implements Runnable&#123; @Override public void run() &#123; synchronized (myLock.lock2)&#123; System.out.println(&quot;这是myThread2的第一层，已经持有lock2&quot;);//死锁情况下，只有这行能输出 synchronized (myLock.lock1)&#123; System.out.println(&quot;这是myThread2的第二层，已经持有lock2和lock1&quot;); &#125; &#125; &#125;&#125;class myThread1 implements Runnable&#123; @Override public void run() &#123; synchronized (myLock.lock1)&#123; System.out.println(&quot;这是myThread1的第一层,已经持有lock1&quot;);//死锁情况下，只有这行能输出 synchronized (myLock.lock2)&#123; System.out.println(&quot;这是myThead1的第二层，已经持有lock1和lock2&quot;); &#125; &#125; &#125;&#125;class myLock&#123; static Object lock1=new Object(); static Object lock2=new Object();&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"解决线程安全的方式","slug":"解决线程安全的方式","date":"2021-05-28T16:00:00.000Z","updated":"2021-05-29T13:27:53.163Z","comments":true,"path":"2021/05/29/解决线程安全的方式/","link":"","permalink":"http://example.com/2021/05/29/%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"","text":"一：同步代码块synchronized(同步监视器){ //需要被同步的代码 } 说明： 1.操作共享数据的代码，即为需要被同步的代码。 –&gt;不能包含代码多了，也不能包含代码少了。 ​ 2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 ​ 3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。 ​ 要求：多个线程必须要共用同一把锁。 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。 ​ 在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视 二：同步方法如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 关于同步方法的总结： \\1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 \\2. 非静态的同步方法，同步监视器是：this 静态的同步方法，同步监视器是：当前类本身 同步代码块和同步方法的对比： 其实还是同步代码块好一些，因为同步方法的作用范围相对来说会比较广泛，很容易会包括进一些没必要同步的代码，这样会造成效率降低。 三：同步锁Lock（jdk5.0新增，也就是建议用）在需要同步的代码前调用Lock 的lock函数，在需要同步的代码执行完之后，手动调用unlock函数才能释放锁。（创建lock对象时，用的时reentrantlock这个类创建的） synchronize和lock的异同：同：都可以解决线程安全问题 异：synchronize在执行完对应的代码块之后，会自动释放锁；lock必须手动释放锁","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Java并发","slug":"Java并发","date":"2021-05-27T11:47:41.000Z","updated":"2021-05-27T12:17:59.544Z","comments":true,"path":"2021/05/27/Java并发/","link":"","permalink":"http://example.com/2021/05/27/Java%E5%B9%B6%E5%8F%91/","excerpt":"","text":"JMM概述 不同线程之间无法直接访问对方工作内存中的变量，线程间的通信方式一般有三种方式进行： 1、wait/notify 2、利用共享内存 3、while轮询 JMM采用的就是共享内存方式实现线程间通讯。 可见性、原子性、有序性可见性：指线程之间的可见性，一个线程修改的状态对另外一个线程是可见的。（volatile可以保证变量的可见性） 原子性：指一个操作或者多个操作要么都执行，要么都不执行。（synchronized可保证原子性） 有序性：对于一个线程的代码而言，我们总是以为代码的执行是从前往后的，依次执行的。这么说不能说完全不对，在单线程程序里，确实会这样执行；但是在多线程并发时，程序的执行就有可能出现乱序。用一句话可以总结为：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行语义（WithIn Thread As-if-Serial Semantics）”,后半句是指“指令重排”现象和“工作内存和主内存同步延迟”现象。 一个最经典的例子就是银行汇款问题，一个银行账户存款100，这时一个人从该账户取10元，同时另一个人向该账户汇10元，那么余额应该还是100。那么此时可能发生这种情况，A线程负责取款，B线程负责汇款，A从主内存读到100，B从主内存读到100，A执行减10操作，并将数据刷新到主内存，这时主内存数据100-10=90，而B内存执行加10操作，并将数据刷新到主内存，最后主内存数据100+10=110，显然这是一个严重的问题，我们要保证A线程和B线程有序执行，先取款后汇款或者先汇款后取款，此为有序性。 Java提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性,volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现， 在单线程程序中，不会发生“指令重排”和“工作内存和主内存同步延迟”现象，只在多线程程序中出现。 Happen before原则定义了哪些指令不能重排：单线程的happen before原则 写在前面的操作happen before后面的操作 锁的happen-before原则： 同一个锁的unlock操作happen-before此锁的lock操作。 volatile的happen-before原则： 对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。 happen-before的传递性原则： 如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。 线程启动的happen-before原则： 同一个线程的start方法happen-before此线程的其它方法。 线程中断的happen-before原则： 对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。 线程终结的happen-before原则： 线程中的所有操作都happen-before线程的终止检测。 对象创建的happen-before原则： 一个对象的初始化完成先于他的finalize方法调用。 哪些会进行重排：执行程序时为了提高性能，编译器和处理器经常会对指令进行重新排序。 编译器优化的重排序： 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 内存系统的重排序： 由于处理器使用的是缓存和读写缓冲区，看上去像是乱序执行。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Java各种对比","slug":"Java各种对比","date":"2021-05-26T16:00:00.000Z","updated":"2021-05-27T09:09:27.122Z","comments":true,"path":"2021/05/27/Java各种对比/","link":"","permalink":"http://example.com/2021/05/27/Java%E5%90%84%E7%A7%8D%E5%AF%B9%E6%AF%94/","excerpt":"","text":"四种权限的作用范围对比： public protected default private 同一个类 可 可 可 可 同一个包 可 可 可 不可 子类父类 可 可 不可 不可 不同包之间 可 不可 不可 不可 ==和equals对比 ==是判断两个变量是否指向同一块内存空间；equals是判断两个变量或实例所指向的内存空间的值是否相同 ==是对内存地址进行比较，equals则是对内容进行比较； ==比较引用是否相同，equals比较值是否相同 comparable和comparator对比Comparable​ 一个类的实现接口，属于内嵌比较。创建一个类时可实现该接口，重写compareTo()方法，用于自定比较方法，之后可采用collections中的sort方法进行排序。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author Mithrandir * @date 2021-04-2021/4/12-14:50 * 类实现comparable接口，可以理解为将比较方式嵌入自身，便可以直接调用Collections的sort方法 * （因为实现接口时重写的compareTo方法定义了比较方法） */public class ComparableLearn &#123; @Test public void test()&#123; List&lt;Person&gt; list = new ArrayList&lt;&gt;(); list.add(new Person(5)); list.add(new Person(1)); list.add(new Person(9)); list.add(new Person(7)); Collections.sort(list); for(Person person:list)&#123; System.out.println(person); &#125; &#125;&#125;class Person implements Comparable&lt;Person&gt; &#123; private int age; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;age=&quot; + age + &#x27;&#125;&#x27;; &#125; public Person() &#123; &#125; public Person(int age) &#123; this.age = age; &#125; @Override public int compareTo(Person o) &#123; return this.age-o.age; &#125;&#125; Comparator1234567891011121314151617181920212223242526272829303132333435363738394041/** * @author Mithrandir * @date 2021-04-2021/4/12-14:59 * comparator作为一个临时比较器，在调用collections的sort方法时写一个比较方法 */public class ComparatorLearn &#123; @Test public void test()&#123; List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student(2)); list.add(new Student(6)); list.add(new Student(1)); list.add(new Student(9)); Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.age-o2.age; &#125; &#125;); for(Student student:list)&#123; System.out.println(student); &#125; &#125;&#125;class Student &#123; int age; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;age=&quot; + age + &#x27;&#125;&#x27;; &#125; public Student() &#123; &#125; public Student(int age) &#123; this.age = age; &#125;&#125; String和StringBuilder和StringBufferString: 底层用的是final char[] StringBuilder: 线程安全 StringBuilder: 线程不安全，效率高 重载和重写重载在同一个class内对同一个函数进行重载，必须保证形参个数或者形参类型不同 重写用于子类继承父类，对父类中方法的重写 基本数据类型和引用数据类型基本数据类型boolean、byte、int、char、long、short、double、float 引用数据类型数组、类、接口… 为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 基本类型 对应的包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 基本使用对比 Integer是int的包装类；int是基本数据类型； Integer变量必须实例化后才能使用；int变量不需要； Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； Integer的默认值是null；int的默认值是0 深度使用对比 由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。 Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）。 非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。因为非new生成的Integer变量指向的是静态常量池中cache数组中存储的指向了堆中的Integer对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的对象引用（地址）不同。 对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false 对于第4条的原因： java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)。而java API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127这个Integer对象进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。 并发和并行并发（concurrent）交替做不同事情的能力；不同代码块交替执行的能力 程序需要被设计成能处理多个同时（几乎是同时）发生的事情 并行（parallelism）同时做不同事情的能力；不同代码块同时执行 通过将问题中的多个部分并行执行，加速解决问题。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础知识点","slug":"基础知识点","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"Volatile关键字","slug":"Volatile关键字","date":"2021-05-26T16:00:00.000Z","updated":"2021-05-27T12:16:26.726Z","comments":true,"path":"2021/05/27/Volatile关键字/","link":"","permalink":"http://example.com/2021/05/27/Volatile%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"volatile关键字volatile 是一个类型修饰符。volatile 的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略 特性： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（实现可见性） 禁止进行指令重排序。（保证一定程度上的原子性） volatile 只能保证对单次读/写的原子性。i++ 这种操作不能保证原子性 简单介绍下指令重排 第一个为读操作时，第二个任何操作不可重排序到第一个前面。 第二个为写操作时，第一个任何操作不可重排序到第二个后面。 第一个为写操作时，第二个的读写操作也不运行重排序。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"常见的线程调度算法","slug":"常见的线程调度算法","date":"2021-05-26T16:00:00.000Z","updated":"2021-05-27T12:31:51.123Z","comments":true,"path":"2021/05/27/常见的线程调度算法/","link":"","permalink":"http://example.com/2021/05/27/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/","excerpt":"","text":"先来先服务（first come first serverd）优点： 易于实现，相当公平； 缺点： 有利于长进程，不利于短进程 短作业优先（shortest job first）优点： 平均周转时间最短，进程等待时间最短，可以增大系统吞吐量 缺点： 难以预测进程执行时间，开销较大；不利于长进程 最短剩余时间优先（shortest remaining time next）按预估剩余时间最短顺序进行调度 高优先权优先调度算法为了照顾紧迫型作业，使之在进入系统后便获得优先处理。 1、非抢占式优先权算法 2、抢占式优先权算法 高响应比优先调度算法根据比率：R=(w+s)/s （R为响应比，w为等待处理的时间，s为预计的服务时间） 如果该进程被立即调用，则R值等于归一化周转时间（周转时间和服务时间的比率）。R最小值为1.0，只有第一个进入系统的进程才能达到该值。调度规则为：当前进程完成或被阻塞时，选择R值最大的就绪进程，它说明了进程的年龄。当偏向短作业时，长进程由于得不到服务，等待时间不断增加，从而增加比值，最终在竞争中赢了短进程。 和最短进程优先、最短剩余时间优先一样，使用最高响应比策略需要估计预计服务时间。 时间片轮转法轮转法是基于适中的抢占策略的，以一个周期性间隔产生时钟中断，当中断发生后，当前正在运行的进程被置于就绪队列中，然后基于先来先去服务策略选择下一个就绪作业的运行。这种技术也称为时间片，因为每个进程再被抢占之前都给定一片时间。 多级反馈队列多级反馈队列算法，不必事先知道各种进程所需要执行的时间，他是当前被公认的一种较好的进程调度算法。其实施过程如下： 1)设置多个就绪队列，并为各个队列赋予不同的优先级。在优先权越高的队列中，为每个进程所规定的执行时间片就越小。 2)当一个新进程进入内存后，首先放入第一队列的末尾，按照先来先去原则排队等候调度。如果他能在一个时间片中完成，便可撤离；如果未完成，就转入第二队列的末尾，同样等待调度…..如此下去，当一个长作业（进程）从第一队列依次将到第n队列（最后队列）后，便按第n队列时间片轮转运行。 3)仅当第一队列空闲的时候，调度程序才调度第二队列中的进程运行；仅当第1到（i-1）队列空时，才会调度第i队列中的进程运行，并执行相应的时间片轮转。 4)如果处理机正在处理第i队列中某进程，又有新进程进入优先权较高的队列，则此新队列抢占正在运行的处理机，并把正在运行的进程放在第i队列的队尾。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"线程状态","slug":"线程状态","date":"2021-05-26T16:00:00.000Z","updated":"2021-05-27T12:18:02.409Z","comments":true,"path":"2021/05/27/线程状态/","link":"","permalink":"http://example.com/2021/05/27/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/","excerpt":"","text":"线程的状态新建状态（new） 线程创建之后 可运行（running） 可能正在运行，也可能正在等待cpu时间片 阻塞（blocked） 等待获取一个排他锁，如果其他线程释放了锁就会结束此状态 无限期等待（waiting） 等待其他线程显示唤醒，否则不会分配cpu时间片 限期等待（time_waiting） 无需其他线程进行显示唤醒，到达时间之后会被系统自动唤醒 终止（terminated） 可能是任务结束之后的终止，也可能是出现异常终止","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"线程进程协程","slug":"进程线程协程","date":"2021-05-26T16:00:00.000Z","updated":"2021-05-27T12:24:31.807Z","comments":true,"path":"2021/05/27/进程线程协程/","link":"","permalink":"http://example.com/2021/05/27/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/","excerpt":"","text":"进程一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。 线程进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。 与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 进程与线程的区别总结线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。 根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行 多进程和多线程区别多进程：操作系统中同时运行的多个程序 多线程：在同一个进程中同时运行的多个任务 举个例子，多线程下载软件，可以同时运行多个线程，但是通过程序运行的结果发现，每一次结果都不一致。 因为多线程存在一个特性：随机性。造成的原因：CPU在瞬间不断切换去处理各个线程而导致的，可以理解成多个线程在抢CPU资源。 Java中的多线程Java程序的进程里有几个线程：主线程，垃圾回收线程(后台线程)等 在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。 Java支持多线程，当Java程序执行main方法的时候，就是在执行一个名字叫做main的线程，可以在main方法执行时，开启多个线程A,B,C，多个线程 main,A,B,C同时执行，相互抢夺CPU，Thread类是java.lang包下的一个常用类,每一个Thread类的对象，就代表一个处于某种状态的线程 从 JVM 角度说进程和线程之间的关系（重要） 从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。 程序计数器为什么是私有的? 程序计数器主要有下面两个作用： 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。 所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。 虚拟机栈和本地方法栈为什么是私有的? 虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 本地方法栈：和虚拟机栈所发挥的作用非常相似，区别是:虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。 所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。 一句话简单了解堆和方法区 堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 来自 https://blog.csdn.net/ThinkWon/article/details/102021274 协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。 最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。 这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。 既然协程这么好，它到底是怎么来使用的呢？ 由于Java的原生语法中并没有实现协程（某些开源框架实现了协程，但是很少被使用）； 协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。 因此，协程的开销远远小于线程的开销。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"进程间通信方式","slug":"进程间的通信方式","date":"2021-05-26T16:00:00.000Z","updated":"2021-05-27T12:27:53.804Z","comments":true,"path":"2021/05/27/进程间的通信方式/","link":"","permalink":"http://example.com/2021/05/27/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/","excerpt":"","text":"进程之间的通信方式1.无名管道( pipe )： 管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 2.高级管道(popen)： 将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。 3.有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 4.消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 5.信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 6.信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 7.共享内存( shared memory ) ： 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 8.套接字( socket ) ： 套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Java反射机制","slug":"Java反射机制","date":"2021-05-26T16:00:00.000Z","updated":"2021-05-31T09:49:15.329Z","comments":true,"path":"2021/05/27/Java反射机制/","link":"","permalink":"http://example.com/2021/05/27/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Java反射机制一、什么是反射：（1）Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。 （2）Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。 二、反射的原理：下图是类的正常加载过程、反射原理与class对象： Class对象的由来是将.class文件读入内存，并为之创建一个Class对象。 对于类加载机制与双亲委派模型感兴趣的小伙伴可以阅读这篇文章 三、反射的优缺点优点：在运行时获得类的各种内容，进行反编译，对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。 缺点：（1）反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射； （2）反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。 四、反射的用途1、反编译：.class–&gt;.java 2、通过反射机制访问java对象的属性，方法，构造方法等 3、当我们在使用IDE,比如Ecplise时，当我们输入一个对象或者类，并想调用他的属性和方法是，一按点号，编译器就会自动列出他的属性或者方法，这里就是用到反射。 4、反射最重要的用途就是开发各种通用框架。比如很多框架（Spring）都是配置化的（比如通过XML文件配置Bean），为了保证框架的通用性，他们可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象。 5、例如，在使用Strut2框架的开发过程中，我们一般会在struts.xml里去配置Action，比如 1234567&lt;action name=&quot;login&quot; class=&quot;org.ScZyhSoft.test.action.SimpleLoginAction&quot; method=&quot;execute&quot;&gt; &lt;result&gt;/shop/shop-index.jsp&lt;/result&gt; &lt;result name=&quot;error&quot;&gt;login.jsp&lt;/result&gt; &lt;/action&gt; 比如我们请求login.action时，那么StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，从action中查找出name为login的Action，并根据class属性创建SimpleLoginAction实例，并用Invoke方法来调用execute方法，这个过程离不开反射。配置文件与Action建立了一种映射关系，当View层发出请求时，请求会被StrutsPrepareAndExecuteFilter拦截，然后StrutsPrepareAndExecuteFilter会去动态地创建Action实例。 比如，加载数据库驱动的，用到的也是反射。 Class.forName(“com.mysql.jdbc.Driver”); // 动态加载mysql驱动 五、反射的基本使用获得Class：主要有三种方法：（1）Object–&gt;getClass （2）任何数据类型（包括基本的数据类型）都有一个“静态”的class属性 （3）通过class类的静态方法：forName(String className)（最常用） 12345678910111213141516171819202122package fanshe;public class Fanshe &#123; public static void main(String[] args) &#123; //第一种方式获取Class对象 Student stu1 = new Student();//这一new 产生一个Student对象，一个Class对象。 Class stuClass = stu1.getClass();//获取Class对象 System.out.println(stuClass.getName()); //第二种方式获取Class对象 Class stuClass2 = Student.class; System.out.println(stuClass == stuClass2);//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个 //第三种方式获取Class对象 try &#123; Class stuClass3 = Class.forName(&quot;fanshe.Student&quot;);//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名 System.out.println(stuClass3 == stuClass2);//判断三种方式是否获取的是同一个Class对象 &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意，在运行期间，一个类，只有一个Class对象产生，所以打印结果都是true； 三种方式中，常用第三种，第一种对象都有了还要反射干什么，第二种需要导入类包，依赖太强，不导包就抛编译错误。一般都使用第三种，一个字符串可以传入也可以写在配置文件中等多种方法。 判断是否为某个类的示例：一般的，我们使用instanceof 关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断时候为某个类的实例，他是一个native方法。 public native boolean isInstance(Object obj); 创建实例：通过反射来生成对象主要有两种方法：（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。 Class&lt;?&gt; c = String.class; Object str = c.newInstance(); （2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建对象，这种方法可以用指定的构造器构造类的实例。 //获取String的Class对象 Class&lt;?&gt; str = String.class; //通过Class对象获取指定的Constructor构造器对象 Constructor constructor=c.getConstructor(String.class); //根据构造器创建实例： Object obj = constructor.newInstance(“hello reflection”); 通过反射获取构造方法并使用：（1）批量获取的方法： public Constructor[] getConstructors()：所有”公有的”构造方法 public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有) （2）单个获取的方法，并调用： public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法： public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有； （3） 调用构造方法： Constructor–&gt;newInstance(Object… initargs) newInstance是 Constructor类的方法（管理构造函数的类） api的解释为：newInstance(Object… initargs) ，使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象，并为之调用。 例子： Student类：共六个构造方法 1234567891011121314151617181920212223242526272829package fanshe;public class Student &#123; //---------------构造方法------------------- //（默认的构造方法） Student(String str)&#123; System.out.println(&quot;(默认)的构造方法 s = &quot; + str); &#125; //无参构造方法 public Student()&#123; System.out.println(&quot;调用了公有、无参构造方法执行了。。。&quot;); &#125; //有一个参数的构造方法 public Student(char name)&#123; System.out.println(&quot;姓名：&quot; + name); &#125; //有多个参数的构造方法 public Student(String name ,int age)&#123; System.out.println(&quot;姓名：&quot;+name+&quot;年龄：&quot;+ age);//这的执行效率有问题，以后解决。 &#125; //受保护的构造方法 protected Student(boolean n)&#123; System.out.println(&quot;受保护的构造方法 n = &quot; + n); &#125; //私有构造方法 private Student(int age)&#123; System.out.println(&quot;私有的构造方法 年龄：&quot;+ age); &#125;&#125; 测试类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package fanshe;import java.lang.reflect.Constructor; /* * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员； * * 1.获取构造方法： * 1).批量的方法： * public Constructor[] getConstructors()：所有&quot;公有的&quot;构造方法 public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有) * 2).获取单个的方法，并调用： * public Constructor getConstructor(Class... parameterTypes):获取单个的&quot;公有的&quot;构造方法： * public Constructor getDeclaredConstructor(Class... parameterTypes):获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有； * 3).调用构造方法： * Constructor--&gt;newInstance(Object... initargs) */public class Constructors &#123; public static void main(String[] args) throws Exception &#123; //1.加载Class对象 Class clazz = Class.forName(&quot;fanshe.Student&quot;); //2.获取所有公有构造方法 System.out.println(&quot;**********************所有公有构造方法*********************************&quot;); Constructor[] conArray = clazz.getConstructors(); for(Constructor c : conArray)&#123; System.out.println(c); &#125; System.out.println(&quot;************所有的构造方法(包括：私有、受保护、默认、公有)***************&quot;); conArray = clazz.getDeclaredConstructors(); for(Constructor c : conArray)&#123; System.out.println(c); &#125; System.out.println(&quot;*****************获取公有、无参的构造方法*******************************&quot;); Constructor con = clazz.getConstructor(null); //1&gt;、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型 //2&gt;、返回的是描述这个无参构造函数的类对象。 System.out.println(&quot;con = &quot; + con); //调用构造方法 Object obj = con.newInstance(); // System.out.println(&quot;obj = &quot; + obj); // Student stu = (Student)obj; System.out.println(&quot;******************获取私有构造方法，并调用*******************************&quot;); con = clazz.getDeclaredConstructor(char.class); System.out.println(con); //调用构造方法 con.setAccessible(true);//暴力访问(忽略掉访问修饰符) obj = con.newInstance(&#x27;男&#x27;); &#125;&#125; 控制台输出： 所有公有构造方法*********** public fanshe.Student(java.lang.String,int) public fanshe.Student(char) public fanshe.Student() 所有的构造方法(包括：私有、受保护、默认、公有)*** private fanshe.Student(int) protected fanshe.Student(boolean) public fanshe.Student(java.lang.String,int) public fanshe.Student(char) public fanshe.Student() fanshe.Student(java.lang.String) 获取公有、无参的构造方法************** con = public fanshe.Student() 调用了公有、无参构造方法执行了。。。 获取私有构造方法，并调用************* public fanshe.Student(char) 姓名：男 获取成员变量并调用：Student类： 1234567891011121314151617package fanshe.field; public class Student &#123; public Student()&#123; &#125; //**********字段*************// public String name; protected int age; char sex; private String phoneNum; @Override public String toString() &#123; return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex + &quot;, phoneNum=&quot; + phoneNum + &quot;]&quot;; &#125;&#125; 测试类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package fanshe.field;import java.lang.reflect.Field;/* * 获取成员变量并调用： * * 1.批量的 * 1).Field[] getFields():获取所有的&quot;公有字段&quot; * 2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有； * 2.获取单个的： * 1).public Field getField(String fieldName):获取某个&quot;公有的&quot;字段； * 2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的) * * 设置字段的值： * Field --&gt; public void set(Object obj,Object value): * 参数说明： * 1.obj:要设置的字段所在的对象； * 2.value:要为字段设置的值； */public class Fields &#123; public static void main(String[] args) throws Exception &#123; //1.获取Class对象 Class stuClass = Class.forName(&quot;fanshe.field.Student&quot;); //2.获取字段 System.out.println(&quot;************获取所有公有的字段********************&quot;); Field[] fieldArray = stuClass.getFields(); for(Field f : fieldArray)&#123; System.out.println(f); &#125; System.out.println(&quot;************获取所有的字段(包括私有、受保护、默认的)********************&quot;); fieldArray = stuClass.getDeclaredFields(); for(Field f : fieldArray)&#123; System.out.println(f); &#125; System.out.println(&quot;*************获取公有字段**并调用***********************************&quot;); Field f = stuClass.getField(&quot;name&quot;); System.out.println(f); //获取一个对象 Object obj = stuClass.getConstructor().newInstance();//产生Student对象--》Student stu = new Student(); //为字段设置值 f.set(obj, &quot;刘德华&quot;);//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot; //验证 Student stu = (Student)obj; System.out.println(&quot;验证姓名：&quot; + stu.name); System.out.println(&quot;**************获取私有字段****并调用********************************&quot;); f = stuClass.getDeclaredField(&quot;phoneNum&quot;); System.out.println(f); f.setAccessible(true);//暴力反射，解除私有限定 f.set(obj, &quot;18888889999&quot;); System.out.println(&quot;验证电话：&quot; + stu); &#125; &#125; 获取所有公有的字段******** public java.lang.String fanshe.field.Student.name 获取所有的字段(包括私有、受保护、默认的)******** public java.lang.String fanshe.field.Student.name protected int fanshe.field.Student.age char fanshe.field.Student.sex private java.lang.String fanshe.field.Student.phoneNum **获取公有字段并调用************************** public java.lang.String fanshe.field.Student.name 验证姓名：刘德华 *获取私有字段并调用*********************** private java.lang.String fanshe.field.Student.phoneNum 验证电话：Student [name=刘德华, age=0, sex= 获取成员方法并调用：Student类： 123456789101112131415161718package fanshe.method; public class Student &#123; //**************成员方法***************// public void show1(String s)&#123; System.out.println(&quot;调用了：公有的，String参数的show1(): s = &quot; + s); &#125; protected void show2()&#123; System.out.println(&quot;调用了：受保护的，无参的show2()&quot;); &#125; void show3()&#123; System.out.println(&quot;调用了：默认的，无参的show3()&quot;); &#125; private String show4(int age)&#123; System.out.println(&quot;调用了，私有的，并且有返回值的，int参数的show4(): age = &quot; + age); return &quot;abcd&quot;; &#125;&#125; 测试类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package fanshe.method;import java.lang.reflect.Method; /* * 获取成员方法并调用： * * 1.批量的： * public Method[] getMethods():获取所有&quot;公有方法&quot;；（包含了父类的方法也包含Object类） * public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的) * 2.获取单个的： * public Method getMethod(String name,Class&lt;?&gt;... parameterTypes): * 参数： * name : 方法名； * Class ... : 形参的Class类型对象 * public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes) * * 调用方法： * Method --&gt; public Object invoke(Object obj,Object... args): * 参数说明： * obj : 要调用方法的对象； * args:调用方式时所传递的实参；): */public class MethodClass &#123; public static void main(String[] args) throws Exception &#123; //1.获取Class对象 Class stuClass = Class.forName(&quot;fanshe.method.Student&quot;); //2.获取所有公有方法 System.out.println(&quot;***************获取所有的”公有“方法*******************&quot;); stuClass.getMethods(); Method[] methodArray = stuClass.getMethods(); for(Method m : methodArray)&#123; System.out.println(m); &#125; System.out.println(&quot;***************获取所有的方法，包括私有的*******************&quot;); methodArray = stuClass.getDeclaredMethods(); for(Method m : methodArray)&#123; System.out.println(m); &#125; System.out.println(&quot;***************获取公有的show1()方法*******************&quot;); Method m = stuClass.getMethod(&quot;show1&quot;, String.class); System.out.println(m); //实例化一个Student对象 Object obj = stuClass.getConstructor().newInstance(); m.invoke(obj, &quot;刘德华&quot;); System.out.println(&quot;***************获取私有的show4()方法******************&quot;); m = stuClass.getDeclaredMethod(&quot;show4&quot;, int.class); System.out.println(m); m.setAccessible(true);//解除私有限定 Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参 System.out.println(&quot;返回值：&quot; + result); &#125;&#125; 控制台输出： 获取所有的”公有“方法**** public void fanshe.method.Student.show1(java.lang.String) public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException public final void java.lang.Object.wait() throws java.lang.InterruptedException public boolean java.lang.Object.equals(java.lang.Object) public java.lang.String java.lang.Object.toString() public native int java.lang.Object.hashCode() public final native java.lang.Class java.lang.Object.getClass() public final native void java.lang.Object.notify() public final native void java.lang.Object.notifyAll() 获取所有的方法，包括私有的**** public void fanshe.method.Student.show1(java.lang.String) private java.lang.String fanshe.method.Student.show4(int) protected void fanshe.method.Student.show2() void fanshe.method.Student.show3() 获取公有的show1()方法**** public void fanshe.method.Student.show1(java.lang.String) 调用了：公有的，String参数的show1(): s = 刘德华 获取私有的show4()方法*** private java.lang.String fanshe.method.Student.show4(int) 调用了，私有的，并且有返回值的，int参数的show4(): age = 20 返回值：abcd 反射main方法:Student类： 1234567891011121314151617181920212223242526272829303132333435package fanshe.main; public class Student &#123; public static void main(String[] args) &#123; System.out.println(&quot;main方法执行了。。。&quot;); &#125;&#125;测试类：package fanshe.main;import java.lang.reflect.Method; /** * 获取Student类的main方法、不要与当前的main方法搞混了 */public class Main &#123; public static void main(String[] args) &#123; try &#123; //1、获取Student对象的字节码 Class clazz = Class.forName(&quot;fanshe.main.Student&quot;); //2、获取main方法 Method methodMain = clazz.getMethod(&quot;main&quot;, String[].class);//第一个参数：方法名称，第二个参数：方法形参的类型， //3、调用main方法 // methodMain.invoke(null, new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;); //第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数 //这里拆的时候将 new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125; 拆成3个对象。。。所以需要将它强转。 methodMain.invoke(null, (Object)new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);//方式一 // methodMain.invoke(null, new Object[]&#123;new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;&#125;);//方式二 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 控制台输出： main方法执行了。。。 利用反射创建数值：数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。 123456789101112public static void testArray() throws ClassNotFoundException &#123; Class&lt;?&gt; cls = Class.forName(&quot;java.lang.String&quot;); Object array = Array.newInstance(cls,25); //往数组里添加内容 Array.set(array,0,&quot;golang&quot;); Array.set(array,1,&quot;Java&quot;); Array.set(array,2,&quot;pytho&quot;); Array.set(array,3,&quot;Scala&quot;); Array.set(array,4,&quot;Clojure&quot;); //获取某一项的内容 System.out.println(Array.get(array,3));&#125; 反射方法的其他使用–通过反射运行配置文件内容：Student类： 12345public class Student &#123; public void show()&#123; System.out.println(&quot;is show()&quot;); &#125;&#125; 配置文件以txt文件为例子： className = cn.fanshe.Student methodName = show 测试类： 123456789101112131415161718192021222324252627282930import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.lang.reflect.Method;import java.util.Properties; /* * 我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改 * 我们只需要将新类发送给客户端，并修改配置文件即可 */public class Demo &#123; public static void main(String[] args) throws Exception &#123; //通过反射获取Class对象 Class stuClass = Class.forName(getValue(&quot;className&quot;));//&quot;cn.fanshe.Student&quot; //2获取show()方法 Method m = stuClass.getMethod(getValue(&quot;methodName&quot;));//show //3.调用show()方法 m.invoke(stuClass.getConstructor().newInstance()); &#125; //此方法接收一个key，在配置文件中获取相应的value public static String getValue(String key) throws IOException&#123; Properties pro = new Properties();//获取配置文件的对象 FileReader in = new FileReader(&quot;pro.txt&quot;);//获取输入流 pro.load(in);//将流加载到配置文件对象中 in.close(); return pro.getProperty(key);//返回根据key获取的value值 &#125;&#125; 控制台输出： is show() 需求： 当我们升级这个系统时，不要Student类，而需要新写一个Student2的类时，这时只需要更改pro.txt的文件内容就可以了。代码就一点不用改动。 12345public class Student2 &#123; public void show2()&#123; System.out.println(&quot;is show2()&quot;); &#125;&#125; 配置文件更改为： className = cn.fanshe.Student2 methodName = show2 反射方法的其他使用–通过反射越过泛型检查：泛型用在编译期，编译过后泛型擦除（消失掉），所以是可以通过反射越过泛型检查的 测试类 12345678910111213141516171819202122232425262728import java.lang.reflect.Method;import java.util.ArrayList; /* * 通过反射越过泛型检查 * 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？ */public class Demo &#123; public static void main(String[] args) throws Exception&#123; ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add(&quot;aaa&quot;); strList.add(&quot;bbb&quot;); // strList.add(100); //获取ArrayList的Class对象，反向的调用add()方法，添加数据 Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象 //获取add()方法 Method m = listClass.getMethod(&quot;add&quot;, Object.class); //调用add()方法 m.invoke(strList, 100); //遍历集合 for(Object obj : strList)&#123; System.out.println(obj); &#125; &#125;&#125; 控制台输出： aaa bbb 100 版权声明：本文为CSDN博主「张维鹏」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/a745233700/article/details/82893076","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-05-26T11:13:32.332Z","updated":"2021-05-26T11:13:32.332Z","comments":true,"path":"2021/05/26/hello-world/","link":"","permalink":"http://example.com/2021/05/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"排序算法总结","slug":"排序算法","date":"2021-05-25T16:00:00.000Z","updated":"2021-05-27T02:24:53.339Z","comments":true,"path":"2021/05/26/排序算法/","link":"","permalink":"http://example.com/2021/05/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"冒泡排序简析：比较相邻的两个元素，如果当前数字比后面的数字大，就交换位置 下列代码做了改进，从数组的末尾开始比较，除了能将最小元素移动至第一位外，还将第二小的元素尽可能的移动至靠近适合它的位置。 123456789101112public void bubbleSort(int[] arr)&#123; int i,j,len=arr.length-1; for(i=0;i&lt;len;i++)&#123; for(j=len-1;j&gt;=i;--j)&#123; if(arr[j]&gt;arr[j+1])&#123; int tmp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=tmp; &#125; &#125; &#125;&#125; 选择排序简析：在未排序的序列中，找到最小的元素，放到排列元素的起始位置；然后再从未排序的序列中找到最小的元素，放到已排序序列的末尾，依次类推，直至末尾。 1234567891011121314public void selectSort(int[] arr)&#123; int minIndex; for(int i=0;i&lt;arr.length;i++)&#123; minIndex=i; for(int j=i;j&lt;arr.length;j++)&#123; if(arr[j]&lt;arr[minIndex])&#123; minIndex=j; &#125; &#125; int tmp=arr[minIndex]; arr[minIndex]=arr[i]; arr[i]=tmp; &#125;&#125; 插入排序简析：对于未排序的序列，在已排序的序列中从后往前扫描，找到合适的位置并插入。 123456789101112public void InsertSort(int[] arr)&#123; int len=arr.length; for(int i=1;i&lt;len;i++)&#123; int insertVal=arr[i];//要插入的值 int insertIndex=i-1;//要插入的值的前一个坐标 while(inserIndex&gt;=0&amp;&amp;insertVal&lt;arr[insertIndex])&#123; arr[insertIndex+1]=arr[insertIndex]; intsertIndex--; &#125;//跳出循环时说明要插入的位置在insertIndex后面 arr[insertIndex+1]=insertVal; &#125;&#125; 希尔排序简析：希尔排序是插入排序的优化版，通过设置不同的步长并逐步减少步长，以步长为单次移动距离，可大幅缩短所需时间。 12345678910111213141516171819public void shellSort(int[] arr)&#123; int len=arr.length; for(int step=len/2;step&gt;0;step/=2)&#123; for(int i=step;i&lt;len;i++)&#123; //记录下要移动的元素下标 int tmpIndex=i; //记录下要移动的元素值 int tmpVal=arr[tmpIndex]; //如果需要移动，那就移动至合适的位置 if(tmpVal&lt;arr[tmmIndex-step])&#123; while(temIndex-step&gt;=0&amp;&amp;tmpVal&lt;arr[tmpIndex-step])&#123; arr[tmpIndex]=arr[tmpIndex-step]; tmpIndex-=step; &#125; &#125;//tmpIndex已经是合适的位置 arr[tmpIndex]=tmpVal; &#125; &#125;&#125; 归并排序简析：将已有序的子序列合并；起始默认单个元素既是一个有序序列。 12345678910111213141516171819202122232425262728293031323334353637383940public class MergeSort &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;8, 4, 5, 7, 1, 3, 6, 2&#125;; int[] tmp = new int[arr.length]; sort(arr,0,arr.length-1,tmp); System.out.println(Arrays.toString(arr)); &#125; private static void sort(int[] arr,int left,int right,int[] tmp) &#123; if(left&gt;=right)&#123; return; &#125; int mid=left+(right-left)/2; sort(arr, left,mid,tmp); sort(arr, mid+1, right,tmp); if(arr[mid]&lt;=arr[mid+1])&#123; return; &#125; merge(arr,left,right,mid,tmp); &#125; private static void merge(int[] arr, int left, int right, int mid,int[] tmp) &#123; int i=left; int j=mid+1; for (int k = left; k &lt;= right; k++) &#123; tmp[k]=arr[k]; &#125; for(int k=left ;k&lt;=right;k++)&#123; if(i==mid+1)&#123; arr[k]=tmp[j++]; &#125;else if(j==right+1)&#123; arr[k]=tmp[i++]; &#125;else if(tmp[i]&lt;=tmp[j])&#123; arr[k]=tmp[i++]; &#125;else&#123; arr[k]=tmp[j++]; &#125; &#125; &#125;&#125; 快速排序简析：通过指定一个pivot，使得数组以pivot为基准，大于pivot的都移动至pivot右边，小于pivot的都移动至其左边，然后对pivot两边的数组再次进行递归排序即可。 123456789101112131415161718192021222324public vodi quickSort(int[] arr,int l,int r)&#123; if(l&lt;r)&#123; int left=l,right=r; int pivot=arr[l]; while(left&lt;right)&#123; while(left&lt;right&amp;&amp;arr[right]&gt;=pivot)&#123;//先找到一个需要移动的right。 //注意，此处必须先寻找right，因为left位置的元素已经取出（就是pivot），所以可以先对left的位置赋值 --right; &#125; if(left&lt;right)&#123; arr[left++]=arr[right]； &#125; while(left&lt;right&amp;&amp;arr[left]&lt;=pivot)&#123; ++left; &#125; if(left&lt;right)&#123; arr[right--]=arr[left]; &#125; &#125; arr[right]=pivot;//这个赋值给left或者right都可以 quickSort(arr,l,right-1); quickSort(arr,right+1,r); &#125;&#125; 代码2： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @author Mithrandir * @date 2021-03-2021/3/27-21:36 */public class QuickSortAnother &#123; public static void main(String[] args) &#123; int[] arr=&#123;1,6,5,4,3,2,9,1&#125;; quicksort(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); &#125; /** * 随机将一个数字放至其合适的位置，并对该位置左右两区间进行排序 * @param arr 待排序的数组 * @param left 数组的左端 * @param right 数组的右端 */ private static void quicksort(int[] arr,int left,int right) &#123; if(left&gt;=right)&#123; return; &#125; int mid=partition(arr,left,right); quicksort(arr, left, mid-1); quicksort(arr, mid+1, right); &#125; /** * 这个要完成的功能是对数组内的一个随机数字安排至合适的位置，并以该位置为根据将数组分为左右区间 * @param arr * @param left * @param right * @return */ private static int partition(int[] arr, int left, int right) &#123; Random random = new Random(); //来区间内位置的一个随机位置 int tmpIndex=random.nextInt(right-left+1)+left; //将该位置的数字放到数组的最右侧 swap(arr,tmpIndex,right); //定义一个索引 int index=left; for(int i=left;i&lt;right;i++)&#123; if(arr[i]&lt;arr[right])&#123;//凡是小于我们的随机数的值，一律从左开始排 swap(arr, i, index++); &#125; &#125; //此时，index左侧的所有值，均小于随机数，将随机数放到index的位置 swap(arr,index, right); return index; &#125; private static void swap(int[] arr, int i, int j) &#123; int tmp=arr[i]; arr[i]=arr[j]; arr[j]=tmp; &#125;&#125; 计数排序简析：计数排序适用于元素数值较为集中，且元素要是确定范围内的整数 123456789101112131415161718192021222324252627282930313233public void countingSort(int[] arr)&#123; if(arr.length==0)&#123; return; &#125; //找到arr里的最大最小值 int min=arr[0],max=arr[0]; for(int i=1;i&lt;arr.length;i++)&#123; if(arr[i]&gt;max)&#123; max=arr[i]; &#125; if(arr[i]&lt;min)&#123; min=arr[i]; &#125; &#125; //定义一个关键值 int bias=0-min; //准备一个额外数组 int[] bucket=new int[max-min+1]; //遍历整个数组，记录每个元素出现的次数 for(int i=0;i&lt;arr.length;i++)&#123; bucket[arr[i]+bias]++; &#125; //接下来准备重新排列arr,index为arr的索引，i为bucket的索引 int index=0,i=0; while(index&lt;arr.length)&#123; if(bucket[i]!=0)&#123; arr[index++]=i-bias; bucket[i]--; &#125;else&#123; i++; &#125; &#125;&#125; 基数排序简析：基数和计数都是用了桶来进行排序，不同的是，基数对所有元素的分配做了优化：按照每个元素的同一位（即个位，十位等）进行摆放，也就是说，所用到的桶一共有10层（0~9），在一轮循环中，每一层放的数据在某一位都相同。基数排序用的空间取决于元素的个数，而计数排序所用的额外空间取决于元素的范围（即最小-最大）。 123456789101112131415161718192021222324252627282930313233343536373839public static void review(int[] arr) &#123; //第一步，先找到数组中的最大值 int size = arr.length; int max = arr[0]; for (int i = 1; i &lt; size; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; //根据最大值找到最大长度 String str = max + &quot;&quot;; int maxLength = str.length(); //创建一个桶，用于盛放处理后的数组 int[][] bucket = new int[10][size]; //还得创建一个计数器，用于计算每个位置放了多少个数据 int[] numsCounter = new int[10]; //接下来就进入每一层的操作：放入桶，从桶中取出 //定义两个变量，k用于确定数据的哪一层，m用于对每个数据进行取余操作 for (int k = 0, m = 1; k &lt; maxLength; m *= 10, k++) &#123; //先将数据取出，根据个（十、百）位数的大小放入桶中 for (int i = 0; i &lt; size; i++) &#123; //取出个位 int num = arr[i] / m % 10; //放入个位对应的桶中 bucket[num][numsCounter[num]++] = arr[i]; &#125; //此时已完成所有数据入桶,按照顺序将其取出 //定义一个索引，用于在arr中重新排序 int index = 0; for (int i = 0; i &lt; bucket.length; i++) &#123; if (numsCounter[i] != 0) &#123;//i的取值范围是0~9，numsCounter[i]!=0说明该位置存放的有数据，需要取出 for (int j = 0; j &lt; numsCounter[i]; j++) &#123; arr[index++] = bucket[i][j]; &#125; &#125; numsCounter[i] = 0; &#125; &#125; &#125;","categories":[{"name":"HelloWorld系列","slug":"HelloWorld系列","permalink":"http://example.com/categories/HelloWorld%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"搜索算法","slug":"搜索算法","date":"2021-05-25T16:00:00.000Z","updated":"2021-05-27T02:25:22.120Z","comments":true,"path":"2021/05/26/搜索算法/","link":"","permalink":"http://example.com/2021/05/26/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/","excerpt":"","text":"有序表查找二分查找代码如下：123456789101112131415public int binarySearch(int[] arr,int target)&#123; int low=0,height=arr.length-1; int mid; while(low&lt;=height)&#123; mid=(low+height)/2; if(arr[mid]&lt;target)&#123; low=mid+1; &#125;else if(arr[mid]&gt;target)&#123; height=mid-1; &#125;else&#123; return mid; &#125; &#125; return -1;&#125; 插值查找适用于数值分布均匀的查找表。 代码如下：123456789101112131415public int binarySearch(int[] arr,int target)&#123; int low=0,height=arr.length-1; int mid; while(low&lt;=height)&#123; mid=low+(hight-low)(arr[mid]-arr[low])/(arr[height]-arr[low]); if(arr[mid]&lt;target)&#123; low=mid+1; &#125;else if(arr[mid]&gt;target)&#123; height=mid-1; &#125;else&#123; return mid; &#125; &#125; return -1;&#125; 斐波那契查找利用了斐波那契数列 12345678910111213141516171819202122232425262728293031323334353637383940414243 public static int fibSearch(int[] arr,int target)&#123; int low=0,heigh=arr.length-1; int[] f=fib(); //k为合适的斐波那契数 int k=0; while(heigh&gt;f[k]-1)&#123; ++k; &#125; //定义斐波那契数长度的数组 int[] nums = Arrays.copyOf(arr, f[k]); for(int i=heigh;i&lt;f[k];i++)&#123; nums[i]=nums[heigh]; &#125; int mid; while (low&lt;=heigh)&#123; mid=low+f[k-1]-1; if(target&gt;arr[mid])&#123; k-=2; low=mid+1; &#125;else if(target&lt;arr[mid])&#123; --k; heigh=mid-1; &#125;else&#123; if(mid&lt;heigh)&#123; return mid; &#125;else&#123; return heigh; &#125; &#125; &#125; return -1; &#125;//创建一个斐波那契数列public static int[] fib()&#123; int[] f=new int[20]; f[0]=1; f[1]=1; for(int i=2;i&lt;20;i++)&#123; f[i]=f[i-1]+f[i-2]; &#125; return f; &#125;","categories":[{"name":"HelloWorld系列","slug":"HelloWorld系列","permalink":"http://example.com/categories/HelloWorld%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://example.com/tags/%E6%90%9C%E7%B4%A2/"}]}],"categories":[{"name":"leetcode刷题笔记","slug":"leetcode刷题笔记","permalink":"http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"JVM相关","slug":"JVM相关","permalink":"http://example.com/categories/JVM%E7%9B%B8%E5%85%B3/"},{"name":"Java并发","slug":"Java并发","permalink":"http://example.com/categories/Java%E5%B9%B6%E5%8F%91/"},{"name":"项目Hospital","slug":"项目Hospital","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AEHospital/"},{"name":"HelloWorld系列","slug":"HelloWorld系列","permalink":"http://example.com/categories/HelloWorld%E7%B3%BB%E5%88%97/"},{"name":"读书总结","slug":"读书总结","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"},{"name":"小技巧","slug":"小技巧","permalink":"http://example.com/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"踩坑记录","slug":"踩坑记录","permalink":"http://example.com/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"图","slug":"图","permalink":"http://example.com/tags/%E5%9B%BE/"},{"name":"基础知识点","slug":"基础知识点","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"动态规划、二分查找","slug":"动态规划、二分查找","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"归并排序","slug":"归并排序","permalink":"http://example.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"BFS","slug":"BFS","permalink":"http://example.com/tags/BFS/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"进制问题","slug":"进制问题","permalink":"http://example.com/tags/%E8%BF%9B%E5%88%B6%E9%97%AE%E9%A2%98/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"搜索","slug":"搜索","permalink":"http://example.com/tags/%E6%90%9C%E7%B4%A2/"}]}