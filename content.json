{"meta":{"title":"Mithrandir","subtitle":"将此博客当作一路成长走过的路。","description":"且将新火试新茶，诗酒趁年华","author":"aoqiangzhang143","url":"http://example.com","root":"/"},"pages":[{"title":"archives","date":"2021-05-27T01:33:43.000Z","updated":"2021-05-27T01:33:43.928Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-05-26T13:31:13.000Z","updated":"2021-05-27T01:36:57.220Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"公益404","date":"2021-05-27T01:34:24.000Z","updated":"2021-05-27T01:37:28.781Z","comments":true,"path":"commonweal/index.html","permalink":"http://example.com/commonweal/index.html","excerpt":"","text":""},{"title":"日程表","date":"2021-05-27T01:34:01.000Z","updated":"2021-05-27T01:37:49.200Z","comments":true,"path":"schedule/index.html","permalink":"http://example.com/schedule/index.html","excerpt":"","text":""},{"title":"","date":"2021-05-27T08:19:00.192Z","updated":"2021-05-27T08:19:00.192Z","comments":true,"path":"lib/canvas-ribbon/canvas-ribbon.js","permalink":"http://example.com/lib/canvas-ribbon/canvas-ribbon.js","excerpt":"","text":"/** * Copyright (c) 2016 hustcc * License: MIT * Version: v1.0.1 * GitHub: https://github.com/hustcc/ribbon.js **/ /*jshint -W030 */ ! function() { function attr(node, attr, default_value) { return Number(node.getAttribute(attr)) || default_value; } // get user config var scripts = document.getElementsByTagName('script'), script = scripts[scripts.length - 1]; // 当前加载的script config = { z: attr(script, \"zIndex\", -1), // z-index a: attr(script, \"alpha\", 0.6), // alpha s: attr(script, \"size\", 90), // size }; var canvas = document.createElement('canvas'), g2d = canvas.getContext('2d'), pr = window.devicePixelRatio || 1, width = window.innerWidth, height = window.innerHeight, f = config.s, q, t, m = Math, r = 0, pi = m.PI*2, cos = m.cos, random = m.random; canvas.width = width * pr; canvas.height = height * pr; g2d.scale(pr, pr); g2d.globalAlpha = config.a; canvas.style.cssText = 'opacity: ' + config.a + ';position:fixed;top:0;left:0;z-index: ' + config.z + ';width:100%;height:100%;pointer-events:none;'; // create canvas document.getElementsByTagName('body')[0].appendChild(canvas); function redraw() { g2d.clearRect(0, 0, width, height); q = [{x: 0, y: height * 0.7 + f}, {x: 0, y: height * 0.7 - f}]; while(q[1].x < width + f) draw(q[0], q[1]); } function draw(i, j) { g2d.beginPath(); g2d.moveTo(i.x, i.y); g2d.lineTo(j.x, j.y); var k = j.x + (random()*2-0.25)*f, n = line(j.y); g2d.lineTo(k, n); g2d.closePath(); r -= pi / -50; g2d.fillStyle = '#'+(cos(r)*127+128"},{"title":"站点地图","date":"2021-05-27T01:34:10.000Z","updated":"2021-05-27T01:38:10.193Z","comments":true,"path":"sitemap/index.html","permalink":"http://example.com/sitemap/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-05-26T13:30:53.000Z","updated":"2021-05-27T01:36:04.485Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-05-27T08:19:00.191Z","updated":"2021-05-27T08:19:00.191Z","comments":true,"path":"lib/canvas-ribbon/README.html","permalink":"http://example.com/lib/canvas-ribbon/README.html","excerpt":"","text":"canvas-ribbon.js for NexT Installation If you want to use the CDN instead of clone this repo, please jump to the Step 3. Step 1 &rarr; Go to NexT dir Change dir to NexT directory. There must be layout, source, languages and other directories: 123$ cd themes/next$ ls_config.yml crowdin.yml docs gulpfile.js languages layout LICENSE.md package.json README.md scripts source Step 2 &rarr; Get module Install module to source/lib directory: 1$ git clone https://github.com/theme-next/theme-next-canvas-ribbon source/lib/canvas-ribbon Step 3 &rarr; Set it up Enable module in NexT _config.yml file: 12canvas_ribbon: enable: true And, if you wants to use the CDN, then need to set: 123vendors: ... canvas_ribbon: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js Update 12$ cd themes/next/source/lib/canvas-ribbon$ git pull"},{"title":"","date":"2021-05-27T04:33:51.869Z","updated":"2021-05-27T04:33:51.869Z","comments":true,"path":"lib/bookmark/README.html","permalink":"http://example.com/lib/bookmark/README.html","excerpt":"","text":"Bookmark for NexT Introduce Bookmark is a plugin that allow the users save their reading position. The users could just click the bookmark icon (like 🔖) in left-top of the page to save the position. And when they visit your blog in the next time, they can continue the last reading position by clicking the bookmark icon from the home page. Installation If you want to use the CDN instead of clone this repo, please jump to the Step 3. Step 1 &rarr; Go to NexT dir Change dir to NexT directory. There must be layout, source, languages and other directories: 123$ cd themes/next$ lsbower.json _config.yml docs gulpfile.coffee languages layout LICENSE.md package.json README.md scripts source test Step 2 &rarr; Get module Install module to source/lib directory: 1$ git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark Step 3 &rarr; Set it up Enable module in NexT _config.yml file: 1bookmark: true And, if you wants to use the CDN, then need to set: 123vendors: ... bookmark: https://cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@latest/bookmark.min.js Update 12$ cd themes/next/source/lib/bookmark$ git pull"},{"title":"","date":"2021-05-27T04:33:51.870Z","updated":"2021-05-27T04:33:51.870Z","comments":true,"path":"lib/bookmark/bookmark.min.js","permalink":"http://example.com/lib/bookmark/bookmark.min.js","excerpt":"","text":"!function(o){\"use strict\";var n=o.localStorage;null==n&&(n={getItem:function(){return null},setItem:function(){},removeItem:function(){},clear:function(){}});var t,e=function(){var o=n.getItem(\"bookmark\");if(null==o)return null;try{return JSON.parse(o)}catch(o){return null}},a=function(){var n=o.document.createElement(\"style\");n.type=\"text/css\";var e=\".book-mark-link{border-bottom:none;display:block;position:fixed;color:#222;font-size:26px !important;top:-10px;left:20px;transition:.3s;}.book-mark-link:hover,.book-mark-link-fixed{top:-2px}@media(max-width:1090px){.book-mark-link{display:none}}\";e=o.document.createTextNode(e),n.appendChild(e),o.document.head.appendChild(n),t=$(''),$(o.document.body).append(t);var a=0;$(o).on(\"scroll.bookmark\",function(){var n=o.document.documentElement.scrollTop;n>0?0===a&&(t.removeClass(\"book-mark-link-fixed\"),a=n):a>0&&(!t.hasClass(\"book-mark-link-fixed\")&&t.addClass(\"book-mark-link-fixed\"),a=0)})},r=function(e,a){null==a&&(a={});var r=o.document.documentElement.scrollTop;return a.lastUri=e,a[e]=r,n.setItem(\"bookmark\",JSON.stringify(a)),t.animate({top:-26},\"fast\",function(){setTimeout(function(){t.css(\"top\",\"\")},400)}),a};o.bookmark={loadBookmark:function(){var o=e();null!=o&&$(function(){a(),t.attr(\"href\",o.lastUri+\"#book:mark\")})},scrollToMark:function(n,l){var i=o.location.pathname,c=e();$(function(){var e;a(),t.click(function(){return c=r(i,c),!1}),\"auto\"===n&&o.addEventListener(\"beforeunload\",function(){r(i,c)}),null!=c&&([l,\"#comments\"].filter(function(n){return n===o.location.hash}).length>0||(e=c[i],isNaN(e)||$(function(){$(o.document.documentElement).animate({scrollTop:e},\"fast\")})))})}}}(window);"},{"title":"","date":"2021-05-27T04:33:51.871Z","updated":"2021-05-27T04:33:51.871Z","comments":true,"path":"lib/bookmark/package.json","permalink":"http://example.com/lib/bookmark/package.json","excerpt":"","text":"{\"name\":\"theme-next-bookmark\",\"version\":\"1.0.2\",\"description\":\"A plugin of local-bookmarks for NexT theme.\",\"main\":\"index.js\",\"scripts\":{\"test\":\"eslint index.js\",\"dist\":\"eslint index.js && uglifyjs --compress --mangle -o bookmark.min.js -- index.js\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/theme-next/theme-next-bookmark.git\"},\"keywords\":[\"hexo\",\"theme-next\",\"plugin\",\"bookmark\"],\"author\":\"Tsanie Lily\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/theme-next/theme-next-bookmark/issues\"},\"homepage\":\"https://github.com/theme-next/theme-next-bookmark#readme\",\"devDependencies\":{\"eslint\":\"^4.17.0\",\"eslint-config-google\":\"^0.9.1\",\"uglify-js\":\"^3.3.10\"}}"},{"title":"","date":"2021-05-27T04:33:51.870Z","updated":"2021-05-27T04:33:51.870Z","comments":true,"path":"lib/bookmark/index.js","permalink":"http://example.com/lib/bookmark/index.js","excerpt":"","text":"(function (global) { 'use strict'; var storage = global.localStorage; if (storage == null) { // if the localStorage is not exists storage = { // eslint-disable-next-line getItem: function () { return null }, setItem: function () { }, removeItem: function () { }, clear: function () { }, }; } // get the saved bookmark object var getBookmark = function () { var mark = storage.getItem('bookmark'); if (mark == null) { return null; } try { return JSON.parse(mark); } catch (e) { // invalid object saved in the storage // console.warn('Invalid bookmark object.'); return null; } }; var link; // register everything var init = function () { // bookmark-link style var style = global.document.createElement('style'); style.type = 'text/css'; var text = '.book-mark-link{' + 'border-bottom:none;' + 'display:block;' + 'position:fixed;' + 'color:#222;' + 'font-size:26px !important;' + 'top:-10px;left:20px;' + 'transition:.3s;' + '}' + '.book-mark-link:hover,.book-mark-link-fixed{top:-2px}' // do not show when the width is not enough + '@media(max-width:1090px){.book-mark-link{display:none}}'; text = global.document.createTextNode(text); style.appendChild(text); global.document.head.appendChild(style); // create a link element // eslint-disable-next-line max-len link = $(''); $(global.document.body).append(link); var currentTop = 0; // scroll event $(global).on('scroll.bookmark', function () { var top = global.document.documentElement.scrollTop; if (top > 0) { if (currentTop === 0) { link.removeClass('book-mark-link-fixed'); currentTop = top; } } else { if (currentTop > 0) { !link.hasClass('book-mark-link-fixed') && link.addClass('book-mark-link-fixed'); currentTop = 0; } } }); }; var loadBookmark = function () { var mark = getBookmark(); if (mark == null) { return; } // found the bookmark $(function () { init(); link.attr('href', mark.lastUri + '#book:mark'); }); }; var doScroll = function (top) { if (!isNaN(top)) { $(function () { // eslint-disable-next-line max-len $(global.document.documentElement).animate({ 'scrollTop': top }, 'fast'); }); } }; var doSaveScroll = function (path, mark) { if (mark == null) { mark = {}; } var top = global.document.documentElement.scrollTop; mark.lastUri = path; mark[path] = top; storage.setItem('bookmark', JSON.stringify(mark)); link.animate({ top: -26 }, 'fast', function () { setTimeout(function () { link.css('top', ''); }, 400); }); return mark; }; var scrollToMark = function (trigger, hash) { var path = global.location.pathname; var mark = getBookmark(); $(function () { init(); // save the position by clicking the icon link.click(function () { mark = doSaveScroll(path, mark); return false; }); // register beforeunload event when the trigger is auto if (trigger === 'auto') { // register beforeunload event global.addEventListener('beforeunload', function () { doSaveScroll(path, mark); }); } // auto scroll to the position if (mark == null) { return; } // and if the page opens with a specific hash, just jump out var skips = [hash, '#comments']; // eslint-disable-next-line if (skips.filter(function (h) { return h === global.location.hash }).length > 0) { return; } doScroll(mark[path]); }); }; global.bookmark = { loadBookmark: loadBookmark, scrollToMark: scrollToMark, }; })(window);"},{"title":"","date":"2021-05-27T04:33:51.871Z","updated":"2021-05-27T04:33:51.871Z","comments":true,"path":"lib/bookmark/renovate.json","permalink":"http://example.com/lib/bookmark/renovate.json","excerpt":"","text":"{\"extends\":[\"config:base\"]}"}],"posts":[{"title":"Spring实战第四版读书笔记","slug":"Spring实战第四版读书笔记","date":"2021-06-03T16:00:00.000Z","updated":"2021-06-07T02:29:23.357Z","comments":true,"path":"2021/06/04/Spring实战第四版读书笔记/","link":"","permalink":"http://example.com/2021/06/04/Spring%E5%AE%9E%E6%88%98%E7%AC%AC%E5%9B%9B%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Spring实战第四版spring本质上是简化java开发。 几个简写： EJB Enterprise JavaBean 企业级javabean JDO Java Data Object java数据对象 POJO Plian Old Java Object 简单老式java对象 DI Dependency Injection 依赖注入 AOP Aspect-Oriented Programing 面向切面编程 第一章：简介怎么简化java开发的：通过DI和AOP实现松耦合；基于切面和惯例进行声明式编程；通过切面和模板减少样板式代码 AOP的作用：AOP通过将遍布应用各处的功能分离出来，形成可重用的组件，从而确保pojo的简单性 Spring容器：将一个类转化为一个切面，首先需要将其声明为一个SpringBean，bean对象生存于Spring容器中； Spring的容器分为两大类：bean工厂和应用上下文。 第二章：装配bean装配bean有三种方式： 1、xml配置 2、java显示装配 3、自动装配【重要】 自动装配最为便捷。 以下为简单的自动装配 分别创建三个pojo并进行注解 12345678910package com.learn.springlearn.exm3;import org.springframework.stereotype.Component;//第一个pojo@Componentpublic class Cat &#123; public void voice()&#123; System.out.println(&quot;喵喵喵&quot;); &#125;&#125; 12345678910package com.learn.springlearn.exm3;import org.springframework.stereotype.Component;//第二个pojo@Componentpublic class Dog &#123; public void voice()&#123; System.out.println(&quot;汪汪叫&quot;); &#125;&#125; 123456789101112131415161718package com.learn.springlearn.exm3;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;//第三个pojo@Componentpublic class Human &#123; @Autowired private Cat cat; @Autowired private Dog dog; public void say()&#123; System.out.println(&quot;我有两只宠物&quot;); cat.voice(); dog.voice(); &#125;&#125; 之后将三个pojo存放至spring容器中 123456789package com.learn.springlearn.exm3;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScanpublic class Exm3Config &#123;&#125; 最后便可对其进行测试 12345678910111213141516171819202122package com.learn.exam3test;import com.learn.springlearn.exm3.Exm3Config;import com.learn.springlearn.exm3.Human;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@ContextConfiguration(classes = Exm3Config.class)//下面这个注解必须要加，不然会报nulllpointerexception@RunWith(SpringJUnit4ClassRunner.class)public class Exm3Test &#123; @Autowired private Human human; @Test public void test()&#123; human.say(); &#125;&#125; 第三章：高级装配配置profile bean：profile可以根据环境创建哪个bean和不创建哪个bean 激活profile：如果定义了spring.profiles.active，那就根据这个配置进行激活profile 没设置active的话，如果定义了spring.profiles.default，那就根据default进行jihuo 如果都没设置，那就只创建那些没定义在profile中的bean 条件化的bean通过注解Conditional实现，只有指定属性不存在的话，指定类就不会被实例化。 自动装配的歧义性一个接口会存在多个实现类，此时进行自动装配时，spring无法确定装配哪个类。 解决方法： 1、设置首选bean：@Primary 2、采用限定符来确定装配指定的bean：@Qualifier（“iceCream”）；@Qualifier也可以用于bean上，相当于为该bean设置ID；@Qualifier也可以将每个bean的ID设置为该类的特性，一个bean会存在多个特性，但是同一个类不允许多次使用同一个注解，因此可自行创建注解","categories":[{"name":"读书总结","slug":"读书总结","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"mybatisplus使用总结","slug":"mybatisplus使用总结","date":"2021-06-03T16:00:00.000Z","updated":"2021-06-04T02:43:47.207Z","comments":true,"path":"2021/06/04/mybatisplus使用总结/","link":"","permalink":"http://example.com/2021/06/04/mybatisplus%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"使用mybatis对数据库进行操作时，为方便定位错误，可在配置文件中进行配置使得myqsl语句在控制台进行输出 在application.properties配置 12#控制面板输出mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl MybatisPlus的主键策略默认采用的是雪花算法：分布式ID生成器 核心思想： 长度共64bit（一个long型）。 首先是一个符号位，1bit标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0。 41bit时间截(毫秒级)，存储的是时间截的差值（当前时间截 - 开始时间截)，结果约等于69.73年。 10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID，可以部署在1024个节点）。 12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID）。 优点：整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞，并且效率较高。 MyBatisPlus自动填充功能好处：自动实现set功能 使用方法： 举例：添加记录的创建时间和修改时间 1、在数据库表中创建对应列：create_time,update_time 2、在对应的实体类中添加对应属性：createTime,updateTime，并添加注解 3、创建一个类，实现MetaObjectHandler接口，并重写其中的两个方法","categories":[{"name":"mybatisplus","slug":"mybatisplus","permalink":"http://example.com/categories/mybatisplus/"}],"tags":[]},{"title":"mysql登录","slug":"mysql登录","date":"2021-06-02T16:00:00.000Z","updated":"2021-06-03T08:19:21.109Z","comments":true,"path":"2021/06/03/mysql登录/","link":"","permalink":"http://example.com/2021/06/03/mysql%E7%99%BB%E5%BD%95/","excerpt":"","text":"启动mysql：systemctl start mysqld 查看mysql启动状态：systemctl status mysqld 显示active表示已经激活。 进行登录：mysql -uroot -p","categories":[{"name":"项目Hospital","slug":"项目Hospital","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AEHospital/"}],"tags":[]},{"title":"IDEA快捷键总结","slug":"IDEA快捷键总结","date":"2021-06-01T16:00:00.000Z","updated":"2021-06-02T08:27:36.746Z","comments":true,"path":"2021/06/02/IDEA快捷键总结/","link":"","permalink":"http://example.com/2021/06/02/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93/","excerpt":"","text":"1 快捷键 功能 2 Ctrl+Shift+A 搜索操作方式 3 Ctrl+Space 基本代码补全，输入字母按后列出匹配的词组 4 Ctrl+Shift+Space 智能代码补全，列出与预期类型一致的方法或变量 5 Ctrl+Alt+Space 补全类名 6 Ctrl+Shift+Enter 补全语句 7 Ctrl+P 显示方法参数 8 Ctrl+Q 显示注释文档 9 Shift+F1 显示外部文档 10 Ctrl+mouse over code 显示描述信息 11 Ctrl+F1 示提示、警告、错误等信息 12 Alt+lnsert 生成代码，生成Getter、Setter构造器等 13 Ctrl+O 重写父类方法 14 Ctrl+I 实现接口方法 15 Ctrl+/ 使用“//”注释或取消注释 16 Ctrl+Shift+/ 使用“/** **/”注释或取消注释 17 Ctrl+W 选择代码块，连续按会增加选择外层的代码块 18 Ctrl+Shift+W 与“Ctrl+W”相反，减少选择代码块 19 Alt+Q 显示类描述信息 20 Alt+Enter-fixes 显示快速修复列表 21 Ctrl+Alt+L 格式化代码 22 Ctrl+Alt+O 优化 Imports 23 Ctrl+Alt+I 自动优化代码缩进 24 Tab/Shift+Tab 缩进代码/取消缩进代码 25 Ctrl+X or Shift+Delete 缩进代码/取消缩进代码 26 Ctrl+C or Ctrl+lnsert 剪切代码，未选择代码时剪切当前行 27 Ctrl+V or Shift+lnsert 粘贴代码 28 Ctrl+Shift+V 粘贴最近复制的内容 29 Ctrl+D 重复代码，未选择代码时重复当前行 30 Ctrl+Y 删除行，未选择时删除当前行 31 Ctrl+Shift+J 合并多行为一行 32 Ctrl+Enter 分割一行为多行 33 Shift+Enter 使光标所在位置的下一行为新行 34 Ctrl+Shift+U 对选中内容进行大小写切换 35 Ctrl+Shift+]/[ 选中到代码块的开始/结束 36 Ctrl+Delete 删除从光标所在位置到单词结束位置的字符 37 Ctrl+Backspace 删除从单词起始位置到光标所在位置的字符 38 Ctrl+NumPad+/- 展开或收起代码块 39 Ctrl+Shift+NumPad+ 展幵所有代码块 40 Ctrl+Shift+NumPad- 收起所有代码块 41 Ctrl+F4 关闭当前编辑页 42 Ctrl+F 查找 43 F3 查找下一个 44 Shift+F3 查找上一个 45 Ctrl+R 替换 46 Ctrl+Shift+F 目录内查找 47 Ctrl+Shift+R 目录内替换 48 Ctrl+Shift+S 语法模板搜索 49 Ctrl+Shift+M 语法模板替换 50 Alt+F7 查找被使用处 51 Ctrl+F7 查找当前文件中的使用处 52 Ctrl+Shift+F7 高亮当前文件中的使用处 53 Ctrl+Alt+F7 列出使用者 54 Ctrl+F9 Make模块、项目 55 Ctrl+Shift+F9 编译选中的文件、模块、项目 56 Alt+Shift+F10 选择配置后运行代码 57 Alt+Shift+F9 选择配置后调试代码 58 Shift+F10 运行代码 59 Shift+F9 调试代码 60 Ctrl+F2 停止调试 61 F8 单步调试，不进入函数内部 62 F7 单步调试，进入函数内部 63 Shift+F7 选择要进入的函数 64 Shift+F8 跳出函数 65 Alt+F9 运行到断点 66 Alt+F8 执行表达式查看结果 67 F9 继续执行，进入下一个断点或执行完程序 68 Ctrl+F8 设置/取消当前行断点 69 Ctrl+Shift+F8 查看断点 70 双击 Shift 查找所有 71 Ctrl+N 查找类 72 Ctrl+Shift+N 查找文件 73 Ctrl+Alt+Shift+N Go to symbol 74 Alt+Right/Left 左右切换Tab 75 F12 回到上一个打开的窗口 76 Esc 焦点回到编辑器 77 Shift+Esc 隐藏打开的视图 78 Ctrl+Shift+F4 关闭当前Tab 79 Ctrl+G 跳到指定行 80 Ctrl+E 显示最近打开的文件 81 Ctrl+Alt+Left 跳到光标的上一个位置 82 Ctrl+Alt+Right 跳到光标的下一个位置 83 Ctrl+Shift+Backspace 跳到上一个编辑处 84 Alt+F1 选择当前文件显示在不同的视图 85 Ctrl+Bor/Ctrl+Click 跳到类声明处 86 Ctrl+Alt+B 跳到实现类/方法 87 Ctrl+Shift+I 显示类/变量/方法定义 88 Ctrl+Shift+B 跳到类型定义处 89 Ctrl+U 跳到父类/方法 90 Alt+Up 光标移动到上一个方法 91 Alt+Down 光标移动到下一个方法 92 Ctrl+[ 光标移动到代码块的起始位置 93 Ctrl+] 光标移动到代码块的结束位置 94 Ctrl+F12 显示文件结构 95 Ctrl+H 显示类层级 96 Ctrl+Shift+H 显示方法层级 97 Ctrl+Alt+H 显示类/方法调用层级 98 F2 光标移动到下一个错误 99 Shift+F2 光标移动到上一个错误 100 F4 编辑源码，光标移到编辑器内 101 Ctrl+Enter 查看源码，光标没移到编辑器内 102 Alt+Home 显示导航面包屑 103 F11 当前行设置书签 104 Shift+F11 显示所有书签 105 Ctrl+F11 设置书签号［0-9］ 106 Ctrl+[0-9] 跳到书签号［0-9］所在位置 107 F5 复制类 108 F6 移动类 109 Alt+Delete 安全删除，删除前会提示调用处 110 Shift+F6 重命名 111 Ctrl+F6 重构方法参数、Exception等 112 Ctrl+Alt+N 合并多行为一行 113 Ctrl+Alt+M 提取为新方法 114 Ctrl+Alt+V 提取为新变量 115 Ctrl+Alt+F 提取为对象新属性 116 Ctrl+Alt+C 提取为新静态常量 117 Alt+0 聚焦到Messages窗口 118 Alt+1 焦到Project窗口 119 Alt+2 聚焦到Favorite窗口 120 Alt+3 聚焦到Find窗口 121 Alt+4 聚焦到Run窗口 122 Alt+5 聚焦到Debug窗口 123 Alt+6 聚焦到TODO窗口 124 Alt+7 聚焦到Structure窗口 125 Alt+8 聚焦到Hierarchy窗口 126 Alt+9 聚焦到Change窗口 127 Ctrl+S 保存文件 128 Ctrl+Alt+Y 与本地文件同步 129 Alt+Shift+F 添加到收藏夹 130 Alt+Shift+I 检查当前文件，包括Javadoc问题、可能存在的bug等 131 Ctrl+Alt+S 打开settings窗口 132 Ctrl+BackQuote (‘) 模式切换，包括文本外观、快捷键、编辑器外观、代码样式","categories":[{"name":"小技巧","slug":"小技巧","permalink":"http://example.com/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[]},{"title":"maven首次运行问题","slug":"maven首次运行问题","date":"2021-06-01T11:12:55.000Z","updated":"2021-06-01T11:20:35.140Z","comments":true,"path":"2021/06/01/maven首次运行问题/","link":"","permalink":"http://example.com/2021/06/01/maven%E9%A6%96%E6%AC%A1%E8%BF%90%E8%A1%8C%E9%97%AE%E9%A2%98/","excerpt":"","text":"第一次运行maven时，由于maven默认用的是jre，用命令行运行时会报错，如下图所示 根据提示错误，可知运行的是jre而不是jkd，查看maven版本 发现路径为jre，至此找到问题根源。 解决方法： 在maven\\bin\\setting文件中，在首行加上 set JAVA_HOME=C:\\JDK\\jdk1.8.0_291 将其所用的JAVA_HOME修改为本机所安装的jdk，之后问题解决，文件可正常编译。","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"http://example.com/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"运行Halo项目时遇到的问题","slug":"运行Halo项目时遇到的问题","date":"2021-05-31T02:51:55.000Z","updated":"2021-05-31T07:13:56.009Z","comments":true,"path":"2021/05/31/运行Halo项目时遇到的问题/","link":"","permalink":"http://example.com/2021/05/31/%E8%BF%90%E8%A1%8CHalo%E9%A1%B9%E7%9B%AE%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"这个问题在将jdk版本从8改为11之后就没遇到了; 但是在后续的运行中又出现了其他错误，经查阅资料，将IDEA从2019.3升级为2020.3之后解决； 后记：改完之后还需要将gradle的jdk版本以及项目运行依赖的jdk版本改为11（我装了8和11两个版本）； 最后一次运行报错是显示未找到默认主题，在halo-dev/halo-theme-anatole (github.com)进行下载并存放至Halo\\halo\\src\\main\\resources\\templates\\themes\\anatole后，成功运行。 至此成功运行。","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"http://example.com/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"AQS简述","slug":"AQS简述","date":"2021-05-28T16:00:00.000Z","updated":"2021-05-29T13:37:36.984Z","comments":true,"path":"2021/05/29/AQS简述/","link":"","permalink":"http://example.com/2021/05/29/AQS%E7%AE%80%E8%BF%B0/","excerpt":"","text":"AbstractQuenedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。 AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包 AQS的核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。 CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。 AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。 用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。 注意：AQS是自旋锁：在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功 转自：AQS原理","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"CAS简述","slug":"CAS简述","date":"2021-05-28T16:00:00.000Z","updated":"2021-05-29T13:35:37.384Z","comments":true,"path":"2021/05/29/CAS简述/","link":"","permalink":"http://example.com/2021/05/29/CAS%E7%AE%80%E8%BF%B0/","excerpt":"","text":"在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁 锁机制存在以下问题： （1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。 （2）一个线程持有锁会导致其它所有需要此锁的线程挂起。 （3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。 volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。 独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。 一、什么是CASCAS,compare and swap的缩写，中文翻译成比较并交换。 我们都知道，在java语言之前，并发就已经广泛存在并在服务器领域得到了大量的应用。所以硬件厂商老早就在芯片中加入了大量直至并发操作的原语，从而在硬件层面提升效率。在intel的CPU中，使用cmpxchg指令。 在Java发展初期，java语言是不能够利用硬件提供的这些便利来提升系统的性能的。而随着java不断的发展,Java本地方法(JNI)的出现，使得java程序越过JVM直接调用本地方法提供了一种便捷的方式，因而java在并发的手段上也多了起来。而在Doug Lea提供的cucurenct包中，CAS理论是它实现整个java包的基石。 CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” 通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。 类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算。 二、CAS的目的利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。 三、CAS存在的问题CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作 \\1. ABA****问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。 从****Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 关于ABA问题参考文档: http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html 2. 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。 3. 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS****操作。 四、 concurrent包的实现 由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式： A线程写volatile变量，随后B线程读这个volatile变量。 A线程写volatile变量，随后B线程用CAS更新这个volatile变量。 A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。 A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。 Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式： 首先，声明共享变量为volatile； 然后，使用CAS的原子条件更新来实现线程之间的同步； 同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。 转自https://blog.csdn.net/ls5718/article/details/52563959 这个讲的也挺好","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"native关键字","slug":"native关键字","date":"2021-05-28T16:00:00.000Z","updated":"2021-05-29T13:16:54.526Z","comments":true,"path":"2021/05/29/native关键字/","link":"","permalink":"http://example.com/2021/05/29/native%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"native关键字native是与C++联合开发的时候用的！java自己开发不用的！ 使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用。 这些函数的实现体在DLL中，JDK的源代码中并不包含，你应该是看不到的。对于不同的平台它们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的。 1。native 是用做java 和其他语言（如c++）进行协作时用的也就是native 后的函数的实现不是用java写的 2。既然都不是java，那就别管它的源代码了，呵呵 native的意思就是通知操作系统， 这个函数你必须给我实现，因为我要使用。 所以native关键字的函数都是操作系统实现的，java只能调用。 java是跨平台的语言，既然是跨了平台，所付出的代价就是牺牲一些对底层的控制，而java要实现对底层的控制，就要一些其他语言的帮助，这个就是native的作用了","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"wait和sleep的异同","slug":"wait和sleep的异同","date":"2021-05-28T16:00:00.000Z","updated":"2021-05-29T13:31:07.038Z","comments":true,"path":"2021/05/29/wait和sleep的异同/","link":"","permalink":"http://example.com/2021/05/29/wait%E5%92%8Csleep%E7%9A%84%E5%BC%82%E5%90%8C/","excerpt":"","text":"相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。 不同点：1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait() 2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中 3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 Sleep()方法是属于Thread类中的，而wait()方法是属于Object类中的。 Sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持着，当指定的时间结束后又会自动恢复运行状态。 在调用sleep方法时，线程不会释放对象锁。 在调用wait方法时，线程会释放对象锁，进入等待此对象的等待锁定池，只有此对象调用notify方法后本线程才进入对象锁定池准备。 sleep可以在任何地方使用，而wait只能在同步方法或者同步块中使用。 另外，sleep是静态方法，wait是非静态方法。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"快速失败、安全失败","slug":"快速失败、安全失败","date":"2021-05-28T16:00:00.000Z","updated":"2021-05-29T13:29:02.295Z","comments":true,"path":"2021/05/29/快速失败、安全失败/","link":"","permalink":"http://example.com/2021/05/29/%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E3%80%81%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5/","excerpt":"","text":"快速失败：在使用迭代器对集合进行迭代的过程中，如果 A 线程正在对集合进行遍历，此时 B 线程对集合进行修改（增加、删除、修改），或者 A 线程在遍历过程中对集合进行修改，都会导致 A 线程抛出 ConcurrentModificationException 异常。 安全失败：采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。 由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"简单死锁的测试","slug":"简单死锁的测试","date":"2021-05-28T16:00:00.000Z","updated":"2021-05-29T13:32:30.639Z","comments":true,"path":"2021/05/29/简单死锁的测试/","link":"","permalink":"http://example.com/2021/05/29/%E7%AE%80%E5%8D%95%E6%AD%BB%E9%94%81%E7%9A%84%E6%B5%8B%E8%AF%95/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738/** * @author Mithrandir * @date 2021-04-2021/4/12-10:19 * 测试死锁 */public class DeadLock &#123; public static void main(String[] args) &#123; new Thread(new myThread1()).start(); new Thread(new myThread2()).start(); &#125;&#125;class myThread2 implements Runnable&#123; @Override public void run() &#123; synchronized (myLock.lock2)&#123; System.out.println(&quot;这是myThread2的第一层，已经持有lock2&quot;);//死锁情况下，只有这行能输出 synchronized (myLock.lock1)&#123; System.out.println(&quot;这是myThread2的第二层，已经持有lock2和lock1&quot;); &#125; &#125; &#125;&#125;class myThread1 implements Runnable&#123; @Override public void run() &#123; synchronized (myLock.lock1)&#123; System.out.println(&quot;这是myThread1的第一层,已经持有lock1&quot;);//死锁情况下，只有这行能输出 synchronized (myLock.lock2)&#123; System.out.println(&quot;这是myThead1的第二层，已经持有lock1和lock2&quot;); &#125; &#125; &#125;&#125;class myLock&#123; static Object lock1=new Object(); static Object lock2=new Object();&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"解决线程安全的方式","slug":"解决线程安全的方式","date":"2021-05-28T16:00:00.000Z","updated":"2021-05-29T13:27:53.163Z","comments":true,"path":"2021/05/29/解决线程安全的方式/","link":"","permalink":"http://example.com/2021/05/29/%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"","text":"一：同步代码块synchronized(同步监视器){ //需要被同步的代码 } 说明： 1.操作共享数据的代码，即为需要被同步的代码。 –&gt;不能包含代码多了，也不能包含代码少了。 ​ 2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 ​ 3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。 ​ 要求：多个线程必须要共用同一把锁。 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。 ​ 在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视 二：同步方法如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 关于同步方法的总结： \\1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 \\2. 非静态的同步方法，同步监视器是：this 静态的同步方法，同步监视器是：当前类本身 同步代码块和同步方法的对比： 其实还是同步代码块好一些，因为同步方法的作用范围相对来说会比较广泛，很容易会包括进一些没必要同步的代码，这样会造成效率降低。 三：同步锁Lock（jdk5.0新增，也就是建议用）在需要同步的代码前调用Lock 的lock函数，在需要同步的代码执行完之后，手动调用unlock函数才能释放锁。（创建lock对象时，用的时reentrantlock这个类创建的） synchronize和lock的异同：同：都可以解决线程安全问题 异：synchronize在执行完对应的代码块之后，会自动释放锁；lock必须手动释放锁","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Java并发","slug":"Java并发","date":"2021-05-27T11:47:41.000Z","updated":"2021-05-27T12:17:59.544Z","comments":true,"path":"2021/05/27/Java并发/","link":"","permalink":"http://example.com/2021/05/27/Java%E5%B9%B6%E5%8F%91/","excerpt":"","text":"JMM概述 不同线程之间无法直接访问对方工作内存中的变量，线程间的通信方式一般有三种方式进行： 1、wait/notify 2、利用共享内存 3、while轮询 JMM采用的就是共享内存方式实现线程间通讯。 可见性、原子性、有序性可见性：指线程之间的可见性，一个线程修改的状态对另外一个线程是可见的。（volatile可以保证变量的可见性） 原子性：指一个操作或者多个操作要么都执行，要么都不执行。（synchronized可保证原子性） 有序性：对于一个线程的代码而言，我们总是以为代码的执行是从前往后的，依次执行的。这么说不能说完全不对，在单线程程序里，确实会这样执行；但是在多线程并发时，程序的执行就有可能出现乱序。用一句话可以总结为：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行语义（WithIn Thread As-if-Serial Semantics）”,后半句是指“指令重排”现象和“工作内存和主内存同步延迟”现象。 一个最经典的例子就是银行汇款问题，一个银行账户存款100，这时一个人从该账户取10元，同时另一个人向该账户汇10元，那么余额应该还是100。那么此时可能发生这种情况，A线程负责取款，B线程负责汇款，A从主内存读到100，B从主内存读到100，A执行减10操作，并将数据刷新到主内存，这时主内存数据100-10=90，而B内存执行加10操作，并将数据刷新到主内存，最后主内存数据100+10=110，显然这是一个严重的问题，我们要保证A线程和B线程有序执行，先取款后汇款或者先汇款后取款，此为有序性。 Java提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性,volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现， 在单线程程序中，不会发生“指令重排”和“工作内存和主内存同步延迟”现象，只在多线程程序中出现。 Happen before原则定义了哪些指令不能重排：单线程的happen before原则 写在前面的操作happen before后面的操作 锁的happen-before原则： 同一个锁的unlock操作happen-before此锁的lock操作。 volatile的happen-before原则： 对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。 happen-before的传递性原则： 如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。 线程启动的happen-before原则： 同一个线程的start方法happen-before此线程的其它方法。 线程中断的happen-before原则： 对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。 线程终结的happen-before原则： 线程中的所有操作都happen-before线程的终止检测。 对象创建的happen-before原则： 一个对象的初始化完成先于他的finalize方法调用。 哪些会进行重排：执行程序时为了提高性能，编译器和处理器经常会对指令进行重新排序。 编译器优化的重排序： 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 内存系统的重排序： 由于处理器使用的是缓存和读写缓冲区，看上去像是乱序执行。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Java各种对比","slug":"Java各种对比","date":"2021-05-26T16:00:00.000Z","updated":"2021-05-27T09:09:27.122Z","comments":true,"path":"2021/05/27/Java各种对比/","link":"","permalink":"http://example.com/2021/05/27/Java%E5%90%84%E7%A7%8D%E5%AF%B9%E6%AF%94/","excerpt":"","text":"四种权限的作用范围对比： public protected default private 同一个类 可 可 可 可 同一个包 可 可 可 不可 子类父类 可 可 不可 不可 不同包之间 可 不可 不可 不可 ==和equals对比 ==是判断两个变量是否指向同一块内存空间；equals是判断两个变量或实例所指向的内存空间的值是否相同 ==是对内存地址进行比较，equals则是对内容进行比较； ==比较引用是否相同，equals比较值是否相同 comparable和comparator对比Comparable​ 一个类的实现接口，属于内嵌比较。创建一个类时可实现该接口，重写compareTo()方法，用于自定比较方法，之后可采用collections中的sort方法进行排序。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author Mithrandir * @date 2021-04-2021/4/12-14:50 * 类实现comparable接口，可以理解为将比较方式嵌入自身，便可以直接调用Collections的sort方法 * （因为实现接口时重写的compareTo方法定义了比较方法） */public class ComparableLearn &#123; @Test public void test()&#123; List&lt;Person&gt; list = new ArrayList&lt;&gt;(); list.add(new Person(5)); list.add(new Person(1)); list.add(new Person(9)); list.add(new Person(7)); Collections.sort(list); for(Person person:list)&#123; System.out.println(person); &#125; &#125;&#125;class Person implements Comparable&lt;Person&gt; &#123; private int age; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;age=&quot; + age + &#x27;&#125;&#x27;; &#125; public Person() &#123; &#125; public Person(int age) &#123; this.age = age; &#125; @Override public int compareTo(Person o) &#123; return this.age-o.age; &#125;&#125; Comparator1234567891011121314151617181920212223242526272829303132333435363738394041/** * @author Mithrandir * @date 2021-04-2021/4/12-14:59 * comparator作为一个临时比较器，在调用collections的sort方法时写一个比较方法 */public class ComparatorLearn &#123; @Test public void test()&#123; List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student(2)); list.add(new Student(6)); list.add(new Student(1)); list.add(new Student(9)); Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.age-o2.age; &#125; &#125;); for(Student student:list)&#123; System.out.println(student); &#125; &#125;&#125;class Student &#123; int age; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;age=&quot; + age + &#x27;&#125;&#x27;; &#125; public Student() &#123; &#125; public Student(int age) &#123; this.age = age; &#125;&#125; String和StringBuilder和StringBufferString: 底层用的是final char[] StringBuilder: 线程安全 StringBuilder: 线程不安全，效率高 重载和重写重载在同一个class内对同一个函数进行重载，必须保证形参个数或者形参类型不同 重写用于子类继承父类，对父类中方法的重写 基本数据类型和引用数据类型基本数据类型boolean、byte、int、char、long、short、double、float 引用数据类型数组、类、接口… 为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 基本类型 对应的包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 基本使用对比 Integer是int的包装类；int是基本数据类型； Integer变量必须实例化后才能使用；int变量不需要； Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； Integer的默认值是null；int的默认值是0 深度使用对比 由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。 Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）。 非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。因为非new生成的Integer变量指向的是静态常量池中cache数组中存储的指向了堆中的Integer对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的对象引用（地址）不同。 对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false 对于第4条的原因： java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)。而java API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127这个Integer对象进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。 并发和并行并发（concurrent）交替做不同事情的能力；不同代码块交替执行的能力 程序需要被设计成能处理多个同时（几乎是同时）发生的事情 并行（parallelism）同时做不同事情的能力；不同代码块同时执行 通过将问题中的多个部分并行执行，加速解决问题。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础知识点","slug":"基础知识点","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"Volatile关键字","slug":"Volatile关键字","date":"2021-05-26T16:00:00.000Z","updated":"2021-05-27T12:16:26.726Z","comments":true,"path":"2021/05/27/Volatile关键字/","link":"","permalink":"http://example.com/2021/05/27/Volatile%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"volatile关键字volatile 是一个类型修饰符。volatile 的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略 特性： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（实现可见性） 禁止进行指令重排序。（保证一定程度上的原子性） volatile 只能保证对单次读/写的原子性。i++ 这种操作不能保证原子性 简单介绍下指令重排 第一个为读操作时，第二个任何操作不可重排序到第一个前面。 第二个为写操作时，第一个任何操作不可重排序到第二个后面。 第一个为写操作时，第二个的读写操作也不运行重排序。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"常见的线程调度算法","slug":"常见的线程调度算法","date":"2021-05-26T16:00:00.000Z","updated":"2021-05-27T12:31:51.123Z","comments":true,"path":"2021/05/27/常见的线程调度算法/","link":"","permalink":"http://example.com/2021/05/27/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/","excerpt":"","text":"先来先服务（first come first serverd）优点： 易于实现，相当公平； 缺点： 有利于长进程，不利于短进程 短作业优先（shortest job first）优点： 平均周转时间最短，进程等待时间最短，可以增大系统吞吐量 缺点： 难以预测进程执行时间，开销较大；不利于长进程 最短剩余时间优先（shortest remaining time next）按预估剩余时间最短顺序进行调度 高优先权优先调度算法为了照顾紧迫型作业，使之在进入系统后便获得优先处理。 1、非抢占式优先权算法 2、抢占式优先权算法 高响应比优先调度算法根据比率：R=(w+s)/s （R为响应比，w为等待处理的时间，s为预计的服务时间） 如果该进程被立即调用，则R值等于归一化周转时间（周转时间和服务时间的比率）。R最小值为1.0，只有第一个进入系统的进程才能达到该值。调度规则为：当前进程完成或被阻塞时，选择R值最大的就绪进程，它说明了进程的年龄。当偏向短作业时，长进程由于得不到服务，等待时间不断增加，从而增加比值，最终在竞争中赢了短进程。 和最短进程优先、最短剩余时间优先一样，使用最高响应比策略需要估计预计服务时间。 时间片轮转法轮转法是基于适中的抢占策略的，以一个周期性间隔产生时钟中断，当中断发生后，当前正在运行的进程被置于就绪队列中，然后基于先来先去服务策略选择下一个就绪作业的运行。这种技术也称为时间片，因为每个进程再被抢占之前都给定一片时间。 多级反馈队列多级反馈队列算法，不必事先知道各种进程所需要执行的时间，他是当前被公认的一种较好的进程调度算法。其实施过程如下： 1)设置多个就绪队列，并为各个队列赋予不同的优先级。在优先权越高的队列中，为每个进程所规定的执行时间片就越小。 2)当一个新进程进入内存后，首先放入第一队列的末尾，按照先来先去原则排队等候调度。如果他能在一个时间片中完成，便可撤离；如果未完成，就转入第二队列的末尾，同样等待调度…..如此下去，当一个长作业（进程）从第一队列依次将到第n队列（最后队列）后，便按第n队列时间片轮转运行。 3)仅当第一队列空闲的时候，调度程序才调度第二队列中的进程运行；仅当第1到（i-1）队列空时，才会调度第i队列中的进程运行，并执行相应的时间片轮转。 4)如果处理机正在处理第i队列中某进程，又有新进程进入优先权较高的队列，则此新队列抢占正在运行的处理机，并把正在运行的进程放在第i队列的队尾。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"线程状态","slug":"线程状态","date":"2021-05-26T16:00:00.000Z","updated":"2021-05-27T12:18:02.409Z","comments":true,"path":"2021/05/27/线程状态/","link":"","permalink":"http://example.com/2021/05/27/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/","excerpt":"","text":"线程的状态新建状态（new） 线程创建之后 可运行（running） 可能正在运行，也可能正在等待cpu时间片 阻塞（blocked） 等待获取一个排他锁，如果其他线程释放了锁就会结束此状态 无限期等待（waiting） 等待其他线程显示唤醒，否则不会分配cpu时间片 限期等待（time_waiting） 无需其他线程进行显示唤醒，到达时间之后会被系统自动唤醒 终止（terminated） 可能是任务结束之后的终止，也可能是出现异常终止","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"线程进程协程","slug":"进程线程协程","date":"2021-05-26T16:00:00.000Z","updated":"2021-05-27T12:24:31.807Z","comments":true,"path":"2021/05/27/进程线程协程/","link":"","permalink":"http://example.com/2021/05/27/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/","excerpt":"","text":"进程一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。 线程进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。 与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 进程与线程的区别总结线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。 根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行 多进程和多线程区别多进程：操作系统中同时运行的多个程序 多线程：在同一个进程中同时运行的多个任务 举个例子，多线程下载软件，可以同时运行多个线程，但是通过程序运行的结果发现，每一次结果都不一致。 因为多线程存在一个特性：随机性。造成的原因：CPU在瞬间不断切换去处理各个线程而导致的，可以理解成多个线程在抢CPU资源。 Java中的多线程Java程序的进程里有几个线程：主线程，垃圾回收线程(后台线程)等 在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。 Java支持多线程，当Java程序执行main方法的时候，就是在执行一个名字叫做main的线程，可以在main方法执行时，开启多个线程A,B,C，多个线程 main,A,B,C同时执行，相互抢夺CPU，Thread类是java.lang包下的一个常用类,每一个Thread类的对象，就代表一个处于某种状态的线程 从 JVM 角度说进程和线程之间的关系（重要） 从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。 程序计数器为什么是私有的? 程序计数器主要有下面两个作用： 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。 所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。 虚拟机栈和本地方法栈为什么是私有的? 虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 本地方法栈：和虚拟机栈所发挥的作用非常相似，区别是:虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。 所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。 一句话简单了解堆和方法区 堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 来自 https://blog.csdn.net/ThinkWon/article/details/102021274 协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。 最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。 这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。 既然协程这么好，它到底是怎么来使用的呢？ 由于Java的原生语法中并没有实现协程（某些开源框架实现了协程，但是很少被使用）； 协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。 因此，协程的开销远远小于线程的开销。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"进程间通信方式","slug":"进程间的通信方式","date":"2021-05-26T16:00:00.000Z","updated":"2021-05-27T12:27:53.804Z","comments":true,"path":"2021/05/27/进程间的通信方式/","link":"","permalink":"http://example.com/2021/05/27/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/","excerpt":"","text":"进程之间的通信方式1.无名管道( pipe )： 管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 2.高级管道(popen)： 将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。 3.有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 4.消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 5.信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 6.信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 7.共享内存( shared memory ) ： 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 8.套接字( socket ) ： 套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Java反射机制","slug":"Java反射机制","date":"2021-05-26T16:00:00.000Z","updated":"2021-05-31T09:49:15.329Z","comments":true,"path":"2021/05/27/Java反射机制/","link":"","permalink":"http://example.com/2021/05/27/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Java反射机制一、什么是反射：（1）Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。 （2）Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。 二、反射的原理：下图是类的正常加载过程、反射原理与class对象： Class对象的由来是将.class文件读入内存，并为之创建一个Class对象。 对于类加载机制与双亲委派模型感兴趣的小伙伴可以阅读这篇文章 三、反射的优缺点优点：在运行时获得类的各种内容，进行反编译，对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。 缺点：（1）反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射； （2）反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。 四、反射的用途1、反编译：.class–&gt;.java 2、通过反射机制访问java对象的属性，方法，构造方法等 3、当我们在使用IDE,比如Ecplise时，当我们输入一个对象或者类，并想调用他的属性和方法是，一按点号，编译器就会自动列出他的属性或者方法，这里就是用到反射。 4、反射最重要的用途就是开发各种通用框架。比如很多框架（Spring）都是配置化的（比如通过XML文件配置Bean），为了保证框架的通用性，他们可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象。 5、例如，在使用Strut2框架的开发过程中，我们一般会在struts.xml里去配置Action，比如 1234567&lt;action name=&quot;login&quot; class=&quot;org.ScZyhSoft.test.action.SimpleLoginAction&quot; method=&quot;execute&quot;&gt; &lt;result&gt;/shop/shop-index.jsp&lt;/result&gt; &lt;result name=&quot;error&quot;&gt;login.jsp&lt;/result&gt; &lt;/action&gt; 比如我们请求login.action时，那么StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，从action中查找出name为login的Action，并根据class属性创建SimpleLoginAction实例，并用Invoke方法来调用execute方法，这个过程离不开反射。配置文件与Action建立了一种映射关系，当View层发出请求时，请求会被StrutsPrepareAndExecuteFilter拦截，然后StrutsPrepareAndExecuteFilter会去动态地创建Action实例。 比如，加载数据库驱动的，用到的也是反射。 Class.forName(“com.mysql.jdbc.Driver”); // 动态加载mysql驱动 五、反射的基本使用获得Class：主要有三种方法：（1）Object–&gt;getClass （2）任何数据类型（包括基本的数据类型）都有一个“静态”的class属性 （3）通过class类的静态方法：forName(String className)（最常用） 12345678910111213141516171819202122package fanshe;public class Fanshe &#123; public static void main(String[] args) &#123; //第一种方式获取Class对象 Student stu1 = new Student();//这一new 产生一个Student对象，一个Class对象。 Class stuClass = stu1.getClass();//获取Class对象 System.out.println(stuClass.getName()); //第二种方式获取Class对象 Class stuClass2 = Student.class; System.out.println(stuClass == stuClass2);//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个 //第三种方式获取Class对象 try &#123; Class stuClass3 = Class.forName(&quot;fanshe.Student&quot;);//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名 System.out.println(stuClass3 == stuClass2);//判断三种方式是否获取的是同一个Class对象 &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意，在运行期间，一个类，只有一个Class对象产生，所以打印结果都是true； 三种方式中，常用第三种，第一种对象都有了还要反射干什么，第二种需要导入类包，依赖太强，不导包就抛编译错误。一般都使用第三种，一个字符串可以传入也可以写在配置文件中等多种方法。 判断是否为某个类的示例：一般的，我们使用instanceof 关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断时候为某个类的实例，他是一个native方法。 public native boolean isInstance(Object obj); 创建实例：通过反射来生成对象主要有两种方法：（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。 Class&lt;?&gt; c = String.class; Object str = c.newInstance(); （2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建对象，这种方法可以用指定的构造器构造类的实例。 //获取String的Class对象 Class&lt;?&gt; str = String.class; //通过Class对象获取指定的Constructor构造器对象 Constructor constructor=c.getConstructor(String.class); //根据构造器创建实例： Object obj = constructor.newInstance(“hello reflection”); 通过反射获取构造方法并使用：（1）批量获取的方法： public Constructor[] getConstructors()：所有”公有的”构造方法 public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有) （2）单个获取的方法，并调用： public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法： public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有； （3） 调用构造方法： Constructor–&gt;newInstance(Object… initargs) newInstance是 Constructor类的方法（管理构造函数的类） api的解释为：newInstance(Object… initargs) ，使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象，并为之调用。 例子： Student类：共六个构造方法 1234567891011121314151617181920212223242526272829package fanshe;public class Student &#123; //---------------构造方法------------------- //（默认的构造方法） Student(String str)&#123; System.out.println(&quot;(默认)的构造方法 s = &quot; + str); &#125; //无参构造方法 public Student()&#123; System.out.println(&quot;调用了公有、无参构造方法执行了。。。&quot;); &#125; //有一个参数的构造方法 public Student(char name)&#123; System.out.println(&quot;姓名：&quot; + name); &#125; //有多个参数的构造方法 public Student(String name ,int age)&#123; System.out.println(&quot;姓名：&quot;+name+&quot;年龄：&quot;+ age);//这的执行效率有问题，以后解决。 &#125; //受保护的构造方法 protected Student(boolean n)&#123; System.out.println(&quot;受保护的构造方法 n = &quot; + n); &#125; //私有构造方法 private Student(int age)&#123; System.out.println(&quot;私有的构造方法 年龄：&quot;+ age); &#125;&#125; 测试类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package fanshe;import java.lang.reflect.Constructor; /* * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员； * * 1.获取构造方法： * 1).批量的方法： * public Constructor[] getConstructors()：所有&quot;公有的&quot;构造方法 public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有) * 2).获取单个的方法，并调用： * public Constructor getConstructor(Class... parameterTypes):获取单个的&quot;公有的&quot;构造方法： * public Constructor getDeclaredConstructor(Class... parameterTypes):获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有； * 3).调用构造方法： * Constructor--&gt;newInstance(Object... initargs) */public class Constructors &#123; public static void main(String[] args) throws Exception &#123; //1.加载Class对象 Class clazz = Class.forName(&quot;fanshe.Student&quot;); //2.获取所有公有构造方法 System.out.println(&quot;**********************所有公有构造方法*********************************&quot;); Constructor[] conArray = clazz.getConstructors(); for(Constructor c : conArray)&#123; System.out.println(c); &#125; System.out.println(&quot;************所有的构造方法(包括：私有、受保护、默认、公有)***************&quot;); conArray = clazz.getDeclaredConstructors(); for(Constructor c : conArray)&#123; System.out.println(c); &#125; System.out.println(&quot;*****************获取公有、无参的构造方法*******************************&quot;); Constructor con = clazz.getConstructor(null); //1&gt;、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型 //2&gt;、返回的是描述这个无参构造函数的类对象。 System.out.println(&quot;con = &quot; + con); //调用构造方法 Object obj = con.newInstance(); // System.out.println(&quot;obj = &quot; + obj); // Student stu = (Student)obj; System.out.println(&quot;******************获取私有构造方法，并调用*******************************&quot;); con = clazz.getDeclaredConstructor(char.class); System.out.println(con); //调用构造方法 con.setAccessible(true);//暴力访问(忽略掉访问修饰符) obj = con.newInstance(&#x27;男&#x27;); &#125;&#125; 控制台输出： 所有公有构造方法*********** public fanshe.Student(java.lang.String,int) public fanshe.Student(char) public fanshe.Student() 所有的构造方法(包括：私有、受保护、默认、公有)*** private fanshe.Student(int) protected fanshe.Student(boolean) public fanshe.Student(java.lang.String,int) public fanshe.Student(char) public fanshe.Student() fanshe.Student(java.lang.String) 获取公有、无参的构造方法************** con = public fanshe.Student() 调用了公有、无参构造方法执行了。。。 获取私有构造方法，并调用************* public fanshe.Student(char) 姓名：男 获取成员变量并调用：Student类： 1234567891011121314151617package fanshe.field; public class Student &#123; public Student()&#123; &#125; //**********字段*************// public String name; protected int age; char sex; private String phoneNum; @Override public String toString() &#123; return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex + &quot;, phoneNum=&quot; + phoneNum + &quot;]&quot;; &#125;&#125; 测试类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package fanshe.field;import java.lang.reflect.Field;/* * 获取成员变量并调用： * * 1.批量的 * 1).Field[] getFields():获取所有的&quot;公有字段&quot; * 2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有； * 2.获取单个的： * 1).public Field getField(String fieldName):获取某个&quot;公有的&quot;字段； * 2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的) * * 设置字段的值： * Field --&gt; public void set(Object obj,Object value): * 参数说明： * 1.obj:要设置的字段所在的对象； * 2.value:要为字段设置的值； */public class Fields &#123; public static void main(String[] args) throws Exception &#123; //1.获取Class对象 Class stuClass = Class.forName(&quot;fanshe.field.Student&quot;); //2.获取字段 System.out.println(&quot;************获取所有公有的字段********************&quot;); Field[] fieldArray = stuClass.getFields(); for(Field f : fieldArray)&#123; System.out.println(f); &#125; System.out.println(&quot;************获取所有的字段(包括私有、受保护、默认的)********************&quot;); fieldArray = stuClass.getDeclaredFields(); for(Field f : fieldArray)&#123; System.out.println(f); &#125; System.out.println(&quot;*************获取公有字段**并调用***********************************&quot;); Field f = stuClass.getField(&quot;name&quot;); System.out.println(f); //获取一个对象 Object obj = stuClass.getConstructor().newInstance();//产生Student对象--》Student stu = new Student(); //为字段设置值 f.set(obj, &quot;刘德华&quot;);//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot; //验证 Student stu = (Student)obj; System.out.println(&quot;验证姓名：&quot; + stu.name); System.out.println(&quot;**************获取私有字段****并调用********************************&quot;); f = stuClass.getDeclaredField(&quot;phoneNum&quot;); System.out.println(f); f.setAccessible(true);//暴力反射，解除私有限定 f.set(obj, &quot;18888889999&quot;); System.out.println(&quot;验证电话：&quot; + stu); &#125; &#125; 获取所有公有的字段******** public java.lang.String fanshe.field.Student.name 获取所有的字段(包括私有、受保护、默认的)******** public java.lang.String fanshe.field.Student.name protected int fanshe.field.Student.age char fanshe.field.Student.sex private java.lang.String fanshe.field.Student.phoneNum **获取公有字段并调用************************** public java.lang.String fanshe.field.Student.name 验证姓名：刘德华 *获取私有字段并调用*********************** private java.lang.String fanshe.field.Student.phoneNum 验证电话：Student [name=刘德华, age=0, sex= 获取成员方法并调用：Student类： 123456789101112131415161718package fanshe.method; public class Student &#123; //**************成员方法***************// public void show1(String s)&#123; System.out.println(&quot;调用了：公有的，String参数的show1(): s = &quot; + s); &#125; protected void show2()&#123; System.out.println(&quot;调用了：受保护的，无参的show2()&quot;); &#125; void show3()&#123; System.out.println(&quot;调用了：默认的，无参的show3()&quot;); &#125; private String show4(int age)&#123; System.out.println(&quot;调用了，私有的，并且有返回值的，int参数的show4(): age = &quot; + age); return &quot;abcd&quot;; &#125;&#125; 测试类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package fanshe.method;import java.lang.reflect.Method; /* * 获取成员方法并调用： * * 1.批量的： * public Method[] getMethods():获取所有&quot;公有方法&quot;；（包含了父类的方法也包含Object类） * public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的) * 2.获取单个的： * public Method getMethod(String name,Class&lt;?&gt;... parameterTypes): * 参数： * name : 方法名； * Class ... : 形参的Class类型对象 * public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes) * * 调用方法： * Method --&gt; public Object invoke(Object obj,Object... args): * 参数说明： * obj : 要调用方法的对象； * args:调用方式时所传递的实参；): */public class MethodClass &#123; public static void main(String[] args) throws Exception &#123; //1.获取Class对象 Class stuClass = Class.forName(&quot;fanshe.method.Student&quot;); //2.获取所有公有方法 System.out.println(&quot;***************获取所有的”公有“方法*******************&quot;); stuClass.getMethods(); Method[] methodArray = stuClass.getMethods(); for(Method m : methodArray)&#123; System.out.println(m); &#125; System.out.println(&quot;***************获取所有的方法，包括私有的*******************&quot;); methodArray = stuClass.getDeclaredMethods(); for(Method m : methodArray)&#123; System.out.println(m); &#125; System.out.println(&quot;***************获取公有的show1()方法*******************&quot;); Method m = stuClass.getMethod(&quot;show1&quot;, String.class); System.out.println(m); //实例化一个Student对象 Object obj = stuClass.getConstructor().newInstance(); m.invoke(obj, &quot;刘德华&quot;); System.out.println(&quot;***************获取私有的show4()方法******************&quot;); m = stuClass.getDeclaredMethod(&quot;show4&quot;, int.class); System.out.println(m); m.setAccessible(true);//解除私有限定 Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参 System.out.println(&quot;返回值：&quot; + result); &#125;&#125; 控制台输出： 获取所有的”公有“方法**** public void fanshe.method.Student.show1(java.lang.String) public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException public final void java.lang.Object.wait() throws java.lang.InterruptedException public boolean java.lang.Object.equals(java.lang.Object) public java.lang.String java.lang.Object.toString() public native int java.lang.Object.hashCode() public final native java.lang.Class java.lang.Object.getClass() public final native void java.lang.Object.notify() public final native void java.lang.Object.notifyAll() 获取所有的方法，包括私有的**** public void fanshe.method.Student.show1(java.lang.String) private java.lang.String fanshe.method.Student.show4(int) protected void fanshe.method.Student.show2() void fanshe.method.Student.show3() 获取公有的show1()方法**** public void fanshe.method.Student.show1(java.lang.String) 调用了：公有的，String参数的show1(): s = 刘德华 获取私有的show4()方法*** private java.lang.String fanshe.method.Student.show4(int) 调用了，私有的，并且有返回值的，int参数的show4(): age = 20 返回值：abcd 反射main方法:Student类： 1234567891011121314151617181920212223242526272829303132333435package fanshe.main; public class Student &#123; public static void main(String[] args) &#123; System.out.println(&quot;main方法执行了。。。&quot;); &#125;&#125;测试类：package fanshe.main;import java.lang.reflect.Method; /** * 获取Student类的main方法、不要与当前的main方法搞混了 */public class Main &#123; public static void main(String[] args) &#123; try &#123; //1、获取Student对象的字节码 Class clazz = Class.forName(&quot;fanshe.main.Student&quot;); //2、获取main方法 Method methodMain = clazz.getMethod(&quot;main&quot;, String[].class);//第一个参数：方法名称，第二个参数：方法形参的类型， //3、调用main方法 // methodMain.invoke(null, new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;); //第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数 //这里拆的时候将 new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125; 拆成3个对象。。。所以需要将它强转。 methodMain.invoke(null, (Object)new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);//方式一 // methodMain.invoke(null, new Object[]&#123;new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;&#125;);//方式二 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 控制台输出： main方法执行了。。。 利用反射创建数值：数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。 123456789101112public static void testArray() throws ClassNotFoundException &#123; Class&lt;?&gt; cls = Class.forName(&quot;java.lang.String&quot;); Object array = Array.newInstance(cls,25); //往数组里添加内容 Array.set(array,0,&quot;golang&quot;); Array.set(array,1,&quot;Java&quot;); Array.set(array,2,&quot;pytho&quot;); Array.set(array,3,&quot;Scala&quot;); Array.set(array,4,&quot;Clojure&quot;); //获取某一项的内容 System.out.println(Array.get(array,3));&#125; 反射方法的其他使用–通过反射运行配置文件内容：Student类： 12345public class Student &#123; public void show()&#123; System.out.println(&quot;is show()&quot;); &#125;&#125; 配置文件以txt文件为例子： className = cn.fanshe.Student methodName = show 测试类： 123456789101112131415161718192021222324252627282930import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.lang.reflect.Method;import java.util.Properties; /* * 我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改 * 我们只需要将新类发送给客户端，并修改配置文件即可 */public class Demo &#123; public static void main(String[] args) throws Exception &#123; //通过反射获取Class对象 Class stuClass = Class.forName(getValue(&quot;className&quot;));//&quot;cn.fanshe.Student&quot; //2获取show()方法 Method m = stuClass.getMethod(getValue(&quot;methodName&quot;));//show //3.调用show()方法 m.invoke(stuClass.getConstructor().newInstance()); &#125; //此方法接收一个key，在配置文件中获取相应的value public static String getValue(String key) throws IOException&#123; Properties pro = new Properties();//获取配置文件的对象 FileReader in = new FileReader(&quot;pro.txt&quot;);//获取输入流 pro.load(in);//将流加载到配置文件对象中 in.close(); return pro.getProperty(key);//返回根据key获取的value值 &#125;&#125; 控制台输出： is show() 需求： 当我们升级这个系统时，不要Student类，而需要新写一个Student2的类时，这时只需要更改pro.txt的文件内容就可以了。代码就一点不用改动。 12345public class Student2 &#123; public void show2()&#123; System.out.println(&quot;is show2()&quot;); &#125;&#125; 配置文件更改为： className = cn.fanshe.Student2 methodName = show2 反射方法的其他使用–通过反射越过泛型检查：泛型用在编译期，编译过后泛型擦除（消失掉），所以是可以通过反射越过泛型检查的 测试类 12345678910111213141516171819202122232425262728import java.lang.reflect.Method;import java.util.ArrayList; /* * 通过反射越过泛型检查 * 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？ */public class Demo &#123; public static void main(String[] args) throws Exception&#123; ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add(&quot;aaa&quot;); strList.add(&quot;bbb&quot;); // strList.add(100); //获取ArrayList的Class对象，反向的调用add()方法，添加数据 Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象 //获取add()方法 Method m = listClass.getMethod(&quot;add&quot;, Object.class); //调用add()方法 m.invoke(strList, 100); //遍历集合 for(Object obj : strList)&#123; System.out.println(obj); &#125; &#125;&#125; 控制台输出： aaa bbb 100 版权声明：本文为CSDN博主「张维鹏」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/a745233700/article/details/82893076","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-05-26T11:13:32.332Z","updated":"2021-05-26T11:13:32.332Z","comments":true,"path":"2021/05/26/hello-world/","link":"","permalink":"http://example.com/2021/05/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"排序算法总结","slug":"排序算法","date":"2021-05-25T16:00:00.000Z","updated":"2021-05-27T02:24:53.339Z","comments":true,"path":"2021/05/26/排序算法/","link":"","permalink":"http://example.com/2021/05/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"冒泡排序简析：比较相邻的两个元素，如果当前数字比后面的数字大，就交换位置 下列代码做了改进，从数组的末尾开始比较，除了能将最小元素移动至第一位外，还将第二小的元素尽可能的移动至靠近适合它的位置。 123456789101112public void bubbleSort(int[] arr)&#123; int i,j,len=arr.length-1; for(i=0;i&lt;len;i++)&#123; for(j=len-1;j&gt;=i;--j)&#123; if(arr[j]&gt;arr[j+1])&#123; int tmp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=tmp; &#125; &#125; &#125;&#125; 选择排序简析：在未排序的序列中，找到最小的元素，放到排列元素的起始位置；然后再从未排序的序列中找到最小的元素，放到已排序序列的末尾，依次类推，直至末尾。 1234567891011121314public void selectSort(int[] arr)&#123; int minIndex; for(int i=0;i&lt;arr.length;i++)&#123; minIndex=i; for(int j=i;j&lt;arr.length;j++)&#123; if(arr[j]&lt;arr[minIndex])&#123; minIndex=j; &#125; &#125; int tmp=arr[minIndex]; arr[minIndex]=arr[i]; arr[i]=tmp; &#125;&#125; 插入排序简析：对于未排序的序列，在已排序的序列中从后往前扫描，找到合适的位置并插入。 123456789101112public void InsertSort(int[] arr)&#123; int len=arr.length; for(int i=1;i&lt;len;i++)&#123; int insertVal=arr[i];//要插入的值 int insertIndex=i-1;//要插入的值的前一个坐标 while(inserIndex&gt;=0&amp;&amp;insertVal&lt;arr[insertIndex])&#123; arr[insertIndex+1]=arr[insertIndex]; intsertIndex--; &#125;//跳出循环时说明要插入的位置在insertIndex后面 arr[insertIndex+1]=insertVal; &#125;&#125; 希尔排序简析：希尔排序是插入排序的优化版，通过设置不同的步长并逐步减少步长，以步长为单次移动距离，可大幅缩短所需时间。 12345678910111213141516171819public void shellSort(int[] arr)&#123; int len=arr.length; for(int step=len/2;step&gt;0;step/=2)&#123; for(int i=step;i&lt;len;i++)&#123; //记录下要移动的元素下标 int tmpIndex=i; //记录下要移动的元素值 int tmpVal=arr[tmpIndex]; //如果需要移动，那就移动至合适的位置 if(tmpVal&lt;arr[tmmIndex-step])&#123; while(temIndex-step&gt;=0&amp;&amp;tmpVal&lt;arr[tmpIndex-step])&#123; arr[tmpIndex]=arr[tmpIndex-step]; tmpIndex-=step; &#125; &#125;//tmpIndex已经是合适的位置 arr[tmpIndex]=tmpVal; &#125; &#125;&#125; 归并排序简析：将已有序的子序列合并；起始默认单个元素既是一个有序序列。 12345678910111213141516171819202122232425262728293031323334353637383940public class MergeSort &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;8, 4, 5, 7, 1, 3, 6, 2&#125;; int[] tmp = new int[arr.length]; sort(arr,0,arr.length-1,tmp); System.out.println(Arrays.toString(arr)); &#125; private static void sort(int[] arr,int left,int right,int[] tmp) &#123; if(left&gt;=right)&#123; return; &#125; int mid=left+(right-left)/2; sort(arr, left,mid,tmp); sort(arr, mid+1, right,tmp); if(arr[mid]&lt;=arr[mid+1])&#123; return; &#125; merge(arr,left,right,mid,tmp); &#125; private static void merge(int[] arr, int left, int right, int mid,int[] tmp) &#123; int i=left; int j=mid+1; for (int k = left; k &lt;= right; k++) &#123; tmp[k]=arr[k]; &#125; for(int k=left ;k&lt;=right;k++)&#123; if(i==mid+1)&#123; arr[k]=tmp[j++]; &#125;else if(j==right+1)&#123; arr[k]=tmp[i++]; &#125;else if(tmp[i]&lt;=tmp[j])&#123; arr[k]=tmp[i++]; &#125;else&#123; arr[k]=tmp[j++]; &#125; &#125; &#125;&#125; 快速排序简析：通过指定一个pivot，使得数组以pivot为基准，大于pivot的都移动至pivot右边，小于pivot的都移动至其左边，然后对pivot两边的数组再次进行递归排序即可。 123456789101112131415161718192021222324public vodi quickSort(int[] arr,int l,int r)&#123; if(l&lt;r)&#123; int left=l,right=r; int pivot=arr[l]; while(left&lt;right)&#123; while(left&lt;right&amp;&amp;arr[right]&gt;=pivot)&#123;//先找到一个需要移动的right。 //注意，此处必须先寻找right，因为left位置的元素已经取出（就是pivot），所以可以先对left的位置赋值 --right; &#125; if(left&lt;right)&#123; arr[left++]=arr[right]； &#125; while(left&lt;right&amp;&amp;arr[left]&lt;=pivot)&#123; ++left; &#125; if(left&lt;right)&#123; arr[right--]=arr[left]; &#125; &#125; arr[right]=pivot;//这个赋值给left或者right都可以 quickSort(arr,l,right-1); quickSort(arr,right+1,r); &#125;&#125; 代码2： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @author Mithrandir * @date 2021-03-2021/3/27-21:36 */public class QuickSortAnother &#123; public static void main(String[] args) &#123; int[] arr=&#123;1,6,5,4,3,2,9,1&#125;; quicksort(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); &#125; /** * 随机将一个数字放至其合适的位置，并对该位置左右两区间进行排序 * @param arr 待排序的数组 * @param left 数组的左端 * @param right 数组的右端 */ private static void quicksort(int[] arr,int left,int right) &#123; if(left&gt;=right)&#123; return; &#125; int mid=partition(arr,left,right); quicksort(arr, left, mid-1); quicksort(arr, mid+1, right); &#125; /** * 这个要完成的功能是对数组内的一个随机数字安排至合适的位置，并以该位置为根据将数组分为左右区间 * @param arr * @param left * @param right * @return */ private static int partition(int[] arr, int left, int right) &#123; Random random = new Random(); //来区间内位置的一个随机位置 int tmpIndex=random.nextInt(right-left+1)+left; //将该位置的数字放到数组的最右侧 swap(arr,tmpIndex,right); //定义一个索引 int index=left; for(int i=left;i&lt;right;i++)&#123; if(arr[i]&lt;arr[right])&#123;//凡是小于我们的随机数的值，一律从左开始排 swap(arr, i, index++); &#125; &#125; //此时，index左侧的所有值，均小于随机数，将随机数放到index的位置 swap(arr,index, right); return index; &#125; private static void swap(int[] arr, int i, int j) &#123; int tmp=arr[i]; arr[i]=arr[j]; arr[j]=tmp; &#125;&#125; 计数排序简析：计数排序适用于元素数值较为集中，且元素要是确定范围内的整数 123456789101112131415161718192021222324252627282930313233public void countingSort(int[] arr)&#123; if(arr.length==0)&#123; return; &#125; //找到arr里的最大最小值 int min=arr[0],max=arr[0]; for(int i=1;i&lt;arr.length;i++)&#123; if(arr[i]&gt;max)&#123; max=arr[i]; &#125; if(arr[i]&lt;min)&#123; min=arr[i]; &#125; &#125; //定义一个关键值 int bias=0-min; //准备一个额外数组 int[] bucket=new int[max-min+1]; //遍历整个数组，记录每个元素出现的次数 for(int i=0;i&lt;arr.length;i++)&#123; bucket[arr[i]+bias]++; &#125; //接下来准备重新排列arr,index为arr的索引，i为bucket的索引 int index=0,i=0; while(index&lt;arr.length)&#123; if(bucket[i]!=0)&#123; arr[index++]=i-bias; bucket[i]--; &#125;else&#123; i++; &#125; &#125;&#125; 基数排序简析：基数和计数都是用了桶来进行排序，不同的是，基数对所有元素的分配做了优化：按照每个元素的同一位（即个位，十位等）进行摆放，也就是说，所用到的桶一共有10层（0~9），在一轮循环中，每一层放的数据在某一位都相同。基数排序用的空间取决于元素的个数，而计数排序所用的额外空间取决于元素的范围（即最小-最大）。 123456789101112131415161718192021222324252627282930313233343536373839public static void review(int[] arr) &#123; //第一步，先找到数组中的最大值 int size = arr.length; int max = arr[0]; for (int i = 1; i &lt; size; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; //根据最大值找到最大长度 String str = max + &quot;&quot;; int maxLength = str.length(); //创建一个桶，用于盛放处理后的数组 int[][] bucket = new int[10][size]; //还得创建一个计数器，用于计算每个位置放了多少个数据 int[] numsCounter = new int[10]; //接下来就进入每一层的操作：放入桶，从桶中取出 //定义两个变量，k用于确定数据的哪一层，m用于对每个数据进行取余操作 for (int k = 0, m = 1; k &lt; maxLength; m *= 10, k++) &#123; //先将数据取出，根据个（十、百）位数的大小放入桶中 for (int i = 0; i &lt; size; i++) &#123; //取出个位 int num = arr[i] / m % 10; //放入个位对应的桶中 bucket[num][numsCounter[num]++] = arr[i]; &#125; //此时已完成所有数据入桶,按照顺序将其取出 //定义一个索引，用于在arr中重新排序 int index = 0; for (int i = 0; i &lt; bucket.length; i++) &#123; if (numsCounter[i] != 0) &#123;//i的取值范围是0~9，numsCounter[i]!=0说明该位置存放的有数据，需要取出 for (int j = 0; j &lt; numsCounter[i]; j++) &#123; arr[index++] = bucket[i][j]; &#125; &#125; numsCounter[i] = 0; &#125; &#125; &#125;","categories":[{"name":"HelloWorld系列","slug":"HelloWorld系列","permalink":"http://example.com/categories/HelloWorld%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"搜索算法","slug":"搜索算法","date":"2021-05-25T16:00:00.000Z","updated":"2021-05-27T02:25:22.120Z","comments":true,"path":"2021/05/26/搜索算法/","link":"","permalink":"http://example.com/2021/05/26/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/","excerpt":"","text":"有序表查找二分查找代码如下：123456789101112131415public int binarySearch(int[] arr,int target)&#123; int low=0,height=arr.length-1; int mid; while(low&lt;=height)&#123; mid=(low+height)/2; if(arr[mid]&lt;target)&#123; low=mid+1; &#125;else if(arr[mid]&gt;target)&#123; height=mid-1; &#125;else&#123; return mid; &#125; &#125; return -1;&#125; 插值查找适用于数值分布均匀的查找表。 代码如下：123456789101112131415public int binarySearch(int[] arr,int target)&#123; int low=0,height=arr.length-1; int mid; while(low&lt;=height)&#123; mid=low+(hight-low)(arr[mid]-arr[low])/(arr[height]-arr[low]); if(arr[mid]&lt;target)&#123; low=mid+1; &#125;else if(arr[mid]&gt;target)&#123; height=mid-1; &#125;else&#123; return mid; &#125; &#125; return -1;&#125; 斐波那契查找利用了斐波那契数列 12345678910111213141516171819202122232425262728293031323334353637383940414243 public static int fibSearch(int[] arr,int target)&#123; int low=0,heigh=arr.length-1; int[] f=fib(); //k为合适的斐波那契数 int k=0; while(heigh&gt;f[k]-1)&#123; ++k; &#125; //定义斐波那契数长度的数组 int[] nums = Arrays.copyOf(arr, f[k]); for(int i=heigh;i&lt;f[k];i++)&#123; nums[i]=nums[heigh]; &#125; int mid; while (low&lt;=heigh)&#123; mid=low+f[k-1]-1; if(target&gt;arr[mid])&#123; k-=2; low=mid+1; &#125;else if(target&lt;arr[mid])&#123; --k; heigh=mid-1; &#125;else&#123; if(mid&lt;heigh)&#123; return mid; &#125;else&#123; return heigh; &#125; &#125; &#125; return -1; &#125;//创建一个斐波那契数列public static int[] fib()&#123; int[] f=new int[20]; f[0]=1; f[1]=1; for(int i=2;i&lt;20;i++)&#123; f[i]=f[i-1]+f[i-2]; &#125; return f; &#125;","categories":[{"name":"HelloWorld系列","slug":"HelloWorld系列","permalink":"http://example.com/categories/HelloWorld%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://example.com/tags/%E6%90%9C%E7%B4%A2/"}]}],"categories":[{"name":"读书总结","slug":"读书总结","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"},{"name":"mybatisplus","slug":"mybatisplus","permalink":"http://example.com/categories/mybatisplus/"},{"name":"项目Hospital","slug":"项目Hospital","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AEHospital/"},{"name":"小技巧","slug":"小技巧","permalink":"http://example.com/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"踩坑记录","slug":"踩坑记录","permalink":"http://example.com/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"HelloWorld系列","slug":"HelloWorld系列","permalink":"http://example.com/categories/HelloWorld%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"基础知识点","slug":"基础知识点","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"搜索","slug":"搜索","permalink":"http://example.com/tags/%E6%90%9C%E7%B4%A2/"}]}